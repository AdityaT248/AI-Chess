{"version":3,"sources":["assets/pieces/white-pawn.svg","assets/pieces/white-rook.svg","assets/pieces/white-knight.svg","assets/pieces/white-bishop.svg","assets/pieces/white-queen.svg","assets/pieces/white-king.svg","assets/pieces/black-pawn.svg","assets/pieces/black-rook.svg","assets/pieces/black-knight.svg","assets/pieces/black-bishop.svg","assets/pieces/black-queen.svg","assets/pieces/black-king.svg","components/ChessBoard.js","components/GameInfo.js","components/PromotionDialog.js","themes.js","components/ThemeSelector.js","utils/chessLogic.js","utils/aiPlayer.js","App.js","index.js"],"names":["pieceImages","whitePawn","whiteRook","whiteKnight","whiteBishop","whiteQueen","whiteKing","blackPawn","blackRook","blackKnight","blackBishop","blackQueen","blackKing","Square","memo","_ref","row","col","piece","isLight","isSelected","isHighlighted","isCheck","isLastMove","isHint","squareColor","onClick","squareClassName","squareStyle","backgroundColor","_jsx","className","style","children","captured","src","color","type","alt","Coordinates","_jsxs","map","file","rank","CapturedPieces","_ref2","capturedPieces","capturedByOpponent","black","white","length","index","ChessBoard","_ref3","board","selectedPiece","onSquareClick","highlightedSquares","checkIndicator","lastMove","hintMove","theme","useMemo","flat","forEach","push","highlightedSquaresMap","square","lastMoveMap","from","to","hintSquareMap","fromRow","fromCol","toRow","toCol","boardRows","squares","isHintSquare","lightSquare","darkSquare","containerStyle","background","boardBg","highlightColor","checkColor","lastMoveColor","accentColor","GameInfo","playerTurn","gameStatus","moveHistory","onResetGame","isInCheck","aiDifficulty","onGetHint","aiThinking","activeTab","setActiveTab","useState","groupedMoves","i","number","Math","floor","materialAdvantage","calculateMaterialAdvantage","pieceValues","whiteCaptured","blackCaptured","move","capturedPiece","advantage","value","abs","renderGameStatus","statusText","includes","disabled","notation","renderAnalysis","searchDepth","PromotionDialog","position","onSelect","onCancel","top","y","left","x","e","stopPropagation","themes","classic","name","blue","dark","green","coral","ThemeSelector","currentTheme","onThemeChange","Object","keys","themeKey","title","initializeBoard","Array","fill","hasMoved","isSquareUnderAttack","attackerColor","pawnDirection","knightMoves","rowOffset","colOffset","newRow","newCol","directions","rowDir","colDir","kingPos","findKing","opponentColor","isValidMove","gameState","targetPiece","isValid","isValidPawnMove","isValidKnightMove","isValidBishopMove","isValidRookMove","isValidQueenMove","isValidKingMove","tempBoard","makeMove","direction","enPassantTarget","start","min","end","max","rowDiff","colDiff","rowDirection","colDirection","rook","isPawnPromotion","promotionPiece","arguments","undefined","newBoard","JSON","parse","stringify","newGameState","castlingRights","kingSide","queenSide","isCheckmate","isStalemate","positionBonus","evaluationCache","Map","knightOffsets","bishop","queen","generatePieceMoves","moves","isCapture","isEnPassant","dirs","isCastling","castlingSide","findBestMove","difficulty","generateMoves","candidateMoves","pieceMoves","randomChance","random","boardHash","hash","getBoardHash","cacheKey","has","get","evaluatedMoves","score","evaluateMove","currentPositionValue","sort","a","b","topMovesCount","topMoves","slice","bestMove","set","size","clear","getAIMove","App","setBoard","setSelectedPiece","setPlayerTurn","setGameStatus","setMoveHistory","setGameState","setHighlightedSquares","setCheckIndicator","setAiDifficulty","showHint","setShowHint","setHintMove","promotionDialog","setPromotionDialog","setCurrentTheme","setAiThinking","handleMoveRef","useRef","handleMove","useCallback","newMove","generateMoveNotation","prevHistory","prevTurn","useEffect","current","makeAIMove","requestAnimationFrame","aiMove","randomMove","setTimeout","error","console","validMoves","pieceType","files","ranks","fromSquare","toSquare","charAt","toUpperCase","handleSquareClick","boardRect","document","querySelector","getBoundingClientRect","squareSize","width","handlePromotion","resetGame","handleDifficultyChange","getHint","suggestedMove","handleThemeChange","localStorage","setItem","savedTheme","getItem","currentThemeObject","Date","getFullYear","ReactDOM","render","React","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.f279bc36.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/white-pawn.236f6686.svg\";","export default __webpack_public_path__ + \"static/media/white-rook.51da5ea4.svg\";","export default __webpack_public_path__ + \"static/media/white-knight.6682d263.svg\";","export default __webpack_public_path__ + \"static/media/white-bishop.434cf6df.svg\";","export default __webpack_public_path__ + \"static/media/white-queen.2ec74f60.svg\";","export default __webpack_public_path__ + \"static/media/white-king.5933a366.svg\";","export default __webpack_public_path__ + \"static/media/black-pawn.3df4af41.svg\";","export default __webpack_public_path__ + \"static/media/black-rook.6208da08.svg\";","export default __webpack_public_path__ + \"static/media/black-knight.dbe602a6.svg\";","export default __webpack_public_path__ + \"static/media/black-bishop.d3b59849.svg\";","export default __webpack_public_path__ + \"static/media/black-queen.81d53079.svg\";","export default __webpack_public_path__ + \"static/media/black-king.5c3d9d02.svg\";","import React, { useMemo, memo } from 'react';\nimport './ChessBoard.css';\n\n// Import SVG pieces\nimport whitePawn from '../assets/pieces/white-pawn.svg';\nimport whiteRook from '../assets/pieces/white-rook.svg';\nimport whiteKnight from '../assets/pieces/white-knight.svg';\nimport whiteBishop from '../assets/pieces/white-bishop.svg';\nimport whiteQueen from '../assets/pieces/white-queen.svg';\nimport whiteKing from '../assets/pieces/white-king.svg';\nimport blackPawn from '../assets/pieces/black-pawn.svg';\nimport blackRook from '../assets/pieces/black-rook.svg';\nimport blackKnight from '../assets/pieces/black-knight.svg';\nimport blackBishop from '../assets/pieces/black-bishop.svg';\nimport blackQueen from '../assets/pieces/black-queen.svg';\nimport blackKing from '../assets/pieces/black-king.svg';\n\n// Map piece types to SVG images - moved outside component for better performance\nconst pieceImages = {\n  'white': {\n    'pawn': whitePawn,\n    'rook': whiteRook,\n    'knight': whiteKnight,\n    'bishop': whiteBishop,\n    'queen': whiteQueen,\n    'king': whiteKing\n  },\n  'black': {\n    'pawn': blackPawn,\n    'rook': blackRook,\n    'knight': blackKnight,\n    'bishop': blackBishop,\n    'queen': blackQueen,\n    'king': blackKing\n  }\n};\n\n// Memoized Square component for better performance\nconst Square = memo(({ \n  row, \n  col, \n  piece, \n  isLight, \n  isSelected, \n  isHighlighted, \n  isCheck, \n  isLastMove, \n  isHint, \n  squareColor, \n  onClick \n}) => {\n  let squareClassName = `square ${isLight ? 'light' : 'dark'}`;\n  if (isSelected) squareClassName += ' selected';\n  if (isHighlighted) squareClassName += ' highlighted';\n  if (isCheck) squareClassName += ' check';\n  if (isLastMove) squareClassName += ' last-move';\n  if (isHint) squareClassName += ' hint';\n  \n  const squareStyle = {\n    backgroundColor: squareColor\n  };\n  \n  return (\n    <div \n      className={squareClassName}\n      style={squareStyle}\n      onClick={onClick}\n    >\n      {piece && !piece.captured && (\n        <img \n          src={pieceImages[piece.color][piece.type]} \n          alt={`${piece.color} ${piece.type}`} \n          className={`piece ${piece.color}`}\n        />\n      )}\n    </div>\n  );\n});\n\n// Memoized coordinates component\nconst Coordinates = memo(() => {\n  const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n  const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n  \n  return (\n    <div className=\"board-coordinates\">\n      <div className=\"files\">\n        {files.map(file => (\n          <div key={file}>{file}</div>\n        ))}\n      </div>\n      <div className=\"ranks\">\n        {ranks.map(rank => (\n          <div key={rank}>{rank}</div>\n        ))}\n      </div>\n    </div>\n  );\n});\n\n// Memoized captured pieces component\nconst CapturedPieces = memo(({ capturedPieces, color }) => {\n  const capturedByOpponent = color === 'white' ? capturedPieces.black : capturedPieces.white;\n  \n  if (capturedByOpponent.length === 0) return null;\n  \n  return (\n    <div className=\"captured-row\">\n      {capturedByOpponent.map((piece, index) => (\n        <img \n          key={index}\n          src={pieceImages[piece.color][piece.type]} \n          alt={`${piece.color} ${piece.type}`} \n          className=\"captured-piece\"\n        />\n      ))}\n    </div>\n  );\n});\n\nconst ChessBoard = ({ \n  board, \n  selectedPiece, \n  onSquareClick, \n  highlightedSquares, \n  checkIndicator,\n  lastMove,\n  hintMove,\n  theme\n}) => {\n  // Calculate captured pieces - memoized for performance\n  const capturedPieces = useMemo(() => {\n    const captured = {\n      white: [],\n      black: []\n    };\n    \n    board.flat().forEach(piece => {\n      if (piece && piece.captured) {\n        captured[piece.color].push(piece);\n      }\n    });\n    \n    return captured;\n  }, [board]);\n\n  // Check if a square is highlighted (valid move) - memoized lookup map\n  const highlightedSquaresMap = useMemo(() => {\n    const map = {};\n    highlightedSquares.forEach(square => {\n      map[`${square.row}-${square.col}`] = true;\n    });\n    return map;\n  }, [highlightedSquares]);\n  \n  // Check if a square is part of the last move - memoized\n  const lastMoveMap = useMemo(() => {\n    if (!lastMove) return {};\n    \n    const { from, to } = lastMove;\n    return {\n      [`${from.row}-${from.col}`]: true,\n      [`${to.row}-${to.col}`]: true\n    };\n  }, [lastMove]);\n  \n  // Check if a square is part of a hint - memoized\n  const hintSquareMap = useMemo(() => {\n    if (!hintMove) return {};\n    \n    const { fromRow, fromCol, toRow, toCol } = hintMove;\n    return {\n      [`${fromRow}-${fromCol}`]: true,\n      [`${toRow}-${toCol}`]: true\n    };\n  }, [hintMove]);\n\n  // Render the board - memoized for performance\n  const boardRows = useMemo(() => {\n    const squares = [];\n    \n    // Define these functions inside the useMemo callback to avoid dependency issues\n    const isHighlighted = (row, col) => {\n      return !!highlightedSquaresMap[`${row}-${col}`];\n    };\n    \n    const isLastMove = (row, col) => {\n      return !!lastMoveMap[`${row}-${col}`];\n    };\n    \n    const isHintSquare = (row, col) => {\n      return !!hintSquareMap[`${row}-${col}`];\n    };\n    \n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col];\n        const isLight = (row + col) % 2 === 0;\n        const isSelected = selectedPiece && selectedPiece.row === row && selectedPiece.col === col;\n        const isCheck = checkIndicator && piece && piece.type === 'king' && piece.color === checkIndicator;\n        \n        squares.push(\n          <Square \n            key={`${row}-${col}`}\n            row={row}\n            col={col}\n            piece={piece}\n            isLight={isLight}\n            isSelected={isSelected}\n            isHighlighted={isHighlighted(row, col)}\n            isCheck={isCheck}\n            isLastMove={isLastMove(row, col)}\n            isHint={isHintSquare(row, col)}\n            squareColor={isLight ? theme.lightSquare : theme.darkSquare}\n            onClick={() => onSquareClick(row, col)}\n          />\n        );\n      }\n    }\n    \n    return squares;\n  }, [board, selectedPiece, checkIndicator, theme, onSquareClick, highlightedSquaresMap, lastMoveMap, hintSquareMap]);\n\n  // Apply theme styles\n  const containerStyle = useMemo(() => ({\n    background: theme.boardBg,\n    '--highlight-color': theme.highlightColor,\n    '--check-color': theme.checkColor,\n    '--last-move-color': theme.lastMoveColor,\n    '--accent-color': theme.accentColor\n  }), [theme]);\n\n  return (\n    <div className=\"chess-board-container\" style={containerStyle}>\n      <div className=\"chess-board\">\n        {boardRows}\n      </div>\n      <Coordinates />\n      <div className=\"captured-pieces\">\n        <CapturedPieces capturedPieces={capturedPieces} color=\"white\" />\n        <CapturedPieces capturedPieces={capturedPieces} color=\"black\" />\n      </div>\n    </div>\n  );\n};\n\nexport default memo(ChessBoard); ","import React, { useState } from 'react';\nimport './GameInfo.css';\n\nconst GameInfo = ({ \n  playerTurn, \n  gameStatus, \n  moveHistory, \n  onResetGame, \n  isInCheck,\n  aiDifficulty,\n  onGetHint,\n  aiThinking\n}) => {\n  const [activeTab, setActiveTab] = useState('moves');\n  \n  // Group moves into pairs (white and black)\n  const groupedMoves = [];\n  for (let i = 0; i < moveHistory.length; i += 2) {\n    groupedMoves.push({\n      number: Math.floor(i / 2) + 1,\n      white: moveHistory[i],\n      black: moveHistory[i + 1]\n    });\n  }\n  \n  // Calculate material advantage\n  const calculateMaterialAdvantage = () => {\n    const pieceValues = {\n      'pawn': 1,\n      'knight': 3,\n      'bishop': 3,\n      'rook': 5,\n      'queen': 9,\n      'king': 0\n    };\n    \n    let whiteCaptured = 0;\n    let blackCaptured = 0;\n    \n    moveHistory.forEach(move => {\n      if (move.capturedPiece) {\n        if (move.capturedPiece.color === 'white') {\n          blackCaptured += pieceValues[move.capturedPiece.type];\n        } else {\n          whiteCaptured += pieceValues[move.capturedPiece.type];\n        }\n      }\n    });\n    \n    const advantage = whiteCaptured - blackCaptured;\n    \n    if (advantage > 0) {\n      return { color: 'white', value: advantage };\n    } else if (advantage < 0) {\n      return { color: 'black', value: Math.abs(advantage) };\n    } else {\n      return { color: 'equal', value: 0 };\n    }\n  };\n  \n  const materialAdvantage = calculateMaterialAdvantage();\n  \n  // Render game status\n  const renderGameStatus = () => {\n    let statusText = '';\n    \n    if (gameStatus === 'ongoing') {\n      statusText = `${playerTurn === 'white' ? 'White' : 'Black'}'s turn`;\n    } else if (gameStatus.includes('checkmate')) {\n      statusText = gameStatus;\n    } else if (gameStatus.includes('stalemate')) {\n      statusText = 'Draw by stalemate';\n    } else {\n      statusText = gameStatus;\n    }\n    \n    return (\n      <div className=\"status-container\">\n        <div className=\"status\">\n          {statusText}\n          {aiThinking && playerTurn === 'black' && (\n            <div className=\"ai-thinking\">\n              <span>AI is thinking</span>\n              <div className=\"thinking-dots\">\n                <span className=\"dot\"></span>\n                <span className=\"dot\"></span>\n                <span className=\"dot\"></span>\n              </div>\n            </div>\n          )}\n        </div>\n        <div className=\"player-indicators\">\n          <div className={`player-indicator ${playerTurn === 'white' ? 'active' : ''}`}>\n            <span className=\"white\">White</span>\n          </div>\n          <div className={`player-indicator ${playerTurn === 'black' ? 'active' : ''}`}>\n            <span className=\"black\">Black</span>\n          </div>\n        </div>\n        {isInCheck && gameStatus === 'ongoing' && (\n          <div className=\"check-status\">\n            {playerTurn === 'white' ? 'White' : 'Black'} is in check!\n          </div>\n        )}\n        {gameStatus !== 'ongoing' && (\n          <div className=\"game-over\">\n            {gameStatus}\n          </div>\n        )}\n        <div className=\"button-container\">\n          <button className=\"reset-button\" onClick={onResetGame}>\n            New Game\n          </button>\n          <button \n            className=\"hint-button\" \n            onClick={onGetHint}\n            disabled={gameStatus !== 'ongoing' || playerTurn !== 'white' || aiThinking}\n          >\n            Hint\n          </button>\n        </div>\n      </div>\n    );\n  };\n  \n  // Render move history\n  const renderMoveHistory = () => {\n    if (moveHistory.length === 0) {\n      return <div className=\"no-moves\">No moves yet</div>;\n    }\n    \n    return (\n      <div className=\"moves-container\">\n        <table className=\"moves-table\">\n          <thead>\n            <tr>\n              <th>#</th>\n              <th>White</th>\n              <th>Black</th>\n            </tr>\n          </thead>\n          <tbody>\n            {groupedMoves.map(move => (\n              <tr key={move.number}>\n                <td className=\"move-number\">{move.number}</td>\n                <td className=\"white-move\">{move.white ? move.white.notation : ''}</td>\n                <td className=\"black-move\">{move.black ? move.black.notation : ''}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  };\n  \n  // Render analysis\n  const renderAnalysis = () => {\n    const searchDepth = {\n      'easy': 1,\n      'medium': 2,\n      'hard': 3\n    }[aiDifficulty];\n    \n    return (\n      <div className=\"analysis-container\">\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">Total Moves</span>\n          <span className=\"analysis-value\">{moveHistory.length}</span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">Material Advantage</span>\n          <span className={`analysis-value material-advantage ${materialAdvantage.color}`}>\n            {materialAdvantage.color === 'equal' ? 'Equal' : `+${materialAdvantage.value} for ${materialAdvantage.color}`}\n          </span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">AI Thinking Depth</span>\n          <span className=\"analysis-value\">{searchDepth} {searchDepth === 1 ? 'move' : 'moves'}</span>\n        </div>\n      </div>\n    );\n  };\n  \n  return (\n    <div className=\"game-info\">\n      <h2>Game Status</h2>\n      {renderGameStatus()}\n      \n      <div className=\"tabs\">\n        <div \n          className={`tab ${activeTab === 'moves' ? 'active' : ''}`}\n          onClick={() => setActiveTab('moves')}\n        >\n          Moves\n        </div>\n        <div \n          className={`tab ${activeTab === 'analysis' ? 'active' : ''}`}\n          onClick={() => setActiveTab('analysis')}\n        >\n          Analysis\n        </div>\n      </div>\n      \n      <div className=\"tab-content\">\n        {activeTab === 'moves' ? renderMoveHistory() : renderAnalysis()}\n      </div>\n    </div>\n  );\n};\n\nexport default GameInfo; ","import React from 'react';\nimport './PromotionDialog.css';\n\n// Import SVG pieces\nimport whiteQueen from '../assets/pieces/white-queen.svg';\nimport whiteRook from '../assets/pieces/white-rook.svg';\nimport whiteBishop from '../assets/pieces/white-bishop.svg';\nimport whiteKnight from '../assets/pieces/white-knight.svg';\nimport blackQueen from '../assets/pieces/black-queen.svg';\nimport blackRook from '../assets/pieces/black-rook.svg';\nimport blackBishop from '../assets/pieces/black-bishop.svg';\nimport blackKnight from '../assets/pieces/black-knight.svg';\n\nconst PromotionDialog = ({ position, color, onSelect, onCancel }) => {\n  const pieceImages = {\n    'white': {\n      'queen': whiteQueen,\n      'rook': whiteRook,\n      'bishop': whiteBishop,\n      'knight': whiteKnight\n    },\n    'black': {\n      'queen': blackQueen,\n      'rook': blackRook,\n      'bishop': blackBishop,\n      'knight': blackKnight\n    }\n  };\n\n  const pieces = ['queen', 'rook', 'bishop', 'knight'];\n\n  return (\n    <div className=\"promotion-dialog-backdrop\" onClick={onCancel}>\n      <div \n        className=\"promotion-dialog\" \n        style={{ \n          top: position.y, \n          left: position.x \n        }}\n        onClick={(e) => e.stopPropagation()}\n      >\n        <div className=\"promotion-title\">Promote to:</div>\n        <div className=\"promotion-options\">\n          {pieces.map(piece => (\n            <div \n              key={piece} \n              className=\"promotion-piece\" \n              onClick={() => onSelect(piece)}\n            >\n              <img \n                src={pieceImages[color][piece]} \n                alt={`${color} ${piece}`} \n                className=\"promotion-piece-image\"\n              />\n              <div className=\"promotion-piece-name\">{piece}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PromotionDialog; ","// Chess board themes\nconst themes = {\n  // Classic wooden theme\n  classic: {\n    name: 'Classic',\n    lightSquare: '#f0d9b5',\n    darkSquare: '#b58863',\n    highlightColor: 'rgba(78, 205, 196, 0.7)',\n    checkColor: 'rgba(255, 107, 107, 0.6)',\n    lastMoveColor: 'rgba(255, 209, 102, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9))',\n    accentColor: '#4ecdc4'\n  },\n  \n  // Blue theme\n  blue: {\n    name: 'Ocean Blue',\n    lightSquare: '#dee3e6',\n    darkSquare: '#8ca2ad',\n    highlightColor: 'rgba(106, 168, 79, 0.7)',\n    checkColor: 'rgba(244, 67, 54, 0.6)',\n    lastMoveColor: 'rgba(255, 193, 7, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(25, 118, 210, 0.9), rgba(13, 71, 161, 0.9))',\n    accentColor: '#03a9f4'\n  },\n  \n  // Dark theme\n  dark: {\n    name: 'Midnight',\n    lightSquare: '#6b7987',\n    darkSquare: '#2e3947',\n    highlightColor: 'rgba(121, 134, 203, 0.7)',\n    checkColor: 'rgba(255, 82, 82, 0.6)',\n    lastMoveColor: 'rgba(255, 215, 64, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(20, 20, 31, 0.9), rgba(10, 10, 18, 0.9))',\n    accentColor: '#9c27b0'\n  },\n  \n  // Green theme\n  green: {\n    name: 'Forest',\n    lightSquare: '#eeeed2',\n    darkSquare: '#769656',\n    highlightColor: 'rgba(119, 149, 86, 0.7)',\n    checkColor: 'rgba(255, 97, 97, 0.6)',\n    lastMoveColor: 'rgba(255, 213, 79, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(27, 94, 32, 0.9), rgba(46, 125, 50, 0.9))',\n    accentColor: '#8bc34a'\n  },\n  \n  // Coral theme\n  coral: {\n    name: 'Coral',\n    lightSquare: '#fce4ec',\n    darkSquare: '#f06292',\n    highlightColor: 'rgba(128, 203, 196, 0.7)',\n    checkColor: 'rgba(255, 82, 82, 0.6)',\n    lastMoveColor: 'rgba(255, 202, 40, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(216, 27, 96, 0.9), rgba(142, 36, 170, 0.9))',\n    accentColor: '#00bcd4'\n  }\n};\n\nexport default themes; ","import React from 'react';\nimport './ThemeSelector.css';\nimport themes from '../themes';\n\nconst ThemeSelector = ({ currentTheme, onThemeChange }) => {\n  return (\n    <div className=\"theme-selector\">\n      <div className=\"theme-selector-label\">Board Theme:</div>\n      <div className=\"theme-options\">\n        {Object.keys(themes).map(themeKey => (\n          <div \n            key={themeKey}\n            className={`theme-option ${currentTheme === themeKey ? 'active' : ''}`}\n            onClick={() => onThemeChange(themeKey)}\n            title={themes[themeKey].name}\n          >\n            <div \n              className=\"theme-preview\"\n              style={{\n                background: `linear-gradient(135deg, \n                  ${themes[themeKey].lightSquare} 0%, \n                  ${themes[themeKey].lightSquare} 50%, \n                  ${themes[themeKey].darkSquare} 50%, \n                  ${themes[themeKey].darkSquare} 100%)`\n              }}\n            ></div>\n            <span className=\"theme-name\">{themes[themeKey].name}</span>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default ThemeSelector; ","// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n  \n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };\n    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };\n  }\n  \n  // Set up rooks\n  board[0][0] = { type: 'rook', color: 'black', hasMoved: false };\n  board[0][7] = { type: 'rook', color: 'black', hasMoved: false };\n  board[7][0] = { type: 'rook', color: 'white', hasMoved: false };\n  board[7][7] = { type: 'rook', color: 'white', hasMoved: false };\n  \n  // Set up knights\n  board[0][1] = { type: 'knight', color: 'black' };\n  board[0][6] = { type: 'knight', color: 'black' };\n  board[7][1] = { type: 'knight', color: 'white' };\n  board[7][6] = { type: 'knight', color: 'white' };\n  \n  // Set up bishops\n  board[0][2] = { type: 'bishop', color: 'black' };\n  board[0][5] = { type: 'bishop', color: 'black' };\n  board[7][2] = { type: 'bishop', color: 'white' };\n  board[7][5] = { type: 'bishop', color: 'white' };\n  \n  // Set up queens\n  board[0][3] = { type: 'queen', color: 'black' };\n  board[7][3] = { type: 'queen', color: 'white' };\n  \n  // Set up kings\n  board[0][4] = { type: 'king', color: 'black', hasMoved: false };\n  board[7][4] = { type: 'king', color: 'white', hasMoved: false };\n  \n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = (board) => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return { row, col };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row + pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row + pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from knights\n  const knightMoves = [\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n    [1, -2], [1, 2], [2, -1], [2, 1]\n  ];\n  \n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    \n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from bishops, rooks, and queens\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1], [0, -1],\n    [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n  \n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    \n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      \n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' ||\n              (piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir)) ||\n              (piece.type === 'rook' && (rowDir === 0 || colDir === 0))) {\n            return true;\n          }\n          \n          // King can attack adjacent squares\n          if (piece.type === 'king' && \n              Math.abs(newRow - row) <= 1 && \n              Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      \n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  \n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  \n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\n// eslint-disable-next-line no-unused-vars\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  // Check if the coordinates are valid\n  if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||\n      toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {\n    return false;\n  }\n  \n  // Check if there is a piece at the starting position\n  const piece = board[fromRow][fromCol];\n  if (!piece) {\n    return false;\n  }\n  \n  // Check if the destination has a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) {\n    return false;\n  }\n  \n  // Check piece-specific movement rules\n  let isValid = false;\n  \n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n  \n  // If the move is valid according to piece rules, check if it would leave the king in check\n  if (isValid) {\n    // Make a temporary move\n    const { board: tempBoard } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Check if the king is in check after the move\n    const kingInCheck = isInCheck(tempBoard, piece.color);\n    \n    // If the king is in check, the move is not valid\n    if (kingInCheck) {\n      return false;\n    }\n  }\n  \n  return isValid;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  \n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Moving forward two squares from starting position\n  if (fromCol === toCol && !piece.hasMoved && \n      toRow === fromRow + 2 * direction &&\n      !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n    \n    // En passant capture\n    if (!board[toRow][toCol] && gameState.enPassantTarget &&\n        toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  \n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  \n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  \n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  if (rowDiff !== colDiff) return false;\n  \n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  \n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  \n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  \n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n  \n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Check if a pawn can be promoted\nexport const isPawnPromotion = (piece, toRow) => {\n  if (!piece || piece.type !== 'pawn') return false;\n  \n  // White pawns promote on row 0, black pawns on row 7\n  return (piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7);\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece = null) => {\n  // Create a deep copy of the board and game state\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const newGameState = JSON.parse(JSON.stringify(gameState));\n  \n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n  \n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[toRow][toCol - 1] = newBoard[toRow][7]; // Move rook\n      newBoard[toRow][7] = null; // Remove rook from original position\n    } \n    // Queenside castling\n    else {\n      newBoard[toRow][toCol + 1] = newBoard[toRow][0]; // Move rook\n      newBoard[toRow][0] = null; // Remove rook from original position\n    }\n  }\n  \n  // Handle en passant capture\n  if (piece.type === 'pawn' && fromCol !== toCol && !targetPiece) {\n    // This is a diagonal move without a target piece, must be en passant\n    newBoard[fromRow][toCol] = null; // Capture the pawn that just moved\n  }\n  \n  // Update en passant target\n  newGameState.enPassantTarget = null;\n  if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {\n    newGameState.enPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };\n  }\n  \n  // Update castling rights\n  if (piece.type === 'king') {\n    newGameState.castlingRights[piece.color].kingSide = false;\n    newGameState.castlingRights[piece.color].queenSide = false;\n  } else if (piece.type === 'rook') {\n    if (fromRow === 7 && fromCol === 0 && piece.color === 'white') {\n      newGameState.castlingRights.white.queenSide = false;\n    } else if (fromRow === 7 && fromCol === 7 && piece.color === 'white') {\n      newGameState.castlingRights.white.kingSide = false;\n    } else if (fromRow === 0 && fromCol === 0 && piece.color === 'black') {\n      newGameState.castlingRights.black.queenSide = false;\n    } else if (fromRow === 0 && fromCol === 7 && piece.color === 'black') {\n      newGameState.castlingRights.black.kingSide = false;\n    }\n  }\n  \n  // Handle pawn promotion\n  if (piece.type === 'pawn' && isPawnPromotion(piece, toRow) && promotionPiece) {\n    // Create a new piece of the specified type\n    newBoard[toRow][toCol] = { type: promotionPiece, color: piece.color };\n  } else {\n    // Regular move\n    newBoard[toRow][toCol] = piece;\n  }\n  \n  // Remove the piece from its original position\n  newBoard[fromRow][fromCol] = null;\n  \n  return { board: newBoard, gameState: newGameState };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color) => {\n  // If not in check, can't be checkmate\n  if (!isInCheck(board, color)) return false;\n  \n  // Check if any move can get out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color) => {\n  // If in check, it's not stalemate\n  if (isInCheck(board, color)) return false;\n  \n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = (board) => {\n  let score = 0;\n  \n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n        \n        // Add positional bonuses\n        let positionalValue = 0;\n        \n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n          \n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n        \n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n        \n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          \n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            \n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          \n          positionalValue += diagonalMoves * 0.05;\n        }\n        \n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && \n                board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          \n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n        \n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(\n            Math.abs(0 - row) + Math.abs(0 - col),\n            Math.abs(0 - row) + Math.abs(7 - col),\n            Math.abs(7 - row) + Math.abs(0 - col),\n            Math.abs(7 - row) + Math.abs(7 - col)\n          );\n          \n          positionalValue += centerDistance * 0.1;\n        }\n        \n        const totalValue = value + positionalValue;\n        \n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n  \n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black')) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white')) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black')) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white')) {\n      score -= 0.5; // White is in check\n    }\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({ fromRow, fromCol, toRow, toCol });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n  \n  // Check for terminal states\n  if (isCheckmate(board, 'white')) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black')) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return 0; // Draw\n  }\n  \n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  \n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  \n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    \n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    \n    if ((isMaximizing && value > bestValue) || (!isMaximizing && value < bestValue)) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}; ","import { \n  // eslint-disable-next-line no-unused-vars\n  makeMove, \n  isValidMove, \n  // eslint-disable-next-line no-unused-vars\n  isInCheck, \n  // eslint-disable-next-line no-unused-vars\n  isCheckmate, \n  // eslint-disable-next-line no-unused-vars\n  isStalemate \n} from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  'knight': [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  'bishop': [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  'rook': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  'queen': [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  'king': [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Memoization cache for position evaluation\nconst evaluationCache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (evaluationCache.size > MAX_CACHE_SIZE) {\n    // Clear the entire cache for simplicity and performance\n    evaluationCache.clear();\n  }\n};\n\n// Get a simple hash for the board position\nconst getBoardHash = (board) => {\n  let hash = '';\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        hash += `${row}${col}${piece.type[0]}${piece.color[0]}`;\n      }\n    }\n  }\n  return hash;\n};\n\n// Evaluate a single move\nconst evaluateMove = (board, move, gameState) => {\n  const { fromRow, fromCol, toRow, toCol } = move;\n  const piece = board[fromRow][fromCol];\n  const targetPiece = board[toRow][toCol];\n  \n  let score = 0;\n  \n  // Capture value\n  if (targetPiece) {\n    score += pieceValues[targetPiece.type] * 2; // Prioritize captures\n  }\n  \n  // Position improvement\n  const currentPositionValue = positionBonus[piece.type][piece.color === 'white' ? fromRow : 7 - fromRow][fromCol];\n  const newPositionValue = positionBonus[piece.type][piece.color === 'white' ? toRow : 7 - toRow][toCol];\n  score += (newPositionValue - currentPositionValue) * 0.5;\n  \n  // Center control bonus\n  const centerDistance = Math.abs(3.5 - toRow) + Math.abs(3.5 - toCol);\n  score += (7 - centerDistance) * 0.2;\n  \n  // Pawn advancement bonus\n  if (piece.type === 'pawn') {\n    const advancementBonus = piece.color === 'white' ? (7 - toRow) : toRow;\n    score += advancementBonus * 0.5;\n    \n    // Bonus for pawns near promotion\n    if ((piece.color === 'white' && toRow <= 1) || (piece.color === 'black' && toRow >= 6)) {\n      score += 5;\n    }\n  }\n  \n  // Avoid moving the king early in the game\n  if (piece.type === 'king') {\n    score -= 2;\n  }\n  \n  // Encourage development of knights and bishops early\n  if ((piece.type === 'knight' || piece.type === 'bishop') && \n      ((piece.color === 'white' && fromRow === 7) || (piece.color === 'black' && fromRow === 0))) {\n    score += 1;\n  }\n  \n  return score;\n};\n\n// Knight move offsets for faster move generation\nconst knightOffsets = [\n  [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n  [1, -2], [1, 2], [2, -1], [2, 1]\n];\n\n// Directional offsets for sliding pieces (bishop, rook, queen)\nconst directions = {\n  bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],\n  rook: [[-1, 0], [0, -1], [0, 1], [1, 0]],\n  queen: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n};\n\n// Generate moves for a specific piece - optimized for speed\nconst generatePieceMoves = (board, row, col, gameState) => {\n  const piece = board[row][col];\n  if (!piece) return [];\n  \n  const moves = [];\n  \n  switch (piece.type) {\n    case 'pawn': {\n      const direction = piece.color === 'white' ? -1 : 1;\n      \n      // Move forward one square\n      if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {\n        moves.push({ fromRow: row, fromCol: col, toRow: row + direction, toCol: col, isCapture: false });\n        \n        // Move forward two squares from starting position\n        if (!piece.hasMoved && \n            row + 2 * direction >= 0 && row + 2 * direction < 8 && \n            !board[row + direction][col] && !board[row + 2 * direction][col]) {\n          moves.push({ fromRow: row, fromCol: col, toRow: row + 2 * direction, toCol: col, isCapture: false });\n        }\n      }\n      \n      // Capture diagonally\n      for (const colOffset of [-1, 1]) {\n        if (col + colOffset >= 0 && col + colOffset < 8 && row + direction >= 0 && row + direction < 8) {\n          // Normal capture\n          if (board[row + direction][col + colOffset] && \n              board[row + direction][col + colOffset].color !== piece.color) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: row + direction, \n              toCol: col + colOffset, \n              isCapture: true \n            });\n          }\n          \n          // En passant capture\n          if (!board[row + direction][col + colOffset] && gameState.enPassantTarget &&\n              row + direction === gameState.enPassantTarget.row && \n              col + colOffset === gameState.enPassantTarget.col) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: row + direction, \n              toCol: col + colOffset, \n              isCapture: true,\n              isEnPassant: true\n            });\n          }\n        }\n      }\n      break;\n    }\n    \n    case 'knight': {\n      for (const [rowOffset, colOffset] of knightOffsets) {\n        const newRow = row + rowOffset;\n        const newCol = col + colOffset;\n        \n        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n          const targetPiece = board[newRow][newCol];\n          if (!targetPiece || targetPiece.color !== piece.color) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: newRow, \n              toCol: newCol, \n              isCapture: !!targetPiece \n            });\n          }\n        }\n      }\n      break;\n    }\n    \n    case 'bishop':\n    case 'rook':\n    case 'queen': {\n      const dirs = directions[piece.type];\n      \n      for (const [rowDir, colDir] of dirs) {\n        let newRow = row + rowDir;\n        let newCol = col + colDir;\n        \n        while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n          const targetPiece = board[newRow][newCol];\n          \n          if (!targetPiece) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: newRow, \n              toCol: newCol, \n              isCapture: false \n            });\n          } else {\n            if (targetPiece.color !== piece.color) {\n              moves.push({ \n                fromRow: row, \n                fromCol: col, \n                toRow: newRow, \n                toCol: newCol, \n                isCapture: true \n              });\n            }\n            break; // Stop in this direction after hitting a piece\n          }\n          \n          newRow += rowDir;\n          newCol += colDir;\n        }\n      }\n      break;\n    }\n    \n    case 'king': {\n      // Regular king moves\n      for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {\n        for (let colOffset = -1; colOffset <= 1; colOffset++) {\n          if (rowOffset === 0 && colOffset === 0) continue;\n          \n          const newRow = row + rowOffset;\n          const newCol = col + colOffset;\n          \n          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = board[newRow][newCol];\n            if (!targetPiece || targetPiece.color !== piece.color) {\n              moves.push({ \n                fromRow: row, \n                fromCol: col, \n                toRow: newRow, \n                toCol: newCol, \n                isCapture: !!targetPiece \n              });\n            }\n          }\n        }\n      }\n      \n      // Castling\n      if (!piece.hasMoved && gameState.castlingRights) {\n        const castlingRights = gameState.castlingRights[piece.color];\n        \n        // Kingside castling\n        if (castlingRights && castlingRights.kingSide && \n            !board[row][col + 1] && !board[row][col + 2] &&\n            board[row][col + 3] && board[row][col + 3].type === 'rook' && \n            !board[row][col + 3].hasMoved) {\n          moves.push({ \n            fromRow: row, \n            fromCol: col, \n            toRow: row, \n            toCol: col + 2, \n            isCapture: false,\n            isCastling: true,\n            castlingSide: 'kingside'\n          });\n        }\n        \n        // Queenside castling\n        if (castlingRights && castlingRights.queenSide && \n            !board[row][col - 1] && !board[row][col - 2] && !board[row][col - 3] &&\n            board[row][col - 4] && board[row][col - 4].type === 'rook' && \n            !board[row][col - 4].hasMoved) {\n          moves.push({ \n            fromRow: row, \n            fromCol: col, \n            toRow: row, \n            toCol: col - 2, \n            isCapture: false,\n            isCastling: true,\n            castlingSide: 'queenside'\n          });\n        }\n      }\n      break;\n    }\n    \n    default:\n      // No moves for unknown piece types\n      break;\n  }\n  \n  return moves;\n};\n\n// Generate all valid moves for a player - optimized version\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  const candidateMoves = [];\n  \n  // First, collect all candidate moves without checking if they're valid\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.color === color) {\n        const pieceMoves = generatePieceMoves(board, row, col, gameState);\n        candidateMoves.push(...pieceMoves);\n      }\n    }\n  }\n  \n  // Then filter out moves that would leave the king in check\n  for (const move of candidateMoves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n      moves.push(move);\n    }\n  }\n  \n  return moves;\n};\n\n// Find the best move using a simple greedy algorithm\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Generate all valid moves\n  let moves = generateMoves(board, color, gameState);\n  \n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n  \n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n  \n  // Add randomness based on difficulty\n  const randomChance = difficulty === 'easy' ? 0.3 : (difficulty === 'medium' ? 0.15 : 0.05);\n  if (Math.random() < randomChance) {\n    const randomIndex = Math.floor(Math.random() * moves.length);\n    return moves[randomIndex];\n  }\n  \n  // Check if we have this position cached\n  const boardHash = getBoardHash(board);\n  const cacheKey = `${boardHash}-${color}-${difficulty}`;\n  \n  if (evaluationCache.has(cacheKey)) {\n    return evaluationCache.get(cacheKey);\n  }\n  \n  // Evaluate each move\n  const evaluatedMoves = moves.map(move => {\n    const score = evaluateMove(board, move, gameState);\n    return { ...move, score };\n  });\n  \n  // Sort moves by score (descending for white, ascending for black)\n  evaluatedMoves.sort((a, b) => {\n    return color === 'white' ? b.score - a.score : a.score - b.score;\n  });\n  \n  // Add some randomness to the top moves based on difficulty\n  const topMovesCount = difficulty === 'easy' ? 5 : (difficulty === 'medium' ? 3 : 2);\n  const topMoves = evaluatedMoves.slice(0, Math.min(topMovesCount, evaluatedMoves.length));\n  \n  // Select a random move from the top moves\n  const selectedIndex = Math.floor(Math.random() * topMoves.length);\n  const bestMove = topMoves[selectedIndex];\n  \n  // Cache the result\n  evaluationCache.set(cacheKey, bestMove);\n  checkCacheSize();\n  \n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n}; ","import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport './App.css';\nimport ChessBoard from './components/ChessBoard';\nimport GameInfo from './components/GameInfo';\nimport PromotionDialog from './components/PromotionDialog';\nimport ThemeSelector from './components/ThemeSelector';\nimport themes from './themes';\nimport { \n  initializeBoard, \n  isValidMove, \n  makeMove, \n  isInCheck, \n  isCheckmate, \n  isStalemate,\n  isPawnPromotion\n} from './utils/chessLogic';\nimport { getAIMove } from './utils/aiPlayer';\n\n// eslint-disable-next-line no-unused-vars\nfunction App() {\n  const [board, setBoard] = useState(initializeBoard());\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [playerTurn, setPlayerTurn] = useState('white');\n  const [gameStatus, setGameStatus] = useState('ongoing');\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [gameState, setGameState] = useState({\n    enPassantTarget: null,\n    castlingRights: {\n      white: { kingSide: true, queenSide: true },\n      black: { kingSide: true, queenSide: true }\n    }\n  });\n  const [highlightedSquares, setHighlightedSquares] = useState([]);\n  const [checkIndicator, setCheckIndicator] = useState(null);\n  const [aiDifficulty, setAiDifficulty] = useState('medium'); // 'easy', 'medium', 'hard'\n  const [showHint, setShowHint] = useState(false);\n  const [hintMove, setHintMove] = useState(null);\n  const [promotionDialog, setPromotionDialog] = useState(null);\n  const [currentTheme, setCurrentTheme] = useState('classic');\n  const [aiThinking, setAiThinking] = useState(false);\n\n  // Create a ref to store the handleMove function\n  const handleMoveRef = useRef(null);\n\n  // Handle move\n  const handleMove = useCallback((fromRow, fromCol, toRow, toCol, promotionPiece = null) => {\n    // eslint-disable-next-line no-unused-vars\n    const { board: newBoard, gameState: newGameState, capturedPiece } = makeMove(\n      board, \n      fromRow, \n      fromCol, \n      toRow, \n      toCol, \n      gameState,\n      promotionPiece\n    );\n    \n    setBoard(newBoard);\n    setGameState(newGameState);\n    \n    // Add move to history\n    const piece = board[fromRow][fromCol];\n    const notation = generateMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece, promotionPiece);\n    \n    const newMove = {\n      from: { row: fromRow, col: fromCol },\n      to: { row: toRow, col: toCol },\n      piece,\n      capturedPiece,\n      notation,\n      color: piece.color\n    };\n    \n    setMoveHistory(prevHistory => [...prevHistory, newMove]);\n    \n    // Switch turns\n    setPlayerTurn(prevTurn => prevTurn === 'white' ? 'black' : 'white');\n    \n    // Clear selection and highlights\n    setSelectedPiece(null);\n    setHighlightedSquares([]);\n    setShowHint(false);\n    setHintMove(null);\n  }, [board, gameState, generateMoveNotation]);\n\n  // Update the ref whenever handleMove changes\n  useEffect(() => {\n    handleMoveRef.current = handleMove;\n  }, [handleMove]);\n\n  // Make AI move - optimized version\n  const makeAIMove = useCallback(() => {\n    if (playerTurn === 'black' && gameStatus === 'ongoing') {\n      setAiThinking(true);\n      \n      // Use requestAnimationFrame to ensure UI updates before AI calculation\n      requestAnimationFrame(() => {\n        try {\n          // Get AI move directly - the new algorithm is fast enough\n          const aiMove = getAIMove(board, 'black', gameState, aiDifficulty);\n          \n          if (aiMove) {\n            const { fromRow, fromCol, toRow, toCol } = aiMove;\n            const piece = board[fromRow][fromCol];\n            \n            // Check if this is a pawn promotion\n            if (isPawnPromotion(piece, toRow)) {\n              // AI always promotes to queen\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol, 'queen');\n            } else {\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol);\n            }\n          } else {\n            // If no move found, try a random move\n            const moves = [];\n            for (let fromRow = 0; fromRow < 8; fromRow++) {\n              for (let fromCol = 0; fromCol < 8; fromCol++) {\n                const piece = board[fromRow][fromCol];\n                if (piece && piece.color === 'black') {\n                  for (let toRow = 0; toRow < 8; toRow++) {\n                    for (let toCol = 0; toCol < 8; toCol++) {\n                      if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n                        moves.push({ fromRow, fromCol, toRow, toCol });\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            \n            if (moves.length > 0) {\n              const randomMove = moves[Math.floor(Math.random() * moves.length)];\n              const { fromRow, fromCol, toRow, toCol } = randomMove;\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol);\n            }\n          }\n          \n          // Add a small delay to make the AI move visible to the user\n          setTimeout(() => {\n            setAiThinking(false);\n          }, 200);\n        } catch (error) {\n          console.error(\"Error in AI move calculation:\", error);\n          setAiThinking(false);\n        }\n      });\n    }\n  }, [board, playerTurn, gameStatus, gameState, aiDifficulty]);\n\n  // Check for check, checkmate, or stalemate after each move\n  useEffect(() => {\n    if (moveHistory.length > 0) {\n      // Check if any king is in check\n      if (isInCheck(board, 'white')) {\n        setCheckIndicator('white');\n        \n        // Check if it's checkmate\n        if (isCheckmate(board, 'white')) {\n          setGameStatus('Checkmate! Black wins.');\n        }\n      } else if (isInCheck(board, 'black')) {\n        setCheckIndicator('black');\n        \n        // Check if it's checkmate\n        if (isCheckmate(board, 'black')) {\n          setGameStatus('Checkmate! White wins.');\n        }\n      } else {\n        setCheckIndicator(null);\n      }\n      \n      // Check for stalemate\n      if (playerTurn === 'white' && isStalemate(board, 'white')) {\n        setGameStatus('Draw by stalemate');\n      } else if (playerTurn === 'black' && isStalemate(board, 'black')) {\n        setGameStatus('Draw by stalemate');\n      }\n    }\n  }, [board, playerTurn, moveHistory]);\n\n  // AI makes a move when it's black's turn\n  useEffect(() => {\n    if (playerTurn === 'black' && gameStatus === 'ongoing') {\n      makeAIMove();\n    }\n  }, [playerTurn, gameStatus, makeAIMove]);\n\n  // Calculate valid moves for the selected piece - memoized\n  const validMoves = useMemo(() => {\n    if (!selectedPiece) return [];\n    \n    const moves = [];\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n          moves.push({ row, col });\n        }\n      }\n    }\n    return moves;\n  }, [selectedPiece, board, gameState]);\n\n  // Update highlighted squares when valid moves change\n  useEffect(() => {\n    setHighlightedSquares(validMoves);\n  }, [validMoves]);\n\n  // eslint-disable-next-line no-unused-vars\n  const getPieceSymbol = useCallback((pieceType) => {\n    switch (pieceType) {\n      case 'pawn': return '';\n      case 'knight': return 'N';\n      case 'bishop': return 'B';\n      case 'rook': return 'R';\n      case 'queen': return 'Q';\n      case 'king': return 'K';\n      default: return '';\n    }\n  }, []);\n\n  // Generate algebraic notation for a move\n  const generateMoveNotation = useCallback((piece, fromRow, fromCol, toRow, toCol, capturedPiece, promotionPiece) => {\n    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n    \n    const fromSquare = files[fromCol] + ranks[fromRow];\n    const toSquare = files[toCol] + ranks[toRow];\n    \n    let notation = '';\n    \n    // Add piece symbol (except for pawns)\n    if (piece.type !== 'pawn') {\n      notation += piece.type.charAt(0).toUpperCase();\n    }\n    \n    // Add capture symbol if applicable\n    if (capturedPiece) {\n      if (piece.type === 'pawn') {\n        notation += fromSquare.charAt(0);\n      }\n      notation += 'x';\n    }\n    \n    // Add destination square\n    notation += toSquare;\n    \n    // Add promotion piece if applicable\n    if (promotionPiece) {\n      notation += '=' + promotionPiece.charAt(0).toUpperCase();\n    }\n    \n    return notation;\n  }, []);\n\n  const handleSquareClick = useCallback((row, col) => {\n    // If game is over or promotion dialog is open, don't allow any moves\n    if (gameStatus !== 'ongoing' || promotionDialog) return;\n    \n    // If it's not the player's turn, don't allow any moves\n    if (playerTurn !== 'white') return;\n    \n    const piece = board[row][col];\n    \n    // If a piece is already selected\n    if (selectedPiece) {\n      // If clicking on the same piece, deselect it\n      if (selectedPiece.row === row && selectedPiece.col === col) {\n        setSelectedPiece(null);\n        return;\n      }\n      \n      // If clicking on a different piece of the same color, select that piece instead\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n        return;\n      }\n      \n      // Try to make a move\n      if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n        // Check if this is a pawn promotion\n        if (isPawnPromotion(selectedPiece.piece, row)) {\n          // Show promotion dialog\n          const boardRect = document.querySelector('.chess-board').getBoundingClientRect();\n          const squareSize = boardRect.width / 8;\n          \n          setPromotionDialog({\n            fromRow: selectedPiece.row,\n            fromCol: selectedPiece.col,\n            toRow: row,\n            toCol: col,\n            position: {\n              x: boardRect.left + col * squareSize + squareSize / 2,\n              y: boardRect.top + row * squareSize + squareSize / 2\n            }\n          });\n          return;\n        }\n        \n        // Regular move\n        handleMove(selectedPiece.row, selectedPiece.col, row, col);\n      }\n    } else {\n      // If no piece is selected and clicked on a piece of the player's color, select it\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n      }\n    }\n  }, [board, gameState, gameStatus, handleMove, playerTurn, promotionDialog, selectedPiece]);\n\n  const handlePromotion = useCallback((pieceType) => {\n    if (!promotionDialog) return;\n    \n    const { fromRow, fromCol, toRow, toCol } = promotionDialog;\n    \n    // Make the move with promotion\n    handleMove(fromRow, fromCol, toRow, toCol, pieceType);\n    setPromotionDialog(null);\n  }, [handleMove, promotionDialog]);\n\n  const resetGame = useCallback(() => {\n    setBoard(initializeBoard());\n    setSelectedPiece(null);\n    setPlayerTurn('white');\n    setGameStatus('ongoing');\n    setMoveHistory([]);\n    setGameState({\n      enPassantTarget: null,\n      castlingRights: {\n        white: { kingSide: true, queenSide: true },\n        black: { kingSide: true, queenSide: true }\n      }\n    });\n    setHighlightedSquares([]);\n    setCheckIndicator(null);\n    setShowHint(false);\n    setHintMove(null);\n    setPromotionDialog(null);\n  }, []);\n\n  const handleDifficultyChange = useCallback((difficulty) => {\n    setAiDifficulty(difficulty);\n    resetGame();\n  }, [resetGame]);\n\n  const getHint = useCallback(() => {\n    // Use the AI to suggest a move for the player\n    if (playerTurn === 'white' && gameStatus === 'ongoing') {\n      const suggestedMove = getAIMove(board, 'white', gameState, 2);\n      if (suggestedMove) {\n        setShowHint(true);\n        setHintMove(suggestedMove);\n      }\n    }\n  }, [board, gameState, gameStatus, playerTurn]);\n\n  // Handle theme change\n  const handleThemeChange = useCallback((themeKey) => {\n    setCurrentTheme(themeKey);\n    // Save theme preference to localStorage\n    localStorage.setItem('chessTheme', themeKey);\n  }, []);\n\n  // Load saved theme from localStorage on initial render\n  useEffect(() => {\n    const savedTheme = localStorage.getItem('chessTheme');\n    if (savedTheme && themes[savedTheme]) {\n      setCurrentTheme(savedTheme);\n    }\n  }, []);\n\n  // Memoize the last move for better performance\n  const lastMove = useMemo(() => {\n    return moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;\n  }, [moveHistory]);\n\n  // Memoize the current theme object\n  const currentThemeObject = useMemo(() => themes[currentTheme], [currentTheme]);\n\n  return (\n    <div className=\"app\">\n      <div className=\"app-header\">\n        <h1>AI Chess</h1>\n        <div className=\"author-credits\">\n          <span>Created by Aditya Thakkar</span>\n        </div>\n      </div>\n      <div className=\"difficulty-selector\">\n        <span className=\"difficulty-label\">AI Difficulty:</span>\n        <div className=\"difficulty-buttons\">\n          <button \n            className={`difficulty-button ${aiDifficulty === 'easy' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('easy')}\n          >\n            Easy\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'medium' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('medium')}\n          >\n            Medium\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'hard' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('hard')}\n          >\n            Hard\n          </button>\n        </div>\n      </div>\n      <ThemeSelector \n        currentTheme={currentTheme} \n        onThemeChange={handleThemeChange} \n      />\n      <div className=\"game-container\">\n        <ChessBoard \n          board={board} \n          selectedPiece={selectedPiece} \n          onSquareClick={handleSquareClick}\n          highlightedSquares={highlightedSquares}\n          checkIndicator={checkIndicator}\n          lastMove={lastMove}\n          hintMove={showHint ? hintMove : null}\n          theme={currentThemeObject}\n        />\n        <GameInfo \n          playerTurn={playerTurn} \n          gameStatus={gameStatus} \n          moveHistory={moveHistory} \n          onResetGame={resetGame} \n          isInCheck={checkIndicator !== null}\n          aiDifficulty={aiDifficulty}\n          onGetHint={getHint}\n          aiThinking={aiThinking}\n        />\n      </div>\n      {promotionDialog && (\n        <PromotionDialog \n          position={promotionDialog.position}\n          color=\"white\"\n          onSelect={handlePromotion}\n          onCancel={() => setPromotionDialog(null)}\n        />\n      )}\n      <div className=\"app-footer\">\n        <div className=\"footer-content\">\n          <p>Chess AI with Minimax Algorithm & Alpha-Beta Pruning</p>\n          <p> {new Date().getFullYear()} AI Chess by Aditya Thakkar</p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App; \n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n); "],"sourceRoot":""}