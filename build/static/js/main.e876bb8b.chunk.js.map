{"version":3,"sources":["assets/pieces/white-pawn.svg","assets/pieces/white-rook.svg","assets/pieces/white-knight.svg","assets/pieces/white-bishop.svg","assets/pieces/white-queen.svg","assets/pieces/white-king.svg","assets/pieces/black-pawn.svg","assets/pieces/black-rook.svg","assets/pieces/black-knight.svg","assets/pieces/black-bishop.svg","assets/pieces/black-queen.svg","assets/pieces/black-king.svg","components/ChessBoard.js","components/GameInfo.js","components/PromotionDialog.js","themes.js","components/ThemeSelector.js","utils/chessLogic.js","utils/aiPlayer.js","App.js","index.js"],"names":["pieceImages","whitePawn","whiteRook","whiteKnight","whiteBishop","whiteQueen","whiteKing","blackPawn","blackRook","blackKnight","blackBishop","blackQueen","blackKing","Square","memo","_ref","row","col","piece","isLight","isSelected","isHighlighted","isCheck","isLastMove","isHint","squareColor","onClick","squareClassName","squareStyle","backgroundColor","_jsx","className","style","children","captured","src","color","type","alt","Coordinates","_jsxs","map","file","rank","CapturedPieces","_ref2","capturedPieces","capturedByOpponent","black","white","length","index","ChessBoard","_ref3","board","selectedPiece","onSquareClick","highlightedSquares","checkIndicator","lastMove","hintMove","theme","useMemo","flat","forEach","push","highlightedSquaresMap","square","lastMoveMap","from","to","hintSquareMap","fromRow","fromCol","toRow","toCol","boardRows","squares","isHintSquare","lightSquare","darkSquare","containerStyle","background","boardBg","highlightColor","checkColor","lastMoveColor","accentColor","GameInfo","playerTurn","gameStatus","moveHistory","onResetGame","isInCheck","aiDifficulty","onGetHint","aiThinking","onDifficultyChange","activeTab","setActiveTab","useState","groupedMoves","i","number","Math","floor","materialAdvantage","calculateMaterialAdvantage","pieceValues","whiteCaptured","blackCaptured","move","capturedPiece","advantage","value","abs","renderGameStatus","statusText","includes","disabled","notation","renderAnalysis","searchDepth","PromotionDialog","position","onSelect","onCancel","top","y","left","x","e","stopPropagation","themes","classic","name","blue","dark","green","coral","ThemeSelector","currentTheme","onThemeChange","Object","keys","themeKey","title","initializeBoard","Array","fill","hasMoved","isSquareUnderAttack","attackerColor","pawnDirection","knightMoves","rowOffset","colOffset","newRow","newCol","directions","rowDir","colDir","gameState","kingPos","findKing","opponentColor","wouldBeInCheck","newBoard","JSON","parse","stringify","cloneBoard","enPassantTarget","isValidMove","targetPiece","isValid","isValidPawnMove","isValidKnightMove","isValidBishopMove","isValidRookMove","isValidQueenMove","isValidKingMove","direction","start","min","end","max","rowDiff","colDiff","rowDirection","colDirection","rook","isPawnPromotion","makeMove","promotionPiece","arguments","undefined","newGameState","castlingRights","kingSide","queenSide","captureRow","isCheckmate","isStalemate","positionBonus","evaluationCache","Map","evaluateBoard","score","totalMaterial","material","countMaterial","isEndgame","materialValue","positionValue","kingEndgame","bonusValue","doubledPawns","r","hasPair","c","otherPiece","openFile","totalValue","findAllValidMoves","moves","sort","a","b","targetA","targetB","captureValueA","captureValueB","promotionValueA","minimax","depth","alpha","beta","maximizingPlayer","startTime","maxTime","Date","now","Error","boardHash","hash","getBoardHash","cacheKey","has","get","bestValue","Infinity","set","size","clear","getAIMove","difficulty","maxDepth","randomChance","random","iterativeDeepeningSearch","bestMove","bestScore","currentBestMove","currentBestScore","console","log","error","message","fallbackError","App","setBoard","setSelectedPiece","setPlayerTurn","setGameStatus","setMoveHistory","setGameState","setHighlightedSquares","setCheckIndicator","setAiDifficulty","showHint","setShowHint","setHintMove","promotionDialog","setPromotionDialog","setCurrentTheme","setAiThinking","handleMoveRef","useRef","generateMoveNotation","useCallback","files","charAt","toUpperCase","handleMove","newMove","prevHistory","prevTurn","useEffect","current","makeAIMove","requestAnimationFrame","aiMove","randomMove","timeoutId","setTimeout","clearTimeout","whiteInCheck","blackInCheck","validMoves","pieceType","handleSquareClick","boardRect","document","querySelector","getBoundingClientRect","squareSize","width","handlePromotion","resetGame","handleDifficultyChange","getHint","suggestedMove","handleThemeChange","localStorage","setItem","savedTheme","getItem","currentThemeObject","getFullYear","ReactDOM","render","React","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.e876bb8b.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/white-pawn.236f6686.svg\";","export default __webpack_public_path__ + \"static/media/white-rook.51da5ea4.svg\";","export default __webpack_public_path__ + \"static/media/white-knight.6682d263.svg\";","export default __webpack_public_path__ + \"static/media/white-bishop.434cf6df.svg\";","export default __webpack_public_path__ + \"static/media/white-queen.2ec74f60.svg\";","export default __webpack_public_path__ + \"static/media/white-king.5933a366.svg\";","export default __webpack_public_path__ + \"static/media/black-pawn.3df4af41.svg\";","export default __webpack_public_path__ + \"static/media/black-rook.6208da08.svg\";","export default __webpack_public_path__ + \"static/media/black-knight.dbe602a6.svg\";","export default __webpack_public_path__ + \"static/media/black-bishop.d3b59849.svg\";","export default __webpack_public_path__ + \"static/media/black-queen.81d53079.svg\";","export default __webpack_public_path__ + \"static/media/black-king.5c3d9d02.svg\";","import React, { useMemo, memo } from 'react';\nimport './ChessBoard.css';\n\n// Import SVG pieces\nimport whitePawn from '../assets/pieces/white-pawn.svg';\nimport whiteRook from '../assets/pieces/white-rook.svg';\nimport whiteKnight from '../assets/pieces/white-knight.svg';\nimport whiteBishop from '../assets/pieces/white-bishop.svg';\nimport whiteQueen from '../assets/pieces/white-queen.svg';\nimport whiteKing from '../assets/pieces/white-king.svg';\nimport blackPawn from '../assets/pieces/black-pawn.svg';\nimport blackRook from '../assets/pieces/black-rook.svg';\nimport blackKnight from '../assets/pieces/black-knight.svg';\nimport blackBishop from '../assets/pieces/black-bishop.svg';\nimport blackQueen from '../assets/pieces/black-queen.svg';\nimport blackKing from '../assets/pieces/black-king.svg';\n\n// Map piece types to SVG images - moved outside component for better performance\nconst pieceImages = {\n  'white': {\n    'pawn': whitePawn,\n    'rook': whiteRook,\n    'knight': whiteKnight,\n    'bishop': whiteBishop,\n    'queen': whiteQueen,\n    'king': whiteKing\n  },\n  'black': {\n    'pawn': blackPawn,\n    'rook': blackRook,\n    'knight': blackKnight,\n    'bishop': blackBishop,\n    'queen': blackQueen,\n    'king': blackKing\n  }\n};\n\n// Memoized Square component for better performance\nconst Square = memo(({ \n  row, \n  col, \n  piece, \n  isLight, \n  isSelected, \n  isHighlighted, \n  isCheck, \n  isLastMove, \n  isHint, \n  squareColor, \n  onClick \n}) => {\n  let squareClassName = `square ${isLight ? 'light' : 'dark'}`;\n  if (isSelected) squareClassName += ' selected';\n  if (isHighlighted) squareClassName += ' highlighted';\n  if (isCheck) squareClassName += ' check';\n  if (isLastMove) squareClassName += ' last-move';\n  if (isHint) squareClassName += ' hint';\n  \n  const squareStyle = {\n    backgroundColor: squareColor\n  };\n  \n  return (\n    <div \n      className={squareClassName}\n      style={squareStyle}\n      onClick={onClick}\n    >\n      {piece && !piece.captured && (\n        <img \n          src={pieceImages[piece.color][piece.type]} \n          alt={`${piece.color} ${piece.type}`} \n          className={`piece ${piece.color}`}\n        />\n      )}\n    </div>\n  );\n});\n\n// Memoized coordinates component\nconst Coordinates = memo(() => {\n  const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n  const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n  \n  return (\n    <div className=\"board-coordinates\">\n      <div className=\"files\">\n        {files.map(file => (\n          <div key={file}>{file}</div>\n        ))}\n      </div>\n      <div className=\"ranks\">\n        {ranks.map(rank => (\n          <div key={rank}>{rank}</div>\n        ))}\n      </div>\n    </div>\n  );\n});\n\n// Memoized captured pieces component\nconst CapturedPieces = memo(({ capturedPieces, color }) => {\n  const capturedByOpponent = color === 'white' ? capturedPieces.black : capturedPieces.white;\n  \n  if (capturedByOpponent.length === 0) return null;\n  \n  return (\n    <div className=\"captured-row\">\n      {capturedByOpponent.map((piece, index) => (\n        <img \n          key={index}\n          src={pieceImages[piece.color][piece.type]} \n          alt={`${piece.color} ${piece.type}`} \n          className=\"captured-piece\"\n        />\n      ))}\n    </div>\n  );\n});\n\nconst ChessBoard = ({ \n  board, \n  selectedPiece, \n  onSquareClick, \n  highlightedSquares, \n  checkIndicator,\n  lastMove,\n  hintMove,\n  theme\n}) => {\n  // Calculate captured pieces - memoized for performance\n  const capturedPieces = useMemo(() => {\n    const captured = {\n      white: [],\n      black: []\n    };\n    \n    board.flat().forEach(piece => {\n      if (piece && piece.captured) {\n        captured[piece.color].push(piece);\n      }\n    });\n    \n    return captured;\n  }, [board]);\n\n  // Check if a square is highlighted (valid move) - memoized lookup map\n  const highlightedSquaresMap = useMemo(() => {\n    const map = {};\n    highlightedSquares.forEach(square => {\n      map[`${square.row}-${square.col}`] = true;\n    });\n    return map;\n  }, [highlightedSquares]);\n  \n  // Check if a square is part of the last move - memoized\n  const lastMoveMap = useMemo(() => {\n    if (!lastMove) return {};\n    \n    const { from, to } = lastMove;\n    return {\n      [`${from.row}-${from.col}`]: true,\n      [`${to.row}-${to.col}`]: true\n    };\n  }, [lastMove]);\n  \n  // Check if a square is part of a hint - memoized\n  const hintSquareMap = useMemo(() => {\n    if (!hintMove) return {};\n    \n    const { fromRow, fromCol, toRow, toCol } = hintMove;\n    return {\n      [`${fromRow}-${fromCol}`]: true,\n      [`${toRow}-${toCol}`]: true\n    };\n  }, [hintMove]);\n\n  // Render the board - memoized for performance\n  const boardRows = useMemo(() => {\n    const squares = [];\n    \n    // Define these functions inside the useMemo callback to avoid dependency issues\n    const isHighlighted = (row, col) => {\n      return !!highlightedSquaresMap[`${row}-${col}`];\n    };\n    \n    const isLastMove = (row, col) => {\n      return !!lastMoveMap[`${row}-${col}`];\n    };\n    \n    const isHintSquare = (row, col) => {\n      return !!hintSquareMap[`${row}-${col}`];\n    };\n    \n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col];\n        const isLight = (row + col) % 2 === 0;\n        const isSelected = selectedPiece && selectedPiece.row === row && selectedPiece.col === col;\n        const isCheck = checkIndicator && piece && piece.type === 'king' && piece.color === checkIndicator;\n        \n        // Get the square color from the theme\n        const squareColor = isLight ? theme.lightSquare : theme.darkSquare;\n        \n        squares.push(\n          <Square\n            key={`${row}-${col}`}\n            row={row}\n            col={col}\n            piece={piece}\n            isLight={isLight}\n            isSelected={isSelected}\n            isHighlighted={isHighlighted(row, col)}\n            isCheck={isCheck}\n            isLastMove={isLastMove(row, col)}\n            isHint={isHintSquare(row, col)}\n            squareColor={squareColor}\n            onClick={() => onSquareClick(row, col)}\n          />\n        );\n      }\n    }\n    \n    return squares;\n  }, [board, selectedPiece, checkIndicator, theme, onSquareClick, highlightedSquaresMap, lastMoveMap, hintSquareMap]);\n\n  // Apply theme styles\n  const containerStyle = useMemo(() => ({\n    background: theme.boardBg,\n    '--highlight-color': theme.highlightColor,\n    '--check-color': theme.checkColor,\n    '--last-move-color': theme.lastMoveColor,\n    '--accent-color': theme.accentColor\n  }), [theme]);\n\n  return (\n    <div className=\"chess-board-container\" style={containerStyle}>\n      <div className=\"chess-board\">\n        {boardRows}\n      </div>\n      <Coordinates />\n      <div className=\"captured-pieces\">\n        <CapturedPieces capturedPieces={capturedPieces} color=\"white\" />\n        <CapturedPieces capturedPieces={capturedPieces} color=\"black\" />\n      </div>\n    </div>\n  );\n};\n\nexport default memo(ChessBoard); ","import React, { useState } from 'react';\nimport './GameInfo.css';\n\nconst GameInfo = ({ \n  playerTurn, \n  gameStatus, \n  moveHistory, \n  onResetGame, \n  isInCheck,\n  aiDifficulty,\n  onGetHint,\n  aiThinking,\n  onDifficultyChange\n}) => {\n  const [activeTab, setActiveTab] = useState('moves');\n  \n  // Group moves into pairs (white and black)\n  const groupedMoves = [];\n  for (let i = 0; i < moveHistory.length; i += 2) {\n    groupedMoves.push({\n      number: Math.floor(i / 2) + 1,\n      white: moveHistory[i],\n      black: moveHistory[i + 1]\n    });\n  }\n  \n  // Calculate material advantage\n  const calculateMaterialAdvantage = () => {\n    const pieceValues = {\n      'pawn': 1,\n      'knight': 3,\n      'bishop': 3,\n      'rook': 5,\n      'queen': 9,\n      'king': 0\n    };\n    \n    let whiteCaptured = 0;\n    let blackCaptured = 0;\n    \n    moveHistory.forEach(move => {\n      if (move.capturedPiece) {\n        if (move.capturedPiece.color === 'white') {\n          blackCaptured += pieceValues[move.capturedPiece.type];\n        } else {\n          whiteCaptured += pieceValues[move.capturedPiece.type];\n        }\n      }\n    });\n    \n    const advantage = whiteCaptured - blackCaptured;\n    \n    if (advantage > 0) {\n      return { color: 'white', value: advantage };\n    } else if (advantage < 0) {\n      return { color: 'black', value: Math.abs(advantage) };\n    } else {\n      return { color: 'equal', value: 0 };\n    }\n  };\n  \n  const materialAdvantage = calculateMaterialAdvantage();\n  \n  // Render game status\n  const renderGameStatus = () => {\n    let statusText = '';\n    \n    if (gameStatus === 'ongoing') {\n      statusText = `${playerTurn === 'white' ? 'White' : 'Black'}'s turn`;\n    } else if (gameStatus.includes('checkmate')) {\n      statusText = gameStatus;\n    } else if (gameStatus.includes('stalemate')) {\n      statusText = 'Draw by stalemate';\n    } else {\n      statusText = gameStatus;\n    }\n    \n    return (\n      <div className=\"status-container\">\n        <div className=\"status\">\n          {statusText}\n          {aiThinking && playerTurn === 'black' && (\n            <div className=\"ai-thinking\">\n              <span>AI is thinking</span>\n              <div className=\"thinking-dots\">\n                <span className=\"dot\"></span>\n                <span className=\"dot\"></span>\n                <span className=\"dot\"></span>\n              </div>\n            </div>\n          )}\n        </div>\n        <div className=\"player-indicators\">\n          <div className={`player-indicator ${playerTurn === 'white' ? 'active' : ''}`}>\n            <span className=\"white\">White</span>\n            {isInCheck && playerTurn === 'white' && <span className=\"check-indicator\">CHECK!</span>}\n          </div>\n          <div className={`player-indicator ${playerTurn === 'black' ? 'active' : ''}`}>\n            <span className=\"black\">Black</span>\n            {isInCheck && playerTurn === 'black' && <span className=\"check-indicator\">CHECK!</span>}\n          </div>\n        </div>\n        {isInCheck && gameStatus === 'ongoing' && (\n          <div className=\"check-status\">\n            {isInCheck === 'white' ? 'White' : 'Black'} is in check!\n          </div>\n        )}\n        {gameStatus !== 'ongoing' && (\n          <div className=\"game-over\">\n            {gameStatus}\n          </div>\n        )}\n        <div className=\"button-container\">\n          <button className=\"reset-button\" onClick={onResetGame}>\n            New Game\n          </button>\n          <button \n            className=\"hint-button\" \n            onClick={onGetHint}\n            disabled={gameStatus !== 'ongoing' || playerTurn !== 'white' || aiThinking}\n          >\n            Hint\n          </button>\n        </div>\n      </div>\n    );\n  };\n  \n  // Render move history\n  const renderMoveHistory = () => {\n    if (moveHistory.length === 0) {\n      return <div className=\"no-moves\">No moves yet</div>;\n    }\n    \n    return (\n      <div className=\"moves-container\">\n        <table className=\"moves-table\">\n          <thead>\n            <tr>\n              <th>#</th>\n              <th>White</th>\n              <th>Black</th>\n            </tr>\n          </thead>\n          <tbody>\n            {groupedMoves.map(move => (\n              <tr key={move.number}>\n                <td className=\"move-number\">{move.number}</td>\n                <td className=\"white-move\">{move.white ? move.white.notation : ''}</td>\n                <td className=\"black-move\">{move.black ? move.black.notation : ''}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  };\n  \n  // Render analysis\n  const renderAnalysis = () => {\n    const searchDepth = {\n      'easy': 3,\n      'medium': 4,\n      'hard': 5\n    }[aiDifficulty];\n    \n    return (\n      <div className=\"analysis-container\">\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">Total Moves</span>\n          <span className=\"analysis-value\">{moveHistory.length}</span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">Material Advantage</span>\n          <span className={`analysis-value material-advantage ${materialAdvantage.color}`}>\n            {materialAdvantage.color === 'equal' ? 'Equal' : `+${materialAdvantage.value} for ${materialAdvantage.color}`}\n          </span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">AI Thinking Depth</span>\n          <span className=\"analysis-value\">{searchDepth} {searchDepth === 1 ? 'move' : 'moves'}</span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">AI Status</span>\n          <span className=\"analysis-value\">\n            {aiThinking ? (\n              <span className=\"ai-thinking-status\">Calculating...</span>\n            ) : (\n              <span className=\"ai-ready-status\">Ready</span>\n            )}\n          </span>\n        </div>\n      </div>\n    );\n  };\n  \n  return (\n    <div className=\"game-info\">\n      <h2>Game Status</h2>\n      {renderGameStatus()}\n      \n      <div className=\"tabs\">\n        <div \n          className={`tab ${activeTab === 'moves' ? 'active' : ''}`}\n          onClick={() => setActiveTab('moves')}\n        >\n          Moves\n        </div>\n        <div \n          className={`tab ${activeTab === 'analysis' ? 'active' : ''}`}\n          onClick={() => setActiveTab('analysis')}\n        >\n          Analysis\n        </div>\n      </div>\n      \n      <div className=\"tab-content\">\n        {activeTab === 'moves' ? renderMoveHistory() : renderAnalysis()}\n      </div>\n      \n      <div className=\"difficulty-section\">\n        <label>AI Difficulty:</label>\n        <div className=\"difficulty-buttons\">\n          <button \n            className={`difficulty-button ${aiDifficulty === 'easy' ? 'active' : ''}`}\n            onClick={() => onDifficultyChange('easy')}\n            disabled={aiThinking}\n          >\n            Easy\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'medium' ? 'active' : ''}`}\n            onClick={() => onDifficultyChange('medium')}\n            disabled={aiThinking}\n          >\n            Medium\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'hard' ? 'active' : ''}`}\n            onClick={() => onDifficultyChange('hard')}\n            disabled={aiThinking}\n          >\n            Hard\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default GameInfo; ","import React from 'react';\nimport './PromotionDialog.css';\n\n// Import SVG pieces\nimport whiteQueen from '../assets/pieces/white-queen.svg';\nimport whiteRook from '../assets/pieces/white-rook.svg';\nimport whiteBishop from '../assets/pieces/white-bishop.svg';\nimport whiteKnight from '../assets/pieces/white-knight.svg';\nimport blackQueen from '../assets/pieces/black-queen.svg';\nimport blackRook from '../assets/pieces/black-rook.svg';\nimport blackBishop from '../assets/pieces/black-bishop.svg';\nimport blackKnight from '../assets/pieces/black-knight.svg';\n\nconst PromotionDialog = ({ position, color, onSelect, onCancel }) => {\n  const pieceImages = {\n    'white': {\n      'queen': whiteQueen,\n      'rook': whiteRook,\n      'bishop': whiteBishop,\n      'knight': whiteKnight\n    },\n    'black': {\n      'queen': blackQueen,\n      'rook': blackRook,\n      'bishop': blackBishop,\n      'knight': blackKnight\n    }\n  };\n\n  const pieces = ['queen', 'rook', 'bishop', 'knight'];\n\n  return (\n    <div className=\"promotion-dialog-backdrop\" onClick={onCancel}>\n      <div \n        className=\"promotion-dialog\" \n        style={{ \n          top: position.y, \n          left: position.x \n        }}\n        onClick={(e) => e.stopPropagation()}\n      >\n        <div className=\"promotion-title\">Promote to:</div>\n        <div className=\"promotion-options\">\n          {pieces.map(piece => (\n            <div \n              key={piece} \n              className=\"promotion-piece\" \n              onClick={() => onSelect(piece)}\n            >\n              <img \n                src={pieceImages[color][piece]} \n                alt={`${color} ${piece}`} \n                className=\"promotion-piece-image\"\n              />\n              <div className=\"promotion-piece-name\">{piece}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PromotionDialog; ","// Chess board themes\nconst themes = {\n  // Classic wooden theme\n  classic: {\n    name: 'Classic',\n    lightSquare: '#f0d9b5',\n    darkSquare: '#b58863',\n    highlightColor: 'rgba(78, 205, 196, 0.7)',\n    checkColor: 'rgba(255, 107, 107, 0.6)',\n    lastMoveColor: 'rgba(255, 209, 102, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9))',\n    accentColor: '#4ecdc4'\n  },\n  \n  // Blue theme\n  blue: {\n    name: 'Ocean Blue',\n    lightSquare: '#dee3e6',\n    darkSquare: '#8ca2ad',\n    highlightColor: 'rgba(106, 168, 79, 0.7)',\n    checkColor: 'rgba(244, 67, 54, 0.6)',\n    lastMoveColor: 'rgba(255, 193, 7, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(25, 118, 210, 0.9), rgba(13, 71, 161, 0.9))',\n    accentColor: '#03a9f4'\n  },\n  \n  // Dark theme\n  dark: {\n    name: 'Midnight',\n    lightSquare: '#6b7987',\n    darkSquare: '#2e3947',\n    highlightColor: 'rgba(121, 134, 203, 0.7)',\n    checkColor: 'rgba(255, 82, 82, 0.6)',\n    lastMoveColor: 'rgba(255, 215, 64, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(20, 20, 31, 0.9), rgba(10, 10, 18, 0.9))',\n    accentColor: '#9c27b0'\n  },\n  \n  // Green theme\n  green: {\n    name: 'Forest',\n    lightSquare: '#eeeed2',\n    darkSquare: '#769656',\n    highlightColor: 'rgba(119, 149, 86, 0.7)',\n    checkColor: 'rgba(255, 97, 97, 0.6)',\n    lastMoveColor: 'rgba(255, 213, 79, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(27, 94, 32, 0.9), rgba(46, 125, 50, 0.9))',\n    accentColor: '#8bc34a'\n  },\n  \n  // Coral theme\n  coral: {\n    name: 'Coral',\n    lightSquare: '#fce4ec',\n    darkSquare: '#f06292',\n    highlightColor: 'rgba(128, 203, 196, 0.7)',\n    checkColor: 'rgba(255, 82, 82, 0.6)',\n    lastMoveColor: 'rgba(255, 202, 40, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(216, 27, 96, 0.9), rgba(142, 36, 170, 0.9))',\n    accentColor: '#00bcd4'\n  }\n};\n\nexport default themes; ","import React from 'react';\nimport './ThemeSelector.css';\nimport themes from '../themes';\n\nconst ThemeSelector = ({ currentTheme, onThemeChange }) => {\n  return (\n    <div className=\"theme-selector\">\n      <div className=\"theme-selector-label\">Board Theme:</div>\n      <div className=\"theme-options\">\n        {Object.keys(themes).map(themeKey => (\n          <div \n            key={themeKey}\n            className={`theme-option ${currentTheme === themeKey ? 'active' : ''}`}\n            onClick={() => onThemeChange(themeKey)}\n            title={themes[themeKey].name}\n          >\n            <div \n              className=\"theme-preview\"\n              style={{\n                background: `linear-gradient(135deg, \n                  ${themes[themeKey].lightSquare} 0%, \n                  ${themes[themeKey].lightSquare} 50%, \n                  ${themes[themeKey].darkSquare} 50%, \n                  ${themes[themeKey].darkSquare} 100%)`\n              }}\n            ></div>\n            <span className=\"theme-name\">{themes[themeKey].name}</span>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default ThemeSelector; ","// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n  \n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };\n    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };\n  }\n  \n  // Set up rooks\n  board[0][0] = { type: 'rook', color: 'black', hasMoved: false };\n  board[0][7] = { type: 'rook', color: 'black', hasMoved: false };\n  board[7][0] = { type: 'rook', color: 'white', hasMoved: false };\n  board[7][7] = { type: 'rook', color: 'white', hasMoved: false };\n  \n  // Set up knights\n  board[0][1] = { type: 'knight', color: 'black', hasMoved: false };\n  board[0][6] = { type: 'knight', color: 'black', hasMoved: false };\n  board[7][1] = { type: 'knight', color: 'white', hasMoved: false };\n  board[7][6] = { type: 'knight', color: 'white', hasMoved: false };\n  \n  // Set up bishops\n  board[0][2] = { type: 'bishop', color: 'black', hasMoved: false };\n  board[0][5] = { type: 'bishop', color: 'black', hasMoved: false };\n  board[7][2] = { type: 'bishop', color: 'white', hasMoved: false };\n  board[7][5] = { type: 'bishop', color: 'white', hasMoved: false };\n  \n  // Set up queens\n  board[0][3] = { type: 'queen', color: 'black', hasMoved: false };\n  board[7][3] = { type: 'queen', color: 'white', hasMoved: false };\n  \n  // Set up kings\n  board[0][4] = { type: 'king', color: 'black', hasMoved: false };\n  board[7][4] = { type: 'king', color: 'white', hasMoved: false };\n  \n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = (board) => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return { row, col };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row - pawnDirection >= 0 && row - pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row - pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row - pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from knights\n  const knightMoves = [\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n    [1, -2], [1, 2], [2, -1], [2, 1]\n  ];\n  \n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    \n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from bishops, rooks, and queens\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1], [0, -1],\n    [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n  \n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    \n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      \n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' ||\n              (piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir)) ||\n              (piece.type === 'rook' && (rowDir === 0 || colDir === 0))) {\n            return true;\n          }\n          \n          // King can attack adjacent squares\n          if (piece.type === 'king' && \n              Math.abs(newRow - row) <= 1 && \n              Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      \n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  \n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color, gameState) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  \n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color, gameState) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  const piece = newBoard[fromRow][fromCol];\n  \n  // Handle en passant capture\n  if (piece.type === 'pawn' && fromCol !== toCol && !newBoard[toRow][toCol] && \n      gameState && gameState.enPassantTarget &&\n      toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n    // Remove the captured pawn\n    const capturedPawnRow = color === 'white' ? toRow + 1 : toRow - 1;\n    newBoard[capturedPawnRow][toCol] = null;\n  }\n  \n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[toRow][toCol - 1] = newBoard[toRow][7]; // Move rook\n      newBoard[toRow][7] = null; // Remove rook from original position\n    } \n    // Queenside castling\n    else {\n      newBoard[toRow][toCol + 1] = newBoard[toRow][0]; // Move rook\n      newBoard[toRow][0] = null; // Remove rook from original position\n    }\n  }\n  \n  // Make the move\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color, gameState);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  // Check if the coordinates are valid\n  if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||\n      toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {\n    return false;\n  }\n  \n  // Check if there is a piece at the starting position\n  const piece = board[fromRow][fromCol];\n  if (!piece) {\n    return false;\n  }\n  \n  // Check if the destination has a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) {\n    return false;\n  }\n  \n  // Prevent capturing the king\n  if (targetPiece && targetPiece.type === 'king') {\n    return false;\n  }\n  \n  // Check piece-specific movement rules\n  let isValid = false;\n  \n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n  \n  // If the move is valid according to piece rules, check if it would leave the king in check\n  if (isValid) {\n    // Check if the king would be in check after the move\n    if (wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, piece.color, gameState)) {\n      return false;\n    }\n  }\n  \n  return isValid;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  \n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Moving forward two squares from starting position\n  if (fromCol === toCol && \n      ((piece.color === 'white' && fromRow === 6) || (piece.color === 'black' && fromRow === 1)) && \n      toRow === fromRow + 2 * direction &&\n      !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n    \n    // En passant capture\n    if (!board[toRow][toCol] && gameState && gameState.enPassantTarget &&\n        toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  \n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  \n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  \n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  if (rowDiff !== colDiff) return false;\n  \n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  \n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  \n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  \n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n  \n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color, gameState)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Check if a pawn can be promoted\nexport const isPawnPromotion = (piece, toRow) => {\n  if (!piece || piece.type !== 'pawn') return false;\n  \n  // White pawns promote on row 0, black pawns on row 7\n  return (piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7);\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece = null) => {\n  // Create a deep copy of the board and game state\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const newGameState = JSON.parse(JSON.stringify(gameState || { enPassantTarget: null, castlingRights: { white: { kingSide: true, queenSide: true }, black: { kingSide: true, queenSide: true } } }));\n  \n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n  let capturedPiece = targetPiece;\n  \n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[toRow][toCol - 1] = newBoard[toRow][7]; // Move rook\n      newBoard[toRow][toCol - 1].hasMoved = true; // Mark rook as moved\n      newBoard[toRow][7] = null; // Remove rook from original position\n    } \n    // Queenside castling\n    else {\n      newBoard[toRow][toCol + 1] = newBoard[toRow][0]; // Move rook\n      newBoard[toRow][toCol + 1].hasMoved = true; // Mark rook as moved\n      newBoard[toRow][0] = null; // Remove rook from original position\n    }\n  }\n  \n  // Handle en passant capture\n  if (piece.type === 'pawn' && fromCol !== toCol && !targetPiece) {\n    // This is a diagonal move without a target piece, must be en passant\n    const captureRow = fromRow; // The pawn to be captured is on the same row as the moving pawn\n    capturedPiece = newBoard[captureRow][toCol]; // Store the captured pawn\n    newBoard[captureRow][toCol] = null; // Capture the pawn that just moved\n  }\n  \n  // Update en passant target\n  newGameState.enPassantTarget = null;\n  if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {\n    const direction = piece.color === 'white' ? -1 : 1;\n    newGameState.enPassantTarget = { row: fromRow + direction, col: fromCol };\n  }\n  \n  // Update castling rights\n  if (piece.type === 'king') {\n    newGameState.castlingRights[piece.color].kingSide = false;\n    newGameState.castlingRights[piece.color].queenSide = false;\n  } else if (piece.type === 'rook') {\n    if (fromRow === 7 && fromCol === 0 && piece.color === 'white') {\n      newGameState.castlingRights.white.queenSide = false;\n    } else if (fromRow === 7 && fromCol === 7 && piece.color === 'white') {\n      newGameState.castlingRights.white.kingSide = false;\n    } else if (fromRow === 0 && fromCol === 0 && piece.color === 'black') {\n      newGameState.castlingRights.black.queenSide = false;\n    } else if (fromRow === 0 && fromCol === 7 && piece.color === 'black') {\n      newGameState.castlingRights.black.kingSide = false;\n    }\n  }\n  \n  // Handle pawn promotion\n  if (piece.type === 'pawn' && isPawnPromotion(piece, toRow) && promotionPiece) {\n    // Create a new piece of the specified type\n    newBoard[toRow][toCol] = { type: promotionPiece, color: piece.color, hasMoved: true };\n  } else {\n    // Regular move\n    newBoard[toRow][toCol] = piece;\n    newBoard[toRow][toCol].hasMoved = true; // Mark the piece as moved\n  }\n  \n  // Remove the piece from its original position\n  newBoard[fromRow][fromCol] = null;\n  \n  return { board: newBoard, gameState: newGameState, capturedPiece };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color, gameState) => {\n  // If the king is not in check, it's not checkmate\n  if (!isInCheck(board, color, gameState)) {\n    return false;\n  }\n  \n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // If any legal move exists, it's not checkmate\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // If no legal move exists and the king is in check, it's checkmate\n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color, gameState) => {\n  // If the king is in check, it's not stalemate\n  if (isInCheck(board, color, gameState)) {\n    return false;\n  }\n  \n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // If any legal move exists, it's not stalemate\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // If no legal move exists and the king is not in check, it's stalemate\n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = (board, gameState) => {\n  let score = 0;\n  \n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n        \n        // Add positional bonuses\n        let positionalValue = 0;\n        \n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n          \n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n        \n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n        \n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          \n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            \n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          \n          positionalValue += diagonalMoves * 0.05;\n        }\n        \n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && \n                board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          \n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n        \n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(\n            Math.abs(0 - row) + Math.abs(0 - col),\n            Math.abs(0 - row) + Math.abs(7 - col),\n            Math.abs(7 - row) + Math.abs(0 - col),\n            Math.abs(7 - row) + Math.abs(7 - col)\n          );\n          \n          positionalValue += centerDistance * 0.1;\n        }\n        \n        const totalValue = value + positionalValue;\n        \n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n  \n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black', gameState)) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white', gameState)) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black', gameState)) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white', gameState)) {\n      score -= 0.5; // White is in check\n    }\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({ fromRow, fromCol, toRow, toCol });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board, gameState);\n  }\n  \n  // Check for terminal states\n  if (isCheckmate(board, 'white', gameState)) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black', gameState)) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white', gameState) || isStalemate(board, 'black', gameState)) {\n    return 0; // Draw\n  }\n  \n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  \n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  \n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    \n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    \n    if ((isMaximizing && value > bestValue) || (!isMaximizing && value < bestValue)) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}; ","import { \n  makeMove, \n  isValidMove, \n  isInCheck, \n  isCheckmate, \n  isStalemate,\n  cloneBoard\n} from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 100,\n  'knight': 320,\n  'bishop': 330,\n  'rook': 500,\n  'queen': 900,\n  'king': 20000\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [50, 50, 50, 50, 50, 50, 50, 50],\n    [10, 10, 20, 30, 30, 20, 10, 10],\n    [5, 5, 10, 25, 25, 10, 5, 5],\n    [0, 0, 0, 20, 20, 0, 0, 0],\n    [5, -5, -10, 0, 0, -10, -5, 5],\n    [5, 10, 10, -20, -20, 10, 10, 5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  'knight': [\n    [-50, -40, -30, -30, -30, -30, -40, -50],\n    [-40, -20, 0, 0, 0, 0, -20, -40],\n    [-30, 0, 10, 15, 15, 10, 0, -30],\n    [-30, 5, 15, 20, 20, 15, 5, -30],\n    [-30, 0, 15, 20, 20, 15, 0, -30],\n    [-30, 5, 10, 15, 15, 10, 5, -30],\n    [-40, -20, 0, 5, 5, 0, -20, -40],\n    [-50, -40, -30, -30, -30, -30, -40, -50]\n  ],\n  'bishop': [\n    [-20, -10, -10, -10, -10, -10, -10, -20],\n    [-10, 0, 0, 0, 0, 0, 0, -10],\n    [-10, 0, 10, 10, 10, 10, 0, -10],\n    [-10, 5, 5, 10, 10, 5, 5, -10],\n    [-10, 0, 5, 10, 10, 5, 0, -10],\n    [-10, 10, 10, 10, 10, 10, 10, -10],\n    [-10, 5, 0, 0, 0, 0, 5, -10],\n    [-20, -10, -10, -10, -10, -10, -10, -20]\n  ],\n  'rook': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 10, 10, 10, 10, 10, 10, 5],\n    [-5, 0, 0, 0, 0, 0, 0, -5],\n    [-5, 0, 0, 0, 0, 0, 0, -5],\n    [-5, 0, 0, 0, 0, 0, 0, -5],\n    [-5, 0, 0, 0, 0, 0, 0, -5],\n    [-5, 0, 0, 0, 0, 0, 0, -5],\n    [0, 0, 0, 5, 5, 0, 0, 0]\n  ],\n  'queen': [\n    [-20, -10, -10, -5, -5, -10, -10, -20],\n    [-10, 0, 0, 0, 0, 0, 0, -10],\n    [-10, 0, 5, 5, 5, 5, 0, -10],\n    [-5, 0, 5, 5, 5, 5, 0, -5],\n    [0, 0, 5, 5, 5, 5, 0, -5],\n    [-10, 5, 5, 5, 5, 5, 0, -10],\n    [-10, 0, 5, 0, 0, 0, 0, -10],\n    [-20, -10, -10, -5, -5, -10, -10, -20]\n  ],\n  'king': [\n    [-30, -40, -40, -50, -50, -40, -40, -30],\n    [-30, -40, -40, -50, -50, -40, -40, -30],\n    [-30, -40, -40, -50, -50, -40, -40, -30],\n    [-30, -40, -40, -50, -50, -40, -40, -30],\n    [-20, -30, -30, -40, -40, -30, -30, -20],\n    [-10, -20, -20, -20, -20, -20, -20, -10],\n    [20, 20, 0, 0, 0, 0, 20, 20],\n    [20, 30, 10, 0, 0, 10, 30, 20]\n  ],\n  // Endgame king position values - encourage king to move to center in endgame\n  'kingEndgame': [\n    [-50, -40, -30, -20, -20, -30, -40, -50],\n    [-30, -20, -10, 0, 0, -10, -20, -30],\n    [-30, -10, 20, 30, 30, 20, -10, -30],\n    [-30, -10, 30, 40, 40, 30, -10, -30],\n    [-30, -10, 30, 40, 40, 30, -10, -30],\n    [-30, -10, 20, 30, 30, 20, -10, -30],\n    [-30, -30, 0, 0, 0, 0, -30, -30],\n    [-50, -30, -30, -30, -30, -30, -30, -50]\n  ]\n};\n\n// Memoization cache for position evaluation\nconst evaluationCache = new Map();\nconst MAX_CACHE_SIZE = 100000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (evaluationCache.size > MAX_CACHE_SIZE) {\n    // Clear the entire cache for simplicity and performance\n    evaluationCache.clear();\n  }\n};\n\n// Get a simple hash for the board position\nconst getBoardHash = (board) => {\n  let hash = '';\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        hash += `${row}${col}${piece.type[0]}${piece.color[0]}`;\n      }\n    }\n  }\n  return hash;\n};\n\n// Count material to determine game phase\nconst countMaterial = (board) => {\n  let material = 0;\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type !== 'king' && piece.type !== 'pawn') {\n        material += pieceValues[piece.type];\n      }\n    }\n  }\n  return material;\n};\n\n// Evaluate the board position\nconst evaluateBoard = (board, gameState) => {\n  // Check for checkmate or stalemate\n  if (isCheckmate(board, 'black', gameState)) {\n    return 10000; // White wins\n  }\n  if (isCheckmate(board, 'white', gameState)) {\n    return -10000; // Black wins\n  }\n  if (isStalemate(board, 'white', gameState) || isStalemate(board, 'black', gameState)) {\n    return 0; // Draw\n  }\n  \n  let score = 0;\n  \n  // Determine game phase (opening, middlegame, endgame)\n  const totalMaterial = countMaterial(board);\n  const isEndgame = totalMaterial < 3000; // Less than a queen and rook worth of material\n  \n  // Material and position evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (!piece) continue;\n      \n      // Base material value\n      const materialValue = pieceValues[piece.type];\n      \n      // Position value - use endgame table for kings in endgame\n      let positionValue;\n      if (piece.type === 'king' && isEndgame) {\n        positionValue = piece.color === 'white' \n          ? positionBonus.kingEndgame[row][col] \n          : positionBonus.kingEndgame[7 - row][col];\n      } else {\n        positionValue = piece.color === 'white' \n          ? positionBonus[piece.type][row][col] \n          : positionBonus[piece.type][7 - row][col];\n      }\n      \n      // Additional bonuses\n      let bonusValue = 0;\n      \n      // Mobility bonus (simplified)\n      if (piece.type === 'knight' || piece.type === 'bishop') {\n        // Bonus for developed pieces\n        if ((piece.color === 'white' && row < 6) || (piece.color === 'black' && row > 1)) {\n          bonusValue += 10;\n        }\n      }\n      \n      // Pawn structure bonuses\n      if (piece.type === 'pawn') {\n        // Bonus for advanced pawns\n        const advancementBonus = piece.color === 'white' ? (6 - row) * 5 : (row - 1) * 5;\n        bonusValue += advancementBonus;\n        \n        // Bonus for pawns near promotion\n        if ((piece.color === 'white' && row <= 1) || (piece.color === 'black' && row >= 6)) {\n          bonusValue += 50;\n        }\n        \n        // Penalty for doubled pawns\n        let doubledPawns = 0;\n        for (let r = 0; r < 8; r++) {\n          if (r !== row && board[r][col] && \n              board[r][col].type === 'pawn' && \n              board[r][col].color === piece.color) {\n            doubledPawns++;\n          }\n        }\n        bonusValue -= doubledPawns * 20;\n        \n        // Bonus for connected pawns\n        if (col > 0 && board[row][col-1] && \n            board[row][col-1].type === 'pawn' && \n            board[row][col-1].color === piece.color) {\n          bonusValue += 10;\n        }\n        if (col < 7 && board[row][col+1] && \n            board[row][col+1].type === 'pawn' && \n            board[row][col+1].color === piece.color) {\n          bonusValue += 10;\n        }\n      }\n      \n      // Bishop pair bonus\n      if (piece.type === 'bishop') {\n        let hasPair = false;\n        for (let r = 0; r < 8; r++) {\n          for (let c = 0; c < 8; c++) {\n            if (r !== row || c !== col) {\n              const otherPiece = board[r][c];\n              if (otherPiece && otherPiece.type === 'bishop' && otherPiece.color === piece.color) {\n                hasPair = true;\n                break;\n              }\n            }\n          }\n          if (hasPair) break;\n        }\n        if (hasPair) {\n          bonusValue += 50; // Bishop pair bonus\n        }\n      }\n      \n      // Rook on open file bonus\n      if (piece.type === 'rook') {\n        let openFile = true;\n        for (let r = 0; r < 8; r++) {\n          if (board[r][col] && board[r][col].type === 'pawn') {\n            openFile = false;\n            break;\n          }\n        }\n        if (openFile) {\n          bonusValue += 30;\n        }\n      }\n      \n      // Calculate total value for this piece\n      const totalValue = materialValue + positionValue + bonusValue;\n      \n      // Add to score (positive for white, negative for black)\n      if (piece.color === 'white') {\n        score += totalValue;\n      } else {\n        score -= totalValue;\n      }\n    }\n  }\n  \n  // Check bonus/penalty\n  if (isInCheck(board, 'black', gameState)) {\n    score += 50; // Bonus for putting black in check\n  }\n  if (isInCheck(board, 'white', gameState)) {\n    score -= 50; // Penalty for white being in check\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // Check for pawn promotion\n              if (piece.type === 'pawn' && \n                  ((color === 'white' && toRow === 0) || \n                   (color === 'black' && toRow === 7))) {\n                // Add moves for each promotion piece\n                for (const promotionPiece of ['queen', 'rook', 'bishop', 'knight']) {\n                  moves.push({ \n                    fromRow, \n                    fromCol, \n                    toRow, \n                    toCol, \n                    promotionPiece \n                  });\n                }\n              } else {\n                moves.push({ fromRow, fromCol, toRow, toCol });\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try captures first\n  moves.sort((a, b) => {\n    const targetA = board[a.toRow][a.toCol];\n    const targetB = board[b.toRow][b.toCol];\n    \n    // Prioritize captures of high-value pieces\n    const captureValueA = targetA ? pieceValues[targetA.type] : 0;\n    const captureValueB = targetB ? pieceValues[targetB.type] : 0;\n    \n    // Prioritize promotions\n    const promotionValueA = a.promotionPiece ? pieceValues[a.promotionPiece] : 0;\n    const promotionValueB = b.promotionPiece ? pieceValues[b.promotionPiece] : 0;\n    \n    return (captureValueB + promotionValueB) - (captureValueA + promotionValueA);\n  });\n  \n  return moves;\n};\n\n// Minimax algorithm with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, maximizingPlayer, gameState, startTime, maxTime) => {\n  // Check if we've exceeded the time limit\n  if (Date.now() - startTime > maxTime) {\n    throw new Error(\"Time limit exceeded\");\n  }\n  \n  // Check for terminal states\n  if (isCheckmate(board, 'white', gameState)) {\n    return -10000 - depth; // Prefer shorter paths to checkmate\n  }\n  if (isCheckmate(board, 'black', gameState)) {\n    return 10000 + depth; // Prefer shorter paths to checkmate\n  }\n  if (isStalemate(board, 'white', gameState) || isStalemate(board, 'black', gameState)) {\n    return 0; // Draw\n  }\n  \n  // If we've reached the maximum depth, evaluate the board\n  if (depth === 0) {\n    return evaluateBoard(board, gameState);\n  }\n  \n  // Get the hash for the current position\n  const boardHash = getBoardHash(board);\n  const cacheKey = `${boardHash}-${depth}-${maximizingPlayer}`;\n  \n  // Check if we've already evaluated this position\n  if (evaluationCache.has(cacheKey)) {\n    return evaluationCache.get(cacheKey);\n  }\n  \n  const color = maximizingPlayer ? 'white' : 'black';\n  const moves = findAllValidMoves(board, color, gameState);\n  \n  // If no valid moves, it's either checkmate or stalemate\n  if (moves.length === 0) {\n    if (isInCheck(board, color, gameState)) {\n      return maximizingPlayer ? -10000 - depth : 10000 + depth; // Checkmate\n    } else {\n      return 0; // Stalemate\n    }\n  }\n  \n  let bestValue = maximizingPlayer ? -Infinity : Infinity;\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol, promotionPiece } = move;\n    \n    // Make the move\n    const { board: newBoard, gameState: newGameState } = makeMove(\n      board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece\n    );\n    \n    // Recursively evaluate the position\n    const value = minimax(\n      newBoard, \n      depth - 1, \n      alpha, \n      beta, \n      !maximizingPlayer, \n      newGameState,\n      startTime,\n      maxTime\n    );\n    \n    // Update the best value\n    if (maximizingPlayer) {\n      bestValue = Math.max(bestValue, value);\n      alpha = Math.max(alpha, bestValue);\n    } else {\n      bestValue = Math.min(bestValue, value);\n      beta = Math.min(beta, bestValue);\n    }\n    \n    // Alpha-beta pruning\n    if (beta <= alpha) {\n      break;\n    }\n  }\n  \n  // Cache the result\n  evaluationCache.set(cacheKey, bestValue);\n  checkCacheSize();\n  \n  return bestValue;\n};\n\n// Iterative deepening search\nconst iterativeDeepeningSearch = (board, color, gameState, maxDepth, maxTime) => {\n  const startTime = Date.now();\n  let bestMove = null;\n  let bestScore = color === 'white' ? -Infinity : Infinity;\n  \n  // Get all valid moves\n  const moves = findAllValidMoves(board, color, gameState);\n  \n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n  \n  // Try increasing depths until we run out of time or reach maxDepth\n  for (let depth = 1; depth <= maxDepth; depth++) {\n    let currentBestMove = null;\n    let currentBestScore = color === 'white' ? -Infinity : Infinity;\n    \n    try {\n      for (const move of moves) {\n        const { fromRow, fromCol, toRow, toCol, promotionPiece } = move;\n        \n        // Make the move\n        const { board: newBoard, gameState: newGameState } = makeMove(\n          board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece\n        );\n        \n        // Evaluate the position\n        const score = minimax(\n          newBoard, \n          depth - 1, \n          -Infinity, \n          Infinity, \n          color === 'black', // If color is black, next player is white (maximizing)\n          newGameState,\n          startTime,\n          maxTime\n        );\n        \n        // Update the best move\n        if ((color === 'white' && score > currentBestScore) || \n            (color === 'black' && score < currentBestScore)) {\n          currentBestScore = score;\n          currentBestMove = move;\n        }\n      }\n      \n      // Update the overall best move if we completed this depth\n      bestMove = currentBestMove;\n      bestScore = currentBestScore;\n      \n      console.log(`Completed depth ${depth}, best score: ${bestScore}`);\n      \n      // If we found a winning move, return it immediately\n      if ((color === 'white' && bestScore > 9000) || \n          (color === 'black' && bestScore < -9000)) {\n        console.log(\"Found winning move!\");\n        break;\n      }\n    } catch (error) {\n      // If we ran out of time, use the best move from the previous depth\n      if (error.message === \"Time limit exceeded\") {\n        console.log(`Completed depth ${depth - 1}`);\n        break;\n      } else {\n        throw error; // Re-throw other errors\n      }\n    }\n    \n    // Check if we're running out of time\n    if (Date.now() - startTime > maxTime * 0.8) {\n      console.log(`Completed depth ${depth}`);\n      break;\n    }\n  }\n  \n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  try {\n    // Set parameters based on difficulty\n    let maxDepth, maxTime;\n    \n    switch (difficulty) {\n      case 'easy':\n        maxDepth = 3;\n        maxTime = 2000; // 2 seconds\n        break;\n      case 'medium':\n        maxDepth = 4;\n        maxTime = 3000; // 3 seconds\n        break;\n      case 'hard':\n        maxDepth = 5;\n        maxTime = 5000; // 5 seconds\n        break;\n      default:\n        maxDepth = 4;\n        maxTime = 3000;\n    }\n    \n    // Add randomness for easier difficulties\n    const randomChance = difficulty === 'easy' ? 0.2 : (difficulty === 'medium' ? 0.05 : 0);\n    if (Math.random() < randomChance) {\n      const moves = findAllValidMoves(board, color, gameState);\n      if (moves.length > 0) {\n        return moves[Math.floor(Math.random() * moves.length)];\n      }\n    }\n    \n    // Use iterative deepening to find the best move\n    return iterativeDeepeningSearch(board, color, gameState, maxDepth, maxTime);\n  } catch (error) {\n    console.error(\"Error in AI move calculation:\", error);\n    \n    // Fallback to a simple random move\n    try {\n      const moves = findAllValidMoves(board, color, gameState);\n      if (moves.length > 0) {\n        return moves[Math.floor(Math.random() * moves.length)];\n      }\n    } catch (fallbackError) {\n      console.error(\"Error in fallback move generation:\", fallbackError);\n    }\n    \n    return null;\n  }\n}; ","import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport './App.css';\nimport ChessBoard from './components/ChessBoard';\nimport GameInfo from './components/GameInfo';\nimport PromotionDialog from './components/PromotionDialog';\nimport ThemeSelector from './components/ThemeSelector';\nimport themes from './themes';\nimport { \n  initializeBoard, \n  isValidMove, \n  makeMove, \n  isInCheck, \n  isCheckmate, \n  isStalemate,\n  isPawnPromotion\n} from './utils/chessLogic';\nimport { getAIMove } from './utils/aiPlayer';\n\n// eslint-disable-next-line no-unused-vars\nfunction App() {\n  const [board, setBoard] = useState(initializeBoard());\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [playerTurn, setPlayerTurn] = useState('white');\n  const [gameStatus, setGameStatus] = useState('ongoing');\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [gameState, setGameState] = useState({\n    enPassantTarget: null,\n    castlingRights: {\n      white: { kingSide: true, queenSide: true },\n      black: { kingSide: true, queenSide: true }\n    }\n  });\n  const [highlightedSquares, setHighlightedSquares] = useState([]);\n  const [checkIndicator, setCheckIndicator] = useState(null);\n  const [aiDifficulty, setAiDifficulty] = useState('medium'); // 'easy', 'medium', 'hard'\n  const [showHint, setShowHint] = useState(false);\n  const [hintMove, setHintMove] = useState(null);\n  const [promotionDialog, setPromotionDialog] = useState(null);\n  const [currentTheme, setCurrentTheme] = useState('classic');\n  const [aiThinking, setAiThinking] = useState(false);\n\n  // Create a ref to store the handleMove function\n  const handleMoveRef = useRef(null);\n\n  // Generate algebraic notation for a move\n  const generateMoveNotation = useCallback((piece, fromRow, fromCol, toRow, toCol, capturedPiece, promotionPiece) => {\n    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n    \n    let notation = '';\n    \n    // Add piece letter (except for pawns)\n    if (piece.type !== 'pawn') {\n      notation += piece.type.charAt(0).toUpperCase();\n    }\n    \n    // Add starting position for pawns if capturing\n    if (piece.type === 'pawn' && capturedPiece) {\n      notation += files[fromCol];\n    }\n    \n    // Add 'x' if capturing\n    if (capturedPiece) {\n      notation += 'x';\n    }\n    \n    // Add destination square\n    notation += files[toCol] + ranks[toRow];\n    \n    // Add promotion piece\n    if (promotionPiece) {\n      notation += '=' + promotionPiece.charAt(0).toUpperCase();\n    }\n    \n    return notation;\n  }, []);\n\n  // Handle move\n  const handleMove = useCallback((fromRow, fromCol, toRow, toCol, promotionPiece = null) => {\n    // Get the piece before making the move\n    const piece = board[fromRow][fromCol];\n    \n    // Make the move\n    const { board: newBoard, gameState: newGameState, capturedPiece } = makeMove(\n      board, \n      fromRow, \n      fromCol, \n      toRow, \n      toCol, \n      gameState,\n      promotionPiece\n    );\n    \n    // Update the board and game state\n    setBoard(newBoard);\n    setGameState(newGameState);\n    \n    // Generate notation for the move\n    const notation = generateMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece, promotionPiece);\n    \n    // Add move to history\n    const newMove = {\n      from: { row: fromRow, col: fromCol },\n      to: { row: toRow, col: toCol },\n      piece,\n      capturedPiece,\n      notation,\n      color: piece.color\n    };\n    \n    setMoveHistory(prevHistory => [...prevHistory, newMove]);\n    \n    // Switch turns\n    setPlayerTurn(prevTurn => prevTurn === 'white' ? 'black' : 'white');\n    \n    // Clear selection and highlights\n    setSelectedPiece(null);\n    setHighlightedSquares([]);\n    setShowHint(false);\n    setHintMove(null);\n  }, [board, gameState, generateMoveNotation]);\n\n  // Update the ref whenever handleMove changes\n  useEffect(() => {\n    handleMoveRef.current = handleMove;\n  }, [handleMove]);\n\n  // Make AI move - optimized version\n  const makeAIMove = useCallback(() => {\n    if (playerTurn === 'black' && gameStatus === 'ongoing' && !aiThinking) {\n      setAiThinking(true);\n      \n      // Use requestAnimationFrame to ensure UI updates before AI calculation\n      requestAnimationFrame(() => {\n        try {\n          // Get AI move with the current difficulty level\n          const aiMove = getAIMove(board, 'black', gameState, aiDifficulty);\n          \n          if (aiMove) {\n            const { fromRow, fromCol, toRow, toCol, promotionPiece } = aiMove;\n            const piece = board[fromRow][fromCol];\n            \n            // Check if this is a pawn promotion\n            if (isPawnPromotion(piece, toRow)) {\n              // Use the AI's choice of promotion piece or default to queen\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol, promotionPiece || 'queen');\n            } else {\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol);\n            }\n          } else {\n            // If no move found, try a random move\n            const moves = [];\n            for (let fromRow = 0; fromRow < 8; fromRow++) {\n              for (let fromCol = 0; fromCol < 8; fromCol++) {\n                const piece = board[fromRow][fromCol];\n                if (piece && piece.color === 'black') {\n                  for (let toRow = 0; toRow < 8; toRow++) {\n                    for (let toCol = 0; toCol < 8; toCol++) {\n                      if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n                        // Check for pawn promotion\n                        if (piece.type === 'pawn' && toRow === 7) {\n                          moves.push({ fromRow, fromCol, toRow, toCol, promotionPiece: 'queen' });\n                        } else {\n                          moves.push({ fromRow, fromCol, toRow, toCol });\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            \n            if (moves.length > 0) {\n              const randomMove = moves[Math.floor(Math.random() * moves.length)];\n              const { fromRow, fromCol, toRow, toCol, promotionPiece } = randomMove;\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol, promotionPiece);\n            }\n          }\n        } catch (error) {\n          console.error(\"Error in AI move calculation:\", error);\n        } finally {\n          // Always set aiThinking to false when done, even if there was an error\n          setAiThinking(false);\n        }\n      });\n    }\n  }, [board, playerTurn, gameStatus, gameState, aiDifficulty, aiThinking]);\n\n  // AI makes a move when it's black's turn - with debounce protection\n  useEffect(() => {\n    let timeoutId = null;\n    \n    if (playerTurn === 'black' && gameStatus === 'ongoing' && !aiThinking) {\n      // Use a timeout to debounce multiple calls\n      timeoutId = setTimeout(() => {\n        makeAIMove();\n      }, 500);\n    }\n    \n    // Cleanup function to clear the timeout if component updates before timeout completes\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }, [playerTurn, gameStatus, makeAIMove, aiThinking]);\n\n  // Check for check, checkmate, or stalemate after each move\n  useEffect(() => {\n    if (moveHistory.length > 0) {\n      // Check if any king is in check\n      const whiteInCheck = isInCheck(board, 'white', gameState);\n      const blackInCheck = isInCheck(board, 'black', gameState);\n      \n      if (whiteInCheck) {\n        setCheckIndicator('white');\n        \n        // Check if it's checkmate\n        if (isCheckmate(board, 'white', gameState)) {\n          setGameStatus('Checkmate! Black wins.');\n        }\n      } else if (blackInCheck) {\n        setCheckIndicator('black');\n        \n        // Check if it's checkmate\n        if (isCheckmate(board, 'black', gameState)) {\n          setGameStatus('Checkmate! White wins.');\n        }\n      } else {\n        setCheckIndicator(null);\n      }\n      \n      // Check for stalemate\n      if (playerTurn === 'white' && isStalemate(board, 'white', gameState)) {\n        setGameStatus('Draw by stalemate');\n      } else if (playerTurn === 'black' && isStalemate(board, 'black', gameState)) {\n        setGameStatus('Draw by stalemate');\n      }\n    }\n  }, [board, playerTurn, moveHistory, gameState]);\n\n  // Calculate valid moves for the selected piece - memoized\n  const validMoves = useMemo(() => {\n    if (!selectedPiece) return [];\n    \n    const moves = [];\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n          moves.push({ row, col });\n        }\n      }\n    }\n    return moves;\n  }, [selectedPiece, board, gameState]);\n\n  // Update highlighted squares when valid moves change\n  useEffect(() => {\n    setHighlightedSquares(validMoves);\n  }, [validMoves]);\n\n  // eslint-disable-next-line no-unused-vars\n  const getPieceSymbol = useCallback((pieceType) => {\n    switch (pieceType) {\n      case 'pawn': return '';\n      case 'knight': return 'N';\n      case 'bishop': return 'B';\n      case 'rook': return 'R';\n      case 'queen': return 'Q';\n      case 'king': return 'K';\n      default: return '';\n    }\n  }, []);\n\n  const handleSquareClick = useCallback((row, col) => {\n    // If game is over or promotion dialog is open, don't allow any moves\n    if (gameStatus !== 'ongoing' || promotionDialog) return;\n    \n    // If it's not the player's turn, don't allow any moves\n    if (playerTurn !== 'white') return;\n    \n    const piece = board[row][col];\n    \n    // If a piece is already selected\n    if (selectedPiece) {\n      // If clicking on the same piece, deselect it\n      if (selectedPiece.row === row && selectedPiece.col === col) {\n        setSelectedPiece(null);\n        return;\n      }\n      \n      // If clicking on a different piece of the same color, select that piece instead\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n        return;\n      }\n      \n      // Try to make a move\n      if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n        // Check if this is a pawn promotion\n        if (isPawnPromotion(selectedPiece.piece, row)) {\n          // Show promotion dialog\n          const boardRect = document.querySelector('.chess-board').getBoundingClientRect();\n          const squareSize = boardRect.width / 8;\n          \n          setPromotionDialog({\n            fromRow: selectedPiece.row,\n            fromCol: selectedPiece.col,\n            toRow: row,\n            toCol: col,\n            position: {\n              x: boardRect.left + col * squareSize + squareSize / 2,\n              y: boardRect.top + row * squareSize + squareSize / 2\n            }\n          });\n          return;\n        }\n        \n        // Regular move\n        handleMove(selectedPiece.row, selectedPiece.col, row, col);\n      }\n    } else {\n      // If no piece is selected and clicked on a piece of the player's color, select it\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n      }\n    }\n  }, [board, gameState, gameStatus, handleMove, playerTurn, promotionDialog, selectedPiece]);\n\n  const handlePromotion = useCallback((pieceType) => {\n    if (!promotionDialog) return;\n    \n    const { fromRow, fromCol, toRow, toCol } = promotionDialog;\n    \n    // Make the move with promotion\n    handleMove(fromRow, fromCol, toRow, toCol, pieceType);\n    setPromotionDialog(null);\n  }, [handleMove, promotionDialog]);\n\n  const resetGame = useCallback(() => {\n    setBoard(initializeBoard());\n    setSelectedPiece(null);\n    setPlayerTurn('white');\n    setGameStatus('ongoing');\n    setMoveHistory([]);\n    setGameState({\n      enPassantTarget: null,\n      castlingRights: {\n        white: { kingSide: true, queenSide: true },\n        black: { kingSide: true, queenSide: true }\n      }\n    });\n    setHighlightedSquares([]);\n    setCheckIndicator(null);\n    setShowHint(false);\n    setHintMove(null);\n    setPromotionDialog(null);\n  }, []);\n\n  const handleDifficultyChange = useCallback((difficulty) => {\n    setAiDifficulty(difficulty);\n    resetGame();\n  }, [resetGame]);\n\n  const getHint = useCallback(() => {\n    // Use the AI to suggest a move for the player\n    if (playerTurn === 'white' && gameStatus === 'ongoing') {\n      const suggestedMove = getAIMove(board, 'white', gameState, 2);\n      if (suggestedMove) {\n        setShowHint(true);\n        setHintMove(suggestedMove);\n      }\n    }\n  }, [board, gameState, gameStatus, playerTurn]);\n\n  // Handle theme change\n  const handleThemeChange = useCallback((themeKey) => {\n    setCurrentTheme(themeKey);\n    // Save theme preference to localStorage\n    localStorage.setItem('chessTheme', themeKey);\n  }, []);\n\n  // Load saved theme from localStorage on initial render\n  useEffect(() => {\n    const savedTheme = localStorage.getItem('chessTheme');\n    if (savedTheme && themes[savedTheme]) {\n      setCurrentTheme(savedTheme);\n    }\n  }, []);\n\n  // Memoize the last move for better performance\n  const lastMove = useMemo(() => {\n    return moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;\n  }, [moveHistory]);\n\n  // Memoize the current theme object\n  const currentThemeObject = useMemo(() => themes[currentTheme], [currentTheme]);\n\n  return (\n    <div className=\"app\">\n      <div className=\"app-header\">\n        <h1>AI Chess</h1>\n        <div className=\"author-credits\">\n          <span>Created by Aditya Thakkar</span>\n        </div>\n        <ThemeSelector \n          currentTheme={currentTheme} \n          onThemeChange={handleThemeChange} \n        />\n      </div>\n      <div className=\"difficulty-selector\">\n        <span className=\"difficulty-label\">AI Difficulty:</span>\n        <div className=\"difficulty-buttons\">\n          <button \n            className={`difficulty-button ${aiDifficulty === 'easy' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('easy')}\n          >\n            Easy\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'medium' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('medium')}\n          >\n            Medium\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'hard' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('hard')}\n          >\n            Hard\n          </button>\n        </div>\n      </div>\n      <div className=\"game-container\">\n        <ChessBoard \n          board={board} \n          selectedPiece={selectedPiece} \n          onSquareClick={handleSquareClick}\n          highlightedSquares={highlightedSquares}\n          checkIndicator={checkIndicator}\n          lastMove={lastMove}\n          hintMove={showHint ? hintMove : null}\n          theme={currentThemeObject}\n        />\n        <GameInfo \n          playerTurn={playerTurn} \n          gameStatus={gameStatus} \n          moveHistory={moveHistory} \n          onResetGame={resetGame}\n          isInCheck={checkIndicator}\n          aiDifficulty={aiDifficulty}\n          onGetHint={getHint}\n          aiThinking={aiThinking}\n          onDifficultyChange={handleDifficultyChange}\n        />\n      </div>\n      {promotionDialog && (\n        <PromotionDialog \n          position={promotionDialog.position}\n          color=\"white\"\n          onSelect={handlePromotion}\n          onCancel={() => setPromotionDialog(null)}\n          theme={currentThemeObject}\n        />\n      )}\n      <div className=\"app-footer\">\n        <div className=\"footer-content\">\n          <p>Chess AI with Minimax Algorithm & Alpha-Beta Pruning</p>\n          <p> {new Date().getFullYear()} AI Chess by Aditya Thakkar</p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App; \n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n); "],"sourceRoot":""}