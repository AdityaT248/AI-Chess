{"version":3,"sources":["assets/pieces/white-pawn.svg","assets/pieces/white-rook.svg","assets/pieces/white-knight.svg","assets/pieces/white-bishop.svg","assets/pieces/white-queen.svg","assets/pieces/white-king.svg","assets/pieces/black-pawn.svg","assets/pieces/black-rook.svg","assets/pieces/black-knight.svg","assets/pieces/black-bishop.svg","assets/pieces/black-queen.svg","assets/pieces/black-king.svg","components/ChessBoard.js","components/GameInfo.js","components/PromotionDialog.js","themes.js","components/ThemeSelector.js","utils/chessLogic.js","utils/aiPlayer.js","App.js","index.js"],"names":["pieceImages","whitePawn","whiteRook","whiteKnight","whiteBishop","whiteQueen","whiteKing","blackPawn","blackRook","blackKnight","blackBishop","blackQueen","blackKing","Square","memo","_ref","row","col","piece","isLight","isSelected","isHighlighted","isCheck","isLastMove","isHint","squareColor","onClick","squareClassName","squareStyle","backgroundColor","_jsx","className","style","children","captured","src","color","type","alt","Coordinates","_jsxs","map","file","rank","CapturedPieces","_ref2","capturedPieces","capturedByOpponent","black","white","length","index","ChessBoard","_ref3","board","selectedPiece","onSquareClick","highlightedSquares","checkIndicator","lastMove","hintMove","theme","useMemo","flat","forEach","push","highlightedSquaresMap","square","lastMoveMap","from","to","hintSquareMap","fromRow","fromCol","toRow","toCol","boardRows","squares","isHintSquare","lightSquare","darkSquare","containerStyle","background","boardBg","highlightColor","checkColor","lastMoveColor","accentColor","GameInfo","playerTurn","gameStatus","moveHistory","onResetGame","isInCheck","aiDifficulty","onGetHint","aiThinking","activeTab","setActiveTab","useState","groupedMoves","i","number","Math","floor","materialAdvantage","calculateMaterialAdvantage","pieceValues","whiteCaptured","blackCaptured","move","capturedPiece","advantage","value","abs","renderGameStatus","statusText","includes","disabled","notation","renderAnalysis","searchDepth","PromotionDialog","position","onSelect","onCancel","top","y","left","x","e","stopPropagation","themes","classic","name","blue","dark","green","coral","ThemeSelector","currentTheme","onThemeChange","Object","keys","themeKey","title","initializeBoard","Array","fill","hasMoved","cloneBoard","JSON","parse","stringify","isSquareUnderAttack","attackerColor","pawnDirection","knightMoves","rowOffset","colOffset","newRow","newCol","directions","rowDir","colDir","kingPos","findKing","opponentColor","isValidMove","gameState","targetPiece","isValid","isValidPawnMove","isValidKnightMove","isValidBishopMove","isValidRookMove","isValidQueenMove","isValidKingMove","tempBoard","direction","enPassantTarget","start","min","end","max","rowDiff","colDiff","rowDirection","colDirection","rook","isPawnPromotion","makeMove","promotionPiece","arguments","undefined","newBoard","newGameState","castlingRights","kingSide","queenSide","captureRow","isCheckmate","isStalemate","positionBonus","evaluationCache","Map","knightOffsets","bishop","queen","generatePieceMoves","moves","isCapture","isEnPassant","dirs","isCastling","castlingSide","findBestMove","difficulty","generateMoves","candidateMoves","pieceMoves","randomChance","random","boardHash","hash","getBoardHash","cacheKey","has","get","MAX_MOVES_TO_EVALUATE","sort","slice","evaluatedMoves","score","evaluateMove","currentPositionValue","error","console","a","b","topMovesCount","topMoves","bestMove","set","size","clear","allMoves","fallbackError","getAIMove","startTime","Date","now","MAX_EXECUTION_TIME","effectiveDifficulty","filter","Boolean","warn","App","setBoard","setSelectedPiece","setPlayerTurn","setGameStatus","setMoveHistory","setGameState","setHighlightedSquares","setCheckIndicator","setAiDifficulty","showHint","setShowHint","setHintMove","promotionDialog","setPromotionDialog","setCurrentTheme","setAiThinking","handleMoveRef","useRef","generateMoveNotation","useCallback","files","charAt","toUpperCase","handleMove","newMove","prevHistory","prevTurn","useEffect","current","makeAIMove","setTimeout","aiMove","randomMove","timeoutId","clearTimeout","whiteInCheck","blackInCheck","validMoves","pieceType","handleSquareClick","boardRect","document","querySelector","getBoundingClientRect","squareSize","width","handlePromotion","resetGame","handleDifficultyChange","getHint","suggestedMove","handleThemeChange","localStorage","setItem","savedTheme","getItem","currentThemeObject","getFullYear","ReactDOM","render","React","StrictMode","getElementById"],"mappings":"wQAAe,G,gBAAA,IAA0B,wCCA1B,MAA0B,uCCA1B,MAA0B,yCCA1B,MAA0B,yCCA1B,MAA0B,wCCA1B,MAA0B,uCCA1B,MAA0B,uCCA1B,MAA0B,uCCA1B,MAA0B,yCCA1B,MAA0B,yCCA1B,MAA0B,wCCA1B,MAA0B,uC,OCkBzC,MAAMA,EAAc,CAClB,MAAS,CACP,KAAQC,EACR,KAAQC,EACR,OAAUC,EACV,OAAUC,EACV,MAASC,EACT,KAAQC,GAEV,MAAS,CACP,KAAQC,EACR,KAAQC,EACR,OAAUC,EACV,OAAUC,EACV,MAASC,EACT,KAAQC,IAKNC,EAASC,gBAAKC,IAYb,IAZc,IACnBC,EAAG,IACHC,EAAG,MACHC,EAAK,QACLC,EAAO,WACPC,EAAU,cACVC,EAAa,QACbC,EAAO,WACPC,EAAU,OACVC,EAAM,YACNC,EAAW,QACXC,GACDX,EACKY,EAAkB,WAAUR,EAAU,QAAU,QAChDC,IAAYO,GAAmB,aAC/BN,IAAeM,GAAmB,gBAClCL,IAASK,GAAmB,UAC5BJ,IAAYI,GAAmB,cAC/BH,IAAQG,GAAmB,SAE/B,MAAMC,EAAc,CAClBC,gBAAiBJ,GAGnB,OACEK,cAAA,OACEC,UAAWJ,EACXK,MAAOJ,EACPF,QAASA,EAAQO,SAEhBf,IAAUA,EAAMgB,UACfJ,cAAA,OACEK,IAAKnC,EAAYkB,EAAMkB,OAAOlB,EAAMmB,MACpCC,IAAK,GAAGpB,EAAMkB,SAASlB,EAAMmB,OAC7BN,UAAW,SAASb,EAAMkB,WAG1B,IAKJG,EAAczB,gBAAK,IAKrB0B,eAAA,OAAKT,UAAU,oBAAmBE,SAAA,CAChCH,cAAA,OAAKC,UAAU,QAAOE,SALZ,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAMrCQ,KAAIC,GACTZ,cAAA,OAAAG,SAAiBS,GAAPA,OAGdZ,cAAA,OAAKC,UAAU,QAAOE,SATZ,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAUrCQ,KAAIE,GACTb,cAAA,OAAAG,SAAiBU,GAAPA,YAQdC,EAAiB9B,gBAAK+B,IAAgC,IAA/B,eAAEC,EAAc,MAAEV,GAAOS,EACpD,MAAME,EAA+B,UAAVX,EAAoBU,EAAeE,MAAQF,EAAeG,MAErF,OAAkC,IAA9BF,EAAmBG,OAAqB,KAG1CpB,cAAA,OAAKC,UAAU,eAAcE,SAC1Bc,EAAmBN,KAAI,CAACvB,EAAOiC,IAC9BrB,cAAA,OAEEK,IAAKnC,EAAYkB,EAAMkB,OAAOlB,EAAMmB,MACpCC,IAAK,GAAGpB,EAAMkB,SAASlB,EAAMmB,OAC7BN,UAAU,kBAHLoB,MAML,IAIJC,EAAaC,IASZ,IATa,MAClBC,EAAK,cACLC,EAAa,cACbC,EAAa,mBACbC,EAAkB,eAClBC,EAAc,SACdC,EAAQ,SACRC,EAAQ,MACRC,GACDR,EAEC,MAAMP,EAAiBgB,mBAAQ,KAC7B,MAAM5B,EAAW,CACfe,MAAO,GACPD,MAAO,IAST,OANAM,EAAMS,OAAOC,SAAQ9C,IACfA,GAASA,EAAMgB,UACjBA,EAAShB,EAAMkB,OAAO6B,KAAK/C,EAC7B,IAGKgB,CAAQ,GACd,CAACoB,IAGEY,EAAwBJ,mBAAQ,KACpC,MAAMrB,EAAM,CAAC,EAIb,OAHAgB,EAAmBO,SAAQG,IACzB1B,EAAI,GAAG0B,EAAOnD,OAAOmD,EAAOlD,QAAS,CAAI,IAEpCwB,CAAG,GACT,CAACgB,IAGEW,EAAcN,mBAAQ,KAC1B,IAAKH,EAAU,MAAO,CAAC,EAEvB,MAAM,KAAEU,EAAI,GAAEC,GAAOX,EACrB,MAAO,CACL,CAAC,GAAGU,EAAKrD,OAAOqD,EAAKpD,QAAQ,EAC7B,CAAC,GAAGqD,EAAGtD,OAAOsD,EAAGrD,QAAQ,EAC1B,GACA,CAAC0C,IAGEY,EAAgBT,mBAAQ,KAC5B,IAAKF,EAAU,MAAO,CAAC,EAEvB,MAAM,QAAEY,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUf,EAC3C,MAAO,CACL,CAAC,GAAGY,KAAWC,MAAY,EAC3B,CAAC,GAAGC,KAASC,MAAU,EACxB,GACA,CAACf,IAGEgB,EAAYd,mBAAQ,KACxB,MAAMe,EAAU,GAGVxD,EAAgBA,CAACL,EAAKC,MACjBiD,EAAsB,GAAGlD,KAAOC,KAGrCM,EAAaA,CAACP,EAAKC,MACdmD,EAAY,GAAGpD,KAAOC,KAG3B6D,EAAeA,CAAC9D,EAAKC,MAChBsD,EAAc,GAAGvD,KAAOC,KAGnC,IAAK,IAAID,EAAM,EAAGA,EAAM,EAAGA,IACzB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAQoC,EAAMtC,GAAKC,GACnBE,GAAWH,EAAMC,GAAO,IAAM,EAC9BG,EAAamC,GAAiBA,EAAcvC,MAAQA,GAAOuC,EAActC,MAAQA,EACjFK,EAAUoC,GAAkBxC,GAAwB,SAAfA,EAAMmB,MAAmBnB,EAAMkB,QAAUsB,EAG9EjC,EAAcN,EAAU0C,EAAMkB,YAAclB,EAAMmB,WAExDH,EAAQZ,KACNnC,cAACjB,EAAM,CAELG,IAAKA,EACLC,IAAKA,EACLC,MAAOA,EACPC,QAASA,EACTC,WAAYA,EACZC,cAAeA,EAAcL,EAAKC,GAClCK,QAASA,EACTC,WAAYA,EAAWP,EAAKC,GAC5BO,OAAQsD,EAAa9D,EAAKC,GAC1BQ,YAAaA,EACbC,QAASA,IAAM8B,EAAcxC,EAAKC,IAX7B,GAAGD,KAAOC,KAcrB,CAGF,OAAO4D,CAAO,GACb,CAACvB,EAAOC,EAAeG,EAAgBG,EAAOL,EAAeU,EAAuBE,EAAaG,IAG9FU,EAAiBnB,mBAAQ,MAC7BoB,WAAYrB,EAAMsB,QAClB,oBAAqBtB,EAAMuB,eAC3B,gBAAiBvB,EAAMwB,WACvB,oBAAqBxB,EAAMyB,cAC3B,iBAAkBzB,EAAM0B,eACtB,CAAC1B,IAEL,OACErB,eAAA,OAAKT,UAAU,wBAAwBC,MAAOiD,EAAehD,SAAA,CAC3DH,cAAA,OAAKC,UAAU,cAAaE,SACzB2C,IAEH9C,cAACS,EAAW,IACZC,eAAA,OAAKT,UAAU,kBAAiBE,SAAA,CAC9BH,cAACc,EAAc,CAACE,eAAgBA,EAAgBV,MAAM,UACtDN,cAACc,EAAc,CAACE,eAAgBA,EAAgBV,MAAM,eAEpD,EAIKtB,qBAAKsC,G,MCrCLoC,MAjNEzE,IASV,IATW,WAChB0E,EAAU,WACVC,EAAU,YACVC,EAAW,YACXC,EAAW,UACXC,EAAS,aACTC,EAAY,UACZC,EAAS,WACTC,GACDjF,EACC,MAAOkF,EAAWC,GAAgBC,mBAAS,SAGrCC,EAAe,GACrB,IAAK,IAAIC,EAAI,EAAGA,EAAIV,EAAYzC,OAAQmD,GAAK,EAC3CD,EAAanC,KAAK,CAChBqC,OAAQC,KAAKC,MAAMH,EAAI,GAAK,EAC5BpD,MAAO0C,EAAYU,GACnBrD,MAAO2C,EAAYU,EAAI,KAK3B,MAkCMI,EAlC6BC,MACjC,MAAMC,EAAc,CAClB,KAAQ,EACR,OAAU,EACV,OAAU,EACV,KAAQ,EACR,MAAS,EACT,KAAQ,GAGV,IAAIC,EAAgB,EAChBC,EAAgB,EAEpBlB,EAAY3B,SAAQ8C,IACdA,EAAKC,gBAC0B,UAA7BD,EAAKC,cAAc3E,MACrByE,GAAiBF,EAAYG,EAAKC,cAAc1E,MAEhDuE,GAAiBD,EAAYG,EAAKC,cAAc1E,MAEpD,IAGF,MAAM2E,EAAYJ,EAAgBC,EAElC,OAAIG,EAAY,EACP,CAAE5E,MAAO,QAAS6E,MAAOD,GACvBA,EAAY,EACd,CAAE5E,MAAO,QAAS6E,MAAOV,KAAKW,IAAIF,IAElC,CAAE5E,MAAO,QAAS6E,MAAO,EAClC,EAGwBP,GA6H1B,OACElE,eAAA,OAAKT,UAAU,YAAWE,SAAA,CACxBH,cAAA,MAAAG,SAAI,gBA5HiBkF,MACvB,IAAIC,EAAa,GAYjB,OATEA,EADiB,YAAf1B,GAC6B,UAAfD,EAAyB,QAAU,SAAtC,UACJC,EAAW2B,SAAS,aAChB3B,EACJA,EAAW2B,SAAS,aAChB,oBAEA3B,EAIblD,eAAA,OAAKT,UAAU,mBAAkBE,SAAA,CAC/BO,eAAA,OAAKT,UAAU,SAAQE,SAAA,CACpBmF,EACApB,GAA6B,UAAfP,GACbjD,eAAA,OAAKT,UAAU,cAAaE,SAAA,CAC1BH,cAAA,QAAAG,SAAM,mBACNO,eAAA,OAAKT,UAAU,gBAAeE,SAAA,CAC5BH,cAAA,QAAMC,UAAU,QAChBD,cAAA,QAAMC,UAAU,QAChBD,cAAA,QAAMC,UAAU,iBAKxBS,eAAA,OAAKT,UAAU,oBAAmBE,SAAA,CAChCO,eAAA,OAAKT,UAAW,qBAAmC,UAAf0D,EAAyB,SAAW,IAAKxD,SAAA,CAC3EH,cAAA,QAAMC,UAAU,QAAOE,SAAC,UACvB4D,GAA4B,UAAfJ,GAA0B3D,cAAA,QAAMC,UAAU,kBAAiBE,SAAC,cAE5EO,eAAA,OAAKT,UAAW,qBAAmC,UAAf0D,EAAyB,SAAW,IAAKxD,SAAA,CAC3EH,cAAA,QAAMC,UAAU,QAAOE,SAAC,UACvB4D,GAA4B,UAAfJ,GAA0B3D,cAAA,QAAMC,UAAU,kBAAiBE,SAAC,iBAG7E4D,GAA4B,YAAfH,GACZlD,eAAA,OAAKT,UAAU,eAAcE,SAAA,CACZ,UAAd4D,EAAwB,QAAU,QAAQ,mBAG/B,YAAfH,GACC5D,cAAA,OAAKC,UAAU,YAAWE,SACvByD,IAGLlD,eAAA,OAAKT,UAAU,mBAAkBE,SAAA,CAC/BH,cAAA,UAAQC,UAAU,eAAeL,QAASkE,EAAY3D,SAAC,aAGvDH,cAAA,UACEC,UAAU,cACVL,QAASqE,EACTuB,SAAyB,YAAf5B,GAA2C,UAAfD,GAA0BO,EAAW/D,SAC5E,cAIC,EAiELkF,GAED3E,eAAA,OAAKT,UAAU,OAAME,SAAA,CACnBH,cAAA,OACEC,UAAW,QAAqB,UAAdkE,EAAwB,SAAW,IACrDvE,QAASA,IAAMwE,EAAa,SAASjE,SACtC,UAGDH,cAAA,OACEC,UAAW,QAAqB,aAAdkE,EAA2B,SAAW,IACxDvE,QAASA,IAAMwE,EAAa,YAAYjE,SACzC,gBAKHH,cAAA,OAAKC,UAAU,cAAaE,SACX,UAAdgE,EA7EsB,IAAvBN,EAAYzC,OACPpB,cAAA,OAAKC,UAAU,WAAUE,SAAC,iBAIjCH,cAAA,OAAKC,UAAU,kBAAiBE,SAC9BO,eAAA,SAAOT,UAAU,cAAaE,SAAA,CAC5BH,cAAA,SAAAG,SACEO,eAAA,MAAAP,SAAA,CACEH,cAAA,MAAAG,SAAI,MACJH,cAAA,MAAAG,SAAI,UACJH,cAAA,MAAAG,SAAI,eAGRH,cAAA,SAAAG,SACGmE,EAAa3D,KAAIqE,GAChBtE,eAAA,MAAAP,SAAA,CACEH,cAAA,MAAIC,UAAU,cAAaE,SAAE6E,EAAKR,SAClCxE,cAAA,MAAIC,UAAU,aAAYE,SAAE6E,EAAK7D,MAAQ6D,EAAK7D,MAAMsE,SAAW,KAC/DzF,cAAA,MAAIC,UAAU,aAAYE,SAAE6E,EAAK9D,MAAQ8D,EAAK9D,MAAMuE,SAAW,OAHxDT,EAAKR,iBAaHkB,MACrB,MAAMC,EAAc,CAClB,KAAQ,EACR,OAAU,EACV,KAAQ,GACR3B,GAEF,OACEtD,eAAA,OAAKT,UAAU,qBAAoBE,SAAA,CACjCO,eAAA,OAAKT,UAAU,gBAAeE,SAAA,CAC5BH,cAAA,QAAMC,UAAU,iBAAgBE,SAAC,gBACjCH,cAAA,QAAMC,UAAU,iBAAgBE,SAAE0D,EAAYzC,YAEhDV,eAAA,OAAKT,UAAU,gBAAeE,SAAA,CAC5BH,cAAA,QAAMC,UAAU,iBAAgBE,SAAC,uBACjCH,cAAA,QAAMC,UAAW,qCAAqC0E,EAAkBrE,QAAQH,SACjD,UAA5BwE,EAAkBrE,MAAoB,QAAU,IAAIqE,EAAkBQ,aAAaR,EAAkBrE,aAG1GI,eAAA,OAAKT,UAAU,gBAAeE,SAAA,CAC5BH,cAAA,QAAMC,UAAU,iBAAgBE,SAAC,sBACjCO,eAAA,QAAMT,UAAU,iBAAgBE,SAAA,CAAEwF,EAAY,IAAkB,IAAhBA,EAAoB,OAAS,gBAE3E,EAyB2CD,OAE7C,E,MCjJKE,MAlDS3G,IAA8C,IAA7C,SAAE4G,EAAQ,MAAEvF,EAAK,SAAEwF,EAAQ,SAAEC,GAAU9G,EAC9D,MAAMf,EAAc,CAClB,MAAS,CACP,MAASK,EACT,KAAQH,EACR,OAAUE,EACV,OAAUD,GAEZ,MAAS,CACP,MAASQ,EACT,KAAQH,EACR,OAAUE,EACV,OAAUD,IAMd,OACEqB,cAAA,OAAKC,UAAU,4BAA4BL,QAASmG,EAAS5F,SAC3DO,eAAA,OACET,UAAU,mBACVC,MAAO,CACL8F,IAAKH,EAASI,EACdC,KAAML,EAASM,GAEjBvG,QAAUwG,GAAMA,EAAEC,kBAAkBlG,SAAA,CAEpCH,cAAA,OAAKC,UAAU,kBAAiBE,SAAC,gBACjCH,cAAA,OAAKC,UAAU,oBAAmBE,SAbzB,CAAC,QAAS,OAAQ,SAAU,UAc3BQ,KAAIvB,GACVsB,eAAA,OAEET,UAAU,kBACVL,QAASA,IAAMkG,EAAS1G,GAAOe,SAAA,CAE/BH,cAAA,OACEK,IAAKnC,EAAYoC,GAAOlB,GACxBoB,IAAK,GAAGF,KAASlB,IACjBa,UAAU,0BAEZD,cAAA,OAAKC,UAAU,uBAAsBE,SAAEf,MATlCA,WAcT,E,MCIKkH,MA9DA,CAEbC,QAAS,CACPC,KAAM,UACNvD,YAAa,UACbC,WAAY,UACZI,eAAgB,0BAChBC,WAAY,2BACZC,cAAe,2BACfH,QAAS,wEACTI,YAAa,WAIfgD,KAAM,CACJD,KAAM,aACNvD,YAAa,UACbC,WAAY,UACZI,eAAgB,0BAChBC,WAAY,yBACZC,cAAe,yBACfH,QAAS,2EACTI,YAAa,WAIfiD,KAAM,CACJF,KAAM,WACNvD,YAAa,UACbC,WAAY,UACZI,eAAgB,2BAChBC,WAAY,yBACZC,cAAe,0BACfH,QAAS,wEACTI,YAAa,WAIfkD,MAAO,CACLH,KAAM,SACNvD,YAAa,UACbC,WAAY,UACZI,eAAgB,0BAChBC,WAAY,yBACZC,cAAe,0BACfH,QAAS,yEACTI,YAAa,WAIfmD,MAAO,CACLJ,KAAM,QACNvD,YAAa,UACbC,WAAY,UACZI,eAAgB,2BAChBC,WAAY,yBACZC,cAAe,0BACfH,QAAS,2EACTI,YAAa,YCzBFoD,MA9BO5H,IAAsC,IAArC,aAAE6H,EAAY,cAAEC,GAAe9H,EACpD,OACEyB,eAAA,OAAKT,UAAU,iBAAgBE,SAAA,CAC7BH,cAAA,OAAKC,UAAU,uBAAsBE,SAAC,iBACtCH,cAAA,OAAKC,UAAU,gBAAeE,SAC3B6G,OAAOC,KAAKX,GAAQ3F,KAAIuG,GACvBxG,eAAA,OAEET,UAAW,iBAAgB6G,IAAiBI,EAAW,SAAW,IAClEtH,QAASA,IAAMmH,EAAcG,GAC7BC,MAAOb,EAAOY,GAAUV,KAAKrG,SAAA,CAE7BH,cAAA,OACEC,UAAU,gBACVC,MAAO,CACLkD,WAAY,+CACRkD,EAAOY,GAAUjE,uCACjBqD,EAAOY,GAAUjE,wCACjBqD,EAAOY,GAAUhE,uCACjBoD,EAAOY,GAAUhE,sBAGzBlD,cAAA,QAAMC,UAAU,aAAYE,SAAEmG,EAAOY,GAAUV,SAf1CU,SAmBP,EC7BV,MAUaE,EAAkBA,KAC7B,MAAM5F,EAAQ6F,MAAM,GAAGC,OAAO3G,KAAI,IAAM0G,MAAM,GAAGC,KAAK,QAGtD,IAAK,IAAInI,EAAM,EAAGA,EAAM,EAAGA,IACzBqC,EAAM,GAAGrC,GAAO,CAAEoB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAGrC,GAAO,CAAEoB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GA6B5D,OAzBA/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GACxD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GACxD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GACxD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GAGxD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAG1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAC1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,SAAUD,MAAO,QAASiH,UAAU,GAG1D/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,QAASD,MAAO,QAASiH,UAAU,GACzD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,QAASD,MAAO,QAASiH,UAAU,GAGzD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GACxD/F,EAAM,GAAG,GAAK,CAAEjB,KAAM,OAAQD,MAAO,QAASiH,UAAU,GAEjD/F,CAAK,EAIDgG,EAAchG,GAClBiG,KAAKC,MAAMD,KAAKE,UAAUnG,IAiBtBoG,EAAsBA,CAACpG,EAAOtC,EAAKC,EAAK0I,KAEnD,MAAMC,EAAkC,UAAlBD,GAA6B,EAAI,EACvD,GAAI3I,EAAM4I,GAAiB,GAAK5I,EAAM4I,EAAgB,EAAG,CACvD,GAAI3I,EAAM,GAAK,EAAG,CAChB,MAAMC,EAAQoC,EAAMtC,EAAM4I,GAAe3I,EAAM,GAC/C,GAAIC,GAAwB,SAAfA,EAAMmB,MAAmBnB,EAAMkB,QAAUuH,EACpD,OAAO,CAEX,CACA,GAAI1I,EAAM,EAAI,EAAG,CACf,MAAMC,EAAQoC,EAAMtC,EAAM4I,GAAe3I,EAAM,GAC/C,GAAIC,GAAwB,SAAfA,EAAMmB,MAAmBnB,EAAMkB,QAAUuH,EACpD,OAAO,CAEX,CACF,CAGA,MAAME,EAAc,CAClB,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,EAAE,GAAI,GAAI,EAAE,EAAG,GAClC,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,IAGhC,IAAK,MAAOC,EAAWC,KAAcF,EAAa,CAChD,MAAMG,EAAShJ,EAAM8I,EACfG,EAAShJ,EAAM8I,EAErB,GAAIC,GAAU,GAAKA,EAAS,GAAKC,GAAU,GAAKA,EAAS,EAAG,CAC1D,MAAM/I,EAAQoC,EAAM0G,GAAQC,GAC5B,GAAI/I,GAAwB,WAAfA,EAAMmB,MAAqBnB,EAAMkB,QAAUuH,EACtD,OAAO,CAEX,CACF,CAGA,MAAMO,EAAa,CACjB,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,GACjC,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAG/B,IAAK,MAAOC,EAAQC,KAAWF,EAAY,CACzC,IAAIF,EAAShJ,EAAMmJ,EACfF,EAAShJ,EAAMmJ,EAEnB,KAAOJ,GAAU,GAAKA,EAAS,GAAKC,GAAU,GAAKA,EAAS,GAAG,CAC7D,MAAM/I,EAAQoC,EAAM0G,GAAQC,GAE5B,GAAI/I,EAAO,CACT,GAAIA,EAAMkB,QAAUuH,EAAe,CACjC,GAAmB,UAAfzI,EAAMmB,MACU,WAAfnB,EAAMmB,MAAqBkE,KAAKW,IAAIiD,KAAY5D,KAAKW,IAAIkD,IAC1C,SAAflJ,EAAMmB,OAA+B,IAAX8H,GAA2B,IAAXC,GAC7C,OAAO,EAIT,GAAmB,SAAflJ,EAAMmB,MACNkE,KAAKW,IAAI8C,EAAShJ,IAAQ,GAC1BuF,KAAKW,IAAI+C,EAAShJ,IAAQ,EAC5B,OAAO,CAEX,CACA,KACF,CAEA+I,GAAUG,EACVF,GAAUG,CACZ,CACF,CAEA,OAAO,CAAK,EAIDvE,EAAYA,CAACvC,EAAOlB,KAC/B,MAAMiI,EA1FgBC,EAAChH,EAAOlB,KAC9B,IAAK,IAAIpB,EAAM,EAAGA,EAAM,EAAGA,IACzB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAQoC,EAAMtC,GAAKC,GACzB,GAAIC,GAAwB,SAAfA,EAAMmB,MAAmBnB,EAAMkB,QAAUA,EACpD,MAAO,CAAEpB,MAAKC,MAElB,CAEF,OAAO,IAAI,EAiFKqJ,CAAShH,EAAOlB,GAChC,IAAKiI,EAAS,OAAO,EAErB,MAAME,EAA0B,UAAVnI,EAAoB,QAAU,QACpD,OAAOsH,EAAoBpG,EAAO+G,EAAQrJ,IAAKqJ,EAAQpJ,IAAKsJ,EAAc,EAgB/DC,EAAcA,CAAClH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,KAEjE,GAAIjG,EAAU,GAAKA,EAAU,GAAKC,EAAU,GAAKA,EAAU,GACvDC,EAAQ,GAAKA,EAAQ,GAAKC,EAAQ,GAAKA,EAAQ,EACjD,OAAO,EAIT,MAAMzD,EAAQoC,EAAMkB,GAASC,GAC7B,IAAKvD,EACH,OAAO,EAIT,MAAMwJ,EAAcpH,EAAMoB,GAAOC,GACjC,GAAI+F,GAAeA,EAAYtI,QAAUlB,EAAMkB,MAC7C,OAAO,EAIT,IAAIuI,GAAU,EAEd,OAAQzJ,EAAMmB,MACZ,IAAK,OACHsI,EAAUC,EAAgBtH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,GACjE,MACF,IAAK,SACHE,EAAUE,EAAkBrG,EAASC,EAASC,EAAOC,GACrD,MACF,IAAK,SACHgG,EAAUG,EAAkBxH,EAAOkB,EAASC,EAASC,EAAOC,GAC5D,MACF,IAAK,OACHgG,EAAUI,EAAgBzH,EAAOkB,EAASC,EAASC,EAAOC,GAC1D,MACF,IAAK,QACHgG,EAAUK,EAAiB1H,EAAOkB,EAASC,EAASC,EAAOC,GAC3D,MACF,IAAK,OACHgG,EAAUM,EAAgB3H,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,GACjE,MACF,QACEE,GAAU,EAId,GAAIA,EAAS,CAEX,MAAMO,EAAY5B,EAAWhG,GAC7B4H,EAAUxG,GAAOC,GAASuG,EAAU1G,GAASC,GAC7CyG,EAAU1G,GAASC,GAAW,KAM9B,GAHoBoB,EAAUqF,EAAWhK,EAAMkB,OAI7C,OAAO,CAEX,CAEA,OAAOuI,CAAO,EAIVC,EAAkBA,CAACtH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,KAC9D,MAAMvJ,EAAQoC,EAAMkB,GAASC,GACvB0G,EAA4B,UAAhBjK,EAAMkB,OAAqB,EAAI,EAGjD,GAAIqC,IAAYE,GAASD,IAAUF,EAAU2G,IAAc7H,EAAMoB,GAAOC,GACtE,OAAO,EAIT,GAAIF,IAAYE,IACM,UAAhBzD,EAAMkB,OAAiC,IAAZoC,GAAmC,UAAhBtD,EAAMkB,OAAiC,IAAZoC,IAC3EE,IAAUF,EAAU,EAAI2G,IACvB7H,EAAMkB,EAAU2G,GAAW1G,KAAanB,EAAMoB,GAAOC,GACxD,OAAO,EAIT,GAAkC,IAA9B4B,KAAKW,IAAIzC,EAAUE,IAAgBD,IAAUF,EAAU2G,EAAW,CAEpE,GAAI7H,EAAMoB,GAAOC,IAAUrB,EAAMoB,GAAOC,GAAOvC,QAAUlB,EAAMkB,MAC7D,OAAO,EAIT,IAAKkB,EAAMoB,GAAOC,IAAU8F,GAAaA,EAAUW,iBAC/C1G,IAAU+F,EAAUW,gBAAgBpK,KAAO2D,IAAU8F,EAAUW,gBAAgBnK,IACjF,OAAO,CAEX,CAEA,OAAO,CAAK,EAIR8J,EAAkBA,CAACzH,EAAOkB,EAASC,EAASC,EAAOC,KAEvD,GAAIH,IAAYE,GAASD,IAAYE,EAAO,OAAO,EAGnD,GAAIH,IAAYE,EAAO,CAErB,MAAM2G,EAAQ9E,KAAK+E,IAAI7G,EAASE,GAC1B4G,EAAMhF,KAAKiF,IAAI/G,EAASE,GAC9B,IAAK,IAAI1D,EAAMoK,EAAQ,EAAGpK,EAAMsK,EAAKtK,IACnC,GAAIqC,EAAMkB,GAASvD,GAAM,OAAO,CAEpC,KAAO,CAEL,MAAMoK,EAAQ9E,KAAK+E,IAAI9G,EAASE,GAC1B6G,EAAMhF,KAAKiF,IAAIhH,EAASE,GAC9B,IAAK,IAAI1D,EAAMqK,EAAQ,EAAGrK,EAAMuK,EAAKvK,IACnC,GAAIsC,EAAMtC,GAAKyD,GAAU,OAAO,CAEpC,CAEA,OAAO,CAAI,EAIPoG,EAAoBA,CAACrG,EAASC,EAASC,EAAOC,KAElD,MAAM8G,EAAUlF,KAAKW,IAAI1C,EAAUE,GAC7BgH,EAAUnF,KAAKW,IAAIzC,EAAUE,GAEnC,OAAoB,IAAZ8G,GAA6B,IAAZC,GAA+B,IAAZD,GAA6B,IAAZC,CAAc,EAIvEZ,EAAoBA,CAACxH,EAAOkB,EAASC,EAASC,EAAOC,KAEzD,MAAM8G,EAAUlF,KAAKW,IAAI1C,EAAUE,GAGnC,GAAI+G,IAFYlF,KAAKW,IAAIzC,EAAUE,GAEV,OAAO,EAGhC,MAAMgH,EAAenH,EAAUE,EAAQ,GAAK,EACtCkH,EAAenH,EAAUE,EAAQ,GAAK,EAE5C,IAAK,IAAI0B,EAAI,EAAGA,EAAIoF,EAASpF,IAC3B,GAAI/C,EAAMkB,EAAU6B,EAAIsF,GAAclH,EAAU4B,EAAIuF,GAAe,OAAO,EAG5E,OAAO,CAAI,EAIPZ,EAAmBA,CAAC1H,EAAOkB,EAASC,EAASC,EAAOC,IAEjDoG,EAAgBzH,EAAOkB,EAASC,EAASC,EAAOC,IAChDmG,EAAkBxH,EAAOkB,EAASC,EAASC,EAAOC,GAIrDsG,EAAkBA,CAAC3H,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,KAC9D,MAAMvJ,EAAQoC,EAAMkB,GAASC,GAGvBgH,EAAUlF,KAAKW,IAAI1C,EAAUE,GAC7BgH,EAAUnF,KAAKW,IAAIzC,EAAUE,GAGnC,GAAI8G,GAAW,GAAKC,GAAW,EAC7B,OAAO,EAIT,GAAgB,IAAZD,GAA6B,IAAZC,IAAkBxK,EAAMmI,WAAaxD,EAAUvC,EAAOpC,EAAMkB,OAE/E,GAAIuC,EAAQF,EAAS,CACnB,MAAMoH,EAAOvI,EAAMkB,GAAS,GAC5B,GAAIqH,GAAsB,SAAdA,EAAKxJ,MAAmBwJ,EAAKzJ,QAAUlB,EAAMkB,QAAUyJ,EAAKxC,WAEjE/F,EAAMkB,GAAS,KAAOlB,EAAMkB,GAAS,GAAI,CAE5C,MAAM+F,EAAgC,UAAhBrJ,EAAMkB,MAAoB,QAAU,QAC1D,IAAKsH,EAAoBpG,EAAOkB,EAAS,EAAG+F,KACvCb,EAAoBpG,EAAOkB,EAAS,EAAG+F,GAC1C,OAAO,CAEX,CAEJ,KAEK,CACH,MAAMsB,EAAOvI,EAAMkB,GAAS,GAC5B,GAAIqH,GAAsB,SAAdA,EAAKxJ,MAAmBwJ,EAAKzJ,QAAUlB,EAAMkB,QAAUyJ,EAAKxC,WAEjE/F,EAAMkB,GAAS,KAAOlB,EAAMkB,GAAS,KAAOlB,EAAMkB,GAAS,GAAI,CAElE,MAAM+F,EAAgC,UAAhBrJ,EAAMkB,MAAoB,QAAU,QAC1D,IAAKsH,EAAoBpG,EAAOkB,EAAS,EAAG+F,KACvCb,EAAoBpG,EAAOkB,EAAS,EAAG+F,GAC1C,OAAO,CAEX,CAEJ,CAGF,OAAO,CAAK,EAIDuB,EAAkBA,CAAC5K,EAAOwD,OAChCxD,GAAwB,SAAfA,EAAMmB,QAGI,UAAhBnB,EAAMkB,OAA+B,IAAVsC,GAAiC,UAAhBxD,EAAMkB,OAA+B,IAAVsC,GAIpEqH,EAAW,SAACzI,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,GAAsC,IAA3BuB,EAAcC,UAAA/I,OAAA,QAAAgJ,IAAAD,UAAA,GAAAA,UAAA,GAAG,KAE1F,MAAME,EAAW5C,KAAKC,MAAMD,KAAKE,UAAUnG,IACrC8I,EAAe7C,KAAKC,MAAMD,KAAKE,UAAUgB,GAAa,CAAEW,gBAAiB,KAAMiB,eAAgB,CAAEpJ,MAAO,CAAEqJ,UAAU,EAAMC,WAAW,GAAQvJ,MAAO,CAAEsJ,UAAU,EAAMC,WAAW,OAEjLrL,EAAQiL,EAAS3H,GAASC,GAC1BiG,EAAcyB,EAASzH,GAAOC,GACpC,IAAIoC,EAAgB2D,EAmBpB,GAhBmB,SAAfxJ,EAAMmB,MAAiD,IAA9BkE,KAAKW,IAAIzC,EAAUE,KAE1CA,EAAQF,GACV0H,EAASzH,GAAOC,EAAQ,GAAKwH,EAASzH,GAAO,GAC7CyH,EAASzH,GAAOC,EAAQ,GAAG0E,UAAW,EACtC8C,EAASzH,GAAO,GAAK,OAIrByH,EAASzH,GAAOC,EAAQ,GAAKwH,EAASzH,GAAO,GAC7CyH,EAASzH,GAAOC,EAAQ,GAAG0E,UAAW,EACtC8C,EAASzH,GAAO,GAAK,OAKN,SAAfxD,EAAMmB,MAAmBoC,IAAYE,IAAU+F,EAAa,CAE9D,MAAM8B,EAAahI,EACnBuC,EAAgBoF,EAASK,GAAY7H,GACrCwH,EAASK,GAAY7H,GAAS,IAChC,CAIA,GADAyH,EAAahB,gBAAkB,KACZ,SAAflK,EAAMmB,MAAiD,IAA9BkE,KAAKW,IAAI1C,EAAUE,GAAc,CAC5D,MAAMyG,EAA4B,UAAhBjK,EAAMkB,OAAqB,EAAI,EACjDgK,EAAahB,gBAAkB,CAAEpK,IAAKwD,EAAU2G,EAAWlK,IAAKwD,EAClE,CA+BA,MA5BmB,SAAfvD,EAAMmB,MACR+J,EAAaC,eAAenL,EAAMkB,OAAOkK,UAAW,EACpDF,EAAaC,eAAenL,EAAMkB,OAAOmK,WAAY,GAC7B,SAAfrL,EAAMmB,OACC,IAAZmC,GAA6B,IAAZC,GAAiC,UAAhBvD,EAAMkB,MAC1CgK,EAAaC,eAAepJ,MAAMsJ,WAAY,EACzB,IAAZ/H,GAA6B,IAAZC,GAAiC,UAAhBvD,EAAMkB,MACjDgK,EAAaC,eAAepJ,MAAMqJ,UAAW,EACxB,IAAZ9H,GAA6B,IAAZC,GAAiC,UAAhBvD,EAAMkB,MACjDgK,EAAaC,eAAerJ,MAAMuJ,WAAY,EACzB,IAAZ/H,GAA6B,IAAZC,GAAiC,UAAhBvD,EAAMkB,QACjDgK,EAAaC,eAAerJ,MAAMsJ,UAAW,IAK9B,SAAfpL,EAAMmB,MAAmByJ,EAAgB5K,EAAOwD,IAAUsH,EAE5DG,EAASzH,GAAOC,GAAS,CAAEtC,KAAM2J,EAAgB5J,MAAOlB,EAAMkB,MAAOiH,UAAU,IAG/E8C,EAASzH,GAAOC,GAASzD,EACzBiL,EAASzH,GAAOC,GAAO0E,UAAW,GAIpC8C,EAAS3H,GAASC,GAAW,KAEtB,CAAEnB,MAAO6I,EAAU1B,UAAW2B,EAAcrF,gBACrD,EAGa0F,EAAc,SAACnJ,EAAOlB,GAA2B,IAApBqI,EAASwB,UAAA/I,OAAA,QAAAgJ,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EAErD,IAAKpG,EAAUvC,EAAOlB,GAAQ,OAAO,EAGrC,IAAK,IAAIoC,EAAU,EAAGA,EAAU,EAAGA,IACjC,IAAK,IAAIC,EAAU,EAAGA,EAAU,EAAGA,IAAW,CAC5C,MAAMvD,EAAQoC,EAAMkB,GAASC,GAC7B,GAAIvD,GAASA,EAAMkB,QAAUA,EAC3B,IAAK,IAAIsC,EAAQ,EAAGA,EAAQ,EAAGA,IAC7B,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,EAAGA,IAE7B,GAAI6F,EAAYlH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,GAAY,CAEjE,MAAMS,EAAY5B,EAAWhG,GAK7B,GAJA4H,EAAUxG,GAAOC,GAASuG,EAAU1G,GAASC,GAC7CyG,EAAU1G,GAASC,GAAW,MAGzBoB,EAAUqF,EAAW9I,GACxB,OAAO,CAEX,CAIR,CAIF,OAAO,CACT,EAGasK,EAAc,SAACpJ,EAAOlB,GAA2B,IAApBqI,EAASwB,UAAA/I,OAAA,QAAAgJ,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAC,EAErD,GAAIpG,EAAUvC,EAAOlB,GAAQ,OAAO,EAGpC,IAAK,IAAIoC,EAAU,EAAGA,EAAU,EAAGA,IACjC,IAAK,IAAIC,EAAU,EAAGA,EAAU,EAAGA,IAAW,CAC5C,MAAMvD,EAAQoC,EAAMkB,GAASC,GAC7B,GAAIvD,GAASA,EAAMkB,QAAUA,EAC3B,IAAK,IAAIsC,EAAQ,EAAGA,EAAQ,EAAGA,IAC7B,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,EAAGA,IAC7B,GAAI6F,EAAYlH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,GAErD,OAAO,CAKjB,CAIF,OAAO,CACT,ECpfM9D,EAAc,CAClB,KAAQ,GACR,OAAU,GACV,OAAU,GACV,KAAQ,GACR,MAAS,GACT,KAAQ,KAIJgG,EAAgB,CACpB,KAAQ,CACN,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,CAAC,GAAK,GAAK,EAAG,IAAK,IAAK,EAAG,GAAK,IAChC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,CAAC,IAAM,IAAM,EAAG,EAAG,GAAI,GAAI,GAAK,IAChC,CAAC,GAAK,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,IAC1B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAExB,OAAU,CACR,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAC1B,EAAE,EAAG,EAAG,EAAG,IAAK,IAAK,EAAG,GAAI,GAC5B,EAAE,EAAG,GAAK,IAAK,EAAG,EAAG,IAAK,IAAM,GAChC,EAAE,EAAG,EAAG,IAAK,EAAG,EAAG,IAAK,GAAI,GAC5B,EAAE,EAAG,GAAK,EAAG,IAAK,IAAK,EAAG,IAAM,GAChC,EAAE,GAAI,EAAG,EAAG,GAAK,GAAK,GAAI,GAAI,GAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAEhC,OAAU,CACR,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GACxB,EAAE,EAAG,EAAG,GAAK,EAAG,EAAG,GAAK,GAAI,GAC5B,EAAE,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,IAAM,GAChC,EAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GACxB,EAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GACxB,EAAE,EAAG,GAAK,EAAG,EAAG,EAAG,EAAG,IAAM,GAC5B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAEhC,KAAQ,CACN,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,CAAC,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IACxB,EAAE,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC1B,EAAE,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC1B,EAAE,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC1B,EAAE,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC1B,EAAE,GAAK,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC1B,CAAC,EAAG,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,IAE5B,MAAS,CACP,EAAE,GAAI,GAAI,GAAI,IAAM,IAAM,GAAI,GAAI,GAClC,EAAE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GACxB,EAAE,EAAG,EAAG,GAAK,GAAK,GAAK,GAAK,GAAI,GAChC,EAAE,GAAK,EAAG,GAAK,GAAK,GAAK,GAAK,GAAI,IAClC,CAAC,EAAG,EAAG,GAAK,GAAK,GAAK,GAAK,GAAI,IAC/B,EAAE,EAAG,GAAK,GAAK,GAAK,GAAK,GAAK,GAAI,GAClC,EAAE,EAAG,EAAG,GAAK,EAAG,EAAG,EAAG,GAAI,GAC1B,EAAE,GAAI,GAAI,GAAI,IAAM,IAAM,GAAI,GAAI,IAEpC,KAAQ,CACN,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,EAAE,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC9B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAKpBC,EAAkB,IAAIC,IAyEtBC,EAAgB,CACpB,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,EAAE,GAAI,GAAI,EAAE,EAAG,GAClC,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,IAI1B5C,EAAa,CACjB6C,OAAQ,CAAC,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,IACzClB,KAAM,CAAC,EAAE,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IACrCmB,MAAO,CAAC,EAAE,GAAI,GAAI,EAAE,EAAG,GAAI,EAAE,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,GAAI,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,KAItEC,EAAqBA,CAAC3J,EAAOtC,EAAKC,EAAKwJ,KAC3C,MAAMvJ,EAAQoC,EAAMtC,GAAKC,GACzB,IAAKC,EAAO,MAAO,GAEnB,MAAMgM,EAAQ,GAEd,OAAQhM,EAAMmB,MACZ,IAAK,OAAQ,CACX,MAAM8I,EAA4B,UAAhBjK,EAAMkB,OAAqB,EAAI,EAG7CpB,EAAMmK,GAAa,GAAKnK,EAAMmK,EAAY,IAAM7H,EAAMtC,EAAMmK,GAAWlK,KACzEiM,EAAMjJ,KAAK,CAAEO,QAASxD,EAAKyD,QAASxD,EAAKyD,MAAO1D,EAAMmK,EAAWxG,MAAO1D,EAAKkM,WAAW,KAGnFjM,EAAMmI,UACPrI,EAAM,EAAImK,GAAa,GAAKnK,EAAM,EAAImK,EAAY,IACjD7H,EAAMtC,EAAMmK,GAAWlK,KAASqC,EAAMtC,EAAM,EAAImK,GAAWlK,IAC9DiM,EAAMjJ,KAAK,CAAEO,QAASxD,EAAKyD,QAASxD,EAAKyD,MAAO1D,EAAM,EAAImK,EAAWxG,MAAO1D,EAAKkM,WAAW,KAKhG,IAAK,MAAMpD,IAAa,EAAE,EAAG,GACvB9I,EAAM8I,GAAa,GAAK9I,EAAM8I,EAAY,GAAK/I,EAAMmK,GAAa,GAAKnK,EAAMmK,EAAY,IAEvF7H,EAAMtC,EAAMmK,GAAWlK,EAAM8I,IAC7BzG,EAAMtC,EAAMmK,GAAWlK,EAAM8I,GAAW3H,QAAUlB,EAAMkB,OAC1D8K,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAO1D,EAAMmK,EACbxG,MAAO1D,EAAM8I,EACboD,WAAW,KAKV7J,EAAMtC,EAAMmK,GAAWlK,EAAM8I,IAAcU,EAAUW,iBACtDpK,EAAMmK,IAAcV,EAAUW,gBAAgBpK,KAC9CC,EAAM8I,IAAcU,EAAUW,gBAAgBnK,KAChDiM,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAO1D,EAAMmK,EACbxG,MAAO1D,EAAM8I,EACboD,WAAW,EACXC,aAAa,KAKrB,KACF,CAEA,IAAK,SACH,IAAK,MAAOtD,EAAWC,KAAc+C,EAAe,CAClD,MAAM9C,EAAShJ,EAAM8I,EACfG,EAAShJ,EAAM8I,EAErB,GAAIC,GAAU,GAAKA,EAAS,GAAKC,GAAU,GAAKA,EAAS,EAAG,CAC1D,MAAMS,EAAcpH,EAAM0G,GAAQC,GAC7BS,GAAeA,EAAYtI,QAAUlB,EAAMkB,OAC9C8K,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAOsF,EACPrF,MAAOsF,EACPkD,YAAazC,GAGnB,CACF,CACA,MAGF,IAAK,SACL,IAAK,OACL,IAAK,QAAS,CACZ,MAAM2C,EAAOnD,EAAWhJ,EAAMmB,MAE9B,IAAK,MAAO8H,EAAQC,KAAWiD,EAAM,CACnC,IAAIrD,EAAShJ,EAAMmJ,EACfF,EAAShJ,EAAMmJ,EAEnB,KAAOJ,GAAU,GAAKA,EAAS,GAAKC,GAAU,GAAKA,EAAS,GAAG,CAC7D,MAAMS,EAAcpH,EAAM0G,GAAQC,GAElC,GAAKS,EAQE,CACDA,EAAYtI,QAAUlB,EAAMkB,OAC9B8K,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAOsF,EACPrF,MAAOsF,EACPkD,WAAW,IAGf,KACF,CAlBED,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAOsF,EACPrF,MAAOsF,EACPkD,WAAW,IAefnD,GAAUG,EACVF,GAAUG,CACZ,CACF,CACA,KACF,CAEA,IAAK,OAEH,IAAK,IAAIN,GAAa,EAAGA,GAAa,EAAGA,IACvC,IAAK,IAAIC,GAAa,EAAGA,GAAa,EAAGA,IAAa,CACpD,GAAkB,IAAdD,GAAiC,IAAdC,EAAiB,SAExC,MAAMC,EAAShJ,EAAM8I,EACfG,EAAShJ,EAAM8I,EAErB,GAAIC,GAAU,GAAKA,EAAS,GAAKC,GAAU,GAAKA,EAAS,EAAG,CAC1D,MAAMS,EAAcpH,EAAM0G,GAAQC,GAC7BS,GAAeA,EAAYtI,QAAUlB,EAAMkB,OAC9C8K,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAOsF,EACPrF,MAAOsF,EACPkD,YAAazC,GAGnB,CACF,CAIF,IAAKxJ,EAAMmI,UAAYoB,EAAU4B,eAAgB,CAC/C,MAAMA,EAAiB5B,EAAU4B,eAAenL,EAAMkB,OAGlDiK,GAAkBA,EAAeC,WAChChJ,EAAMtC,GAAKC,EAAM,KAAOqC,EAAMtC,GAAKC,EAAM,IAC1CqC,EAAMtC,GAAKC,EAAM,IAAmC,SAA7BqC,EAAMtC,GAAKC,EAAM,GAAGoB,OAC1CiB,EAAMtC,GAAKC,EAAM,GAAGoI,UACvB6D,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAO1D,EACP2D,MAAO1D,EAAM,EACbkM,WAAW,EACXG,YAAY,EACZC,aAAc,cAKdlB,IAAkBA,EAAeE,WAChCjJ,EAAMtC,GAAKC,EAAM,IAAOqC,EAAMtC,GAAKC,EAAM,IAAOqC,EAAMtC,GAAKC,EAAM,KAClEqC,EAAMtC,GAAKC,EAAM,IAAmC,SAA7BqC,EAAMtC,GAAKC,EAAM,GAAGoB,MAC1CiB,EAAMtC,GAAKC,EAAM,GAAGoI,UACvB6D,EAAMjJ,KAAK,CACTO,QAASxD,EACTyD,QAASxD,EACTyD,MAAO1D,EACP2D,MAAO1D,EAAM,EACbkM,WAAW,EACXG,YAAY,EACZC,aAAc,aAGpB,EASJ,OAAOL,CAAK,EA+BDM,EAAe,SAAClK,EAAOlB,EAAOqI,GAAsC,IAA3BgD,EAAUxB,UAAA/I,OAAA,QAAAgJ,IAAAD,UAAA,GAAAA,UAAA,GAAG,SACjE,IAEE,IAAIiB,EA9BcQ,EAACpK,EAAOlB,EAAOqI,KACnC,MAAMyC,EAAQ,GACRS,EAAiB,GAGvB,IAAK,IAAI3M,EAAM,EAAGA,EAAM,EAAGA,IACzB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAQoC,EAAMtC,GAAKC,GACzB,GAAIC,GAASA,EAAMkB,QAAUA,EAAO,CAClC,MAAMwL,EAAaX,EAAmB3J,EAAOtC,EAAKC,EAAKwJ,GACvDkD,EAAe1J,QAAQ2J,EACzB,CACF,CAIF,IAAK,MAAM9G,KAAQ6G,EAAgB,CACjC,MAAM,QAAEnJ,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUmC,EACvC0D,EAAYlH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,IACrDyC,EAAMjJ,KAAK6C,EAEf,CAEA,OAAOoG,CAAK,EAOEQ,CAAcpK,EAAOlB,EAAOqI,GAGxC,IAAKyC,GAA0B,IAAjBA,EAAMhK,OAClB,OAAO,KAIT,GAAqB,IAAjBgK,EAAMhK,OACR,OAAOgK,EAAM,GAIf,MAAMW,EAA8B,SAAfJ,EAAwB,GAAsB,WAAfA,EAA0B,GAAM,IACpF,GAAIlH,KAAKuH,SAAWD,EAAc,CAEhC,OAAOX,EADa3G,KAAKC,MAAMD,KAAKuH,SAAWZ,EAAMhK,QAEvD,CAGA,MAAM6K,EAxTYzK,KACpB,IAAI0K,EAAO,GACX,IAAK,IAAIhN,EAAM,EAAGA,EAAM,EAAGA,IACzB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAMC,EAAQoC,EAAMtC,GAAKC,GACrBC,IACF8M,GAAQ,GAAGhN,IAAMC,IAAMC,EAAMmB,KAAK,KAAKnB,EAAMkB,MAAM,KAEvD,CAEF,OAAO4L,CAAI,EA8SSC,CAAa3K,GACzB4K,EAAW,GAAGH,KAAa3L,KAASqL,IAE1C,GAAIb,EAAgBuB,IAAID,GACtB,OAAOtB,EAAgBwB,IAAIF,GAI7B,MAAMG,EAAwB,GAC1BnB,EAAMhK,OAASmL,IAEjBnB,EAAQA,EAAMoB,MAAK,IAAM,GAAM/H,KAAKuH,WAAUS,MAAM,EAAGF,IAIzD,MAAMG,EAAiBtB,EAAMzK,KAAIqE,IAC/B,IACE,MAAM2H,EA3TOC,EAACpL,EAAOwD,KAC3B,MAAM,QAAEtC,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUmC,EACrC5F,EAAQoC,EAAMkB,GAASC,GACvBiG,EAAcpH,EAAMoB,GAAOC,GAEjC,IAAI8J,EAAQ,EAGR/D,IACF+D,GAAyC,EAAhC9H,EAAY+D,EAAYrI,OAInC,MAAMsM,EAAuBhC,EAAczL,EAAMmB,MAAsB,UAAhBnB,EAAMkB,MAAoBoC,EAAU,EAAIA,GAASC,GAExGgK,GAAqD,IAD5B9B,EAAczL,EAAMmB,MAAsB,UAAhBnB,EAAMkB,MAAoBsC,EAAQ,EAAIA,GAAOC,GACnEgK,GAI7BF,GAAgC,IAAtB,GADalI,KAAKW,IAAI,IAAMxC,GAAS6B,KAAKW,IAAI,IAAMvC,KAI3C,SAAfzD,EAAMmB,OAERoM,GAA4B,IADa,UAAhBvN,EAAMkB,MAAqB,EAAIsC,EAASA,IAI5C,UAAhBxD,EAAMkB,OAAqBsC,GAAS,GAAuB,UAAhBxD,EAAMkB,OAAqBsC,GAAS,KAClF+J,GAAS,IAeb,MAVmB,SAAfvN,EAAMmB,OACRoM,GAAS,GAIS,WAAfvN,EAAMmB,MAAoC,WAAfnB,EAAMmB,QAChB,UAAhBnB,EAAMkB,OAAiC,IAAZoC,GAAmC,UAAhBtD,EAAMkB,OAAiC,IAAZoC,KAC7EiK,GAAS,GAGJA,CAAK,EAgRQC,CAAapL,EAAOwD,GAClC,MAAO,IAAKA,EAAM2H,QACpB,CAAE,MAAOG,GAEP,OADAC,QAAQD,MAAM,yBAA0BA,GACjC,IAAK9H,EAAM2H,MAAO,EAC3B,KAIFD,EAAeF,MAAK,CAACQ,EAAGC,IACL,UAAV3M,EAAoB2M,EAAEN,MAAQK,EAAEL,MAAQK,EAAEL,MAAQM,EAAEN,QAI7D,MAAMO,EAA+B,SAAfvB,EAAwB,EAAoB,WAAfA,EAA0B,EAAI,EAC3EwB,EAAWT,EAAeD,MAAM,EAAGhI,KAAK+E,IAAI0D,EAAeR,EAAetL,SAI1EgM,EAAWD,EADK1I,KAAKC,MAAMD,KAAKuH,SAAWmB,EAAS/L,SAO1D,OAHA0J,EAAgBuC,IAAIjB,EAAUgB,GAtW5BtC,EAAgBwC,KAJC,KAMnBxC,EAAgByC,QAuWTH,CACT,CAAE,MAAON,GACPC,QAAQD,MAAM,2BAA4BA,GAE1C,IACE,MAAMU,EAAW,GACjB,IAAK,IAAI9K,EAAU,EAAGA,EAAU,EAAGA,IACjC,IAAK,IAAIC,EAAU,EAAGA,EAAU,EAAGA,IAAW,CAC5C,MAAMvD,EAAQoC,EAAMkB,GAASC,GAC7B,GAAIvD,GAASA,EAAMkB,QAAUA,EAC3B,IAAK,IAAIsC,EAAQ,EAAGA,EAAQ,EAAGA,IAC7B,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,EAAGA,IACzB6F,EAAYlH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,IACrD6E,EAASrL,KAAK,CAAEO,UAASC,UAASC,QAAOC,SAKnD,CAGF,GAAI2K,EAASpM,OAAS,EACpB,OAAOoM,EAAS/I,KAAKC,MAAMD,KAAKuH,SAAWwB,EAASpM,QAExD,CAAE,MAAOqM,GACPV,QAAQD,MAAM,qCAAsCW,EACtD,CAEA,OAAO,IACT,CACF,EAGaC,EAAYA,CAAClM,EAAOlB,EAAOqI,EAAWgD,KACjD,IAEE,MAAMgC,EAAYC,KAAKC,MACjBC,EAAqB,IAG3B,IAAIC,EAAsBpC,EACP,SAAfA,GAAyBnK,EAAMS,OAAO+L,OAAOC,SAAS7M,OAAS,KAEjE2M,EAAsB,UAIxB,MAAMX,EAAW1B,EAAalK,EAAOlB,EAAOqI,EAAWoF,GAGvD,GAAIH,KAAKC,MAAQF,EAAYG,EAAoB,CAC/Cf,QAAQmB,KAAK,+DAEb,MAAM9C,EAAQ,GACd,IAAK,IAAI1I,EAAU,EAAGA,EAAU,EAAGA,IACjC,IAAK,IAAIC,EAAU,EAAGA,EAAU,EAAGA,IAAW,CAC5C,MAAMvD,EAAQoC,EAAMkB,GAASC,GAC7B,GAAIvD,GAASA,EAAMkB,QAAUA,EAC3B,IAAK,IAAIsC,EAAQ,EAAGA,EAAQ,EAAGA,IAC7B,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,EAAGA,IACzB6F,EAAYlH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,IACrDyC,EAAMjJ,KAAK,CAAEO,UAASC,UAASC,QAAOC,SAKhD,CAGF,GAAIuI,EAAMhK,OAAS,EACjB,OAAOgK,EAAM3G,KAAKC,MAAMD,KAAKuH,SAAWZ,EAAMhK,QAElD,CAEA,OAAOgM,CACT,CAAE,MAAON,GAGP,OAFAC,QAAQD,MAAM,gCAAiCA,GAExC,IACT,GChEaqB,MAjcf,WACE,MAAO3M,EAAO4M,GAAY/J,mBAAS+C,MAC5B3F,EAAe4M,GAAoBhK,mBAAS,OAC5CV,EAAY2K,GAAiBjK,mBAAS,UACtCT,EAAY2K,GAAiBlK,mBAAS,YACtCR,EAAa2K,GAAkBnK,mBAAS,KACxCsE,EAAW8F,GAAgBpK,mBAAS,CACzCiF,gBAAiB,KACjBiB,eAAgB,CACdpJ,MAAO,CAAEqJ,UAAU,EAAMC,WAAW,GACpCvJ,MAAO,CAAEsJ,UAAU,EAAMC,WAAW,OAGjC9I,EAAoB+M,GAAyBrK,mBAAS,KACtDzC,EAAgB+M,GAAqBtK,mBAAS,OAC9CL,EAAc4K,GAAmBvK,mBAAS,WAC1CwK,EAAUC,GAAezK,oBAAS,IAClCvC,EAAUiN,GAAe1K,mBAAS,OAClC2K,EAAiBC,GAAsB5K,mBAAS,OAChDyC,EAAcoI,GAAmB7K,mBAAS,YAC1CH,EAAYiL,GAAiB9K,oBAAS,GAGvC+K,EAAgBC,iBAAO,MAGvBC,EAAuBC,uBAAY,CAACnQ,EAAOsD,EAASC,EAASC,EAAOC,EAAOoC,EAAeiF,KAC9F,MAAMsF,EAAQ,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAGlD,IAAI/J,EAAW,GAyBf,MAtBmB,SAAfrG,EAAMmB,OACRkF,GAAYrG,EAAMmB,KAAKkP,OAAO,GAAGC,eAIhB,SAAftQ,EAAMmB,MAAmB0E,IAC3BQ,GAAY+J,EAAM7M,IAIhBsC,IACFQ,GAAY,KAIdA,GAAY+J,EAAM3M,GApBJ,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAoBjBD,GAG7BsH,IACFzE,GAAY,IAAMyE,EAAeuF,OAAO,GAAGC,eAGtCjK,CAAQ,GACd,IAGGkK,EAAaJ,uBAAY,SAAC7M,EAASC,EAASC,EAAOC,GAAkC,IAA3BqH,EAAcC,UAAA/I,OAAA,QAAAgJ,IAAAD,UAAA,GAAAA,UAAA,GAAG,KAE/E,MAAM/K,EAAQoC,EAAMkB,GAASC,IAGrBnB,MAAO6I,EAAU1B,UAAW2B,EAAY,cAAErF,GAAkBgF,EAClEzI,EACAkB,EACAC,EACAC,EACAC,EACA8F,EACAuB,GAIFkE,EAAS/D,GACToE,EAAanE,GAGb,MAGMsF,EAAU,CACdrN,KAAM,CAAErD,IAAKwD,EAASvD,IAAKwD,GAC3BH,GAAI,CAAEtD,IAAK0D,EAAOzD,IAAK0D,GACvBzD,QACA6F,gBACAQ,SARe6J,EAAqBlQ,EAAOsD,EAASC,EAASC,EAAOC,EAAOoC,EAAeiF,GAS1F5J,MAAOlB,EAAMkB,OAGfkO,GAAeqB,GAAe,IAAIA,EAAaD,KAG/CtB,GAAcwB,GAAyB,UAAbA,EAAuB,QAAU,UAG3DzB,EAAiB,MACjBK,EAAsB,IACtBI,GAAY,GACZC,EAAY,KACd,GAAG,CAACvN,EAAOmH,EAAW2G,IAGtBS,qBAAU,KACRX,EAAcY,QAAUL,CAAU,GACjC,CAACA,IAGJ,MAAMM,EAAaV,uBAAY,KACV,UAAf5L,GAAyC,YAAfC,GAA6BM,IACzDiL,GAAc,GAGde,YAAW,KACT,IAEE,MAAMC,EAASzC,EAAUlM,EAAO,QAASmH,EAAW3E,GAEpD,GAAImM,EAAQ,CACV,MAAM,QAAEzN,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUsN,EACrC/Q,EAAQoC,EAAMkB,GAASC,GAGzBqH,EAAgB5K,EAAOwD,GAEzBwM,EAAcY,QAAQtN,EAASC,EAASC,EAAOC,EAAO,SAEtDuM,EAAcY,QAAQtN,EAASC,EAASC,EAAOC,EAEnD,KAAO,CAEL,MAAMuI,EAAQ,GACd,IAAK,IAAI1I,EAAU,EAAGA,EAAU,EAAGA,IACjC,IAAK,IAAIC,EAAU,EAAGA,EAAU,EAAGA,IAAW,CAC5C,MAAMvD,EAAQoC,EAAMkB,GAASC,GAC7B,GAAIvD,GAAyB,UAAhBA,EAAMkB,MACjB,IAAK,IAAIsC,EAAQ,EAAGA,EAAQ,EAAGA,IAC7B,IAAK,IAAIC,EAAQ,EAAGA,EAAQ,EAAGA,IACzB6F,EAAYlH,EAAOkB,EAASC,EAASC,EAAOC,EAAO8F,IACrDyC,EAAMjJ,KAAK,CAAEO,UAASC,UAASC,QAAOC,SAKhD,CAGF,GAAIuI,EAAMhK,OAAS,EAAG,CACpB,MAAMgP,EAAahF,EAAM3G,KAAKC,MAAMD,KAAKuH,SAAWZ,EAAMhK,UACpD,QAAEsB,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUuN,EAC3ChB,EAAcY,QAAQtN,EAASC,EAASC,EAAOC,EACjD,CACF,CACF,CAAE,MAAOiK,GACPC,QAAQD,MAAM,gCAAiCA,EACjD,CAAC,QAECqC,GAAc,EAChB,IACC,KACL,GACC,CAAC3N,EAAOmC,EAAYC,EAAY+E,EAAW3E,EAAcE,IAG5D6L,qBAAU,KACR,IAAIM,EAAY,KAUhB,MARmB,UAAf1M,GAAyC,YAAfC,GAA6BM,IAEzDmM,EAAYH,YAAW,KACrBD,GAAY,GACX,MAIE,KACDI,GACFC,aAAaD,EACf,CACD,GACA,CAAC1M,EAAYC,EAAYqM,EAAY/L,IAGxC6L,qBAAU,KACR,GAAIlM,EAAYzC,OAAS,EAAG,CAE1B,MAAMmP,EAAexM,EAAUvC,EAAO,SAChCgP,EAAezM,EAAUvC,EAAO,SAElC+O,GACF5B,EAAkB,SAGdhE,EAAYnJ,EAAO,QAASmH,IAC9B4F,EAAc,2BAEPiC,GACT7B,EAAkB,SAGdhE,EAAYnJ,EAAO,QAASmH,IAC9B4F,EAAc,2BAGhBI,EAAkB,OAID,UAAfhL,GAA0BiH,EAAYpJ,EAAO,QAASmH,IAEhC,UAAfhF,GAA0BiH,EAAYpJ,EAAO,QAASmH,KAD/D4F,EAAc,oBAIlB,IACC,CAAC/M,EAAOmC,EAAYE,EAAa8E,IAGpC,MAAM8H,EAAazO,mBAAQ,KACzB,IAAKP,EAAe,MAAO,GAE3B,MAAM2J,EAAQ,GACd,IAAK,IAAIlM,EAAM,EAAGA,EAAM,EAAGA,IACzB,IAAK,IAAIC,EAAM,EAAGA,EAAM,EAAGA,IACrBuJ,EAAYlH,EAAOC,EAAcvC,IAAKuC,EAActC,IAAKD,EAAKC,EAAKwJ,IACrEyC,EAAMjJ,KAAK,CAAEjD,MAAKC,QAIxB,OAAOiM,CAAK,GACX,CAAC3J,EAAeD,EAAOmH,IAG1BoH,qBAAU,KACRrB,EAAsB+B,EAAW,GAChC,CAACA,IAGmBlB,uBAAamB,IAClC,OAAQA,GACN,IAAK,OAML,QAAS,MAAO,GALhB,IAAK,SAAU,MAAO,IACtB,IAAK,SAAU,MAAO,IACtB,IAAK,OAAQ,MAAO,IACpB,IAAK,QAAS,MAAO,IACrB,IAAK,OAAQ,MAAO,IAEtB,GACC,IAVH,MAYMC,EAAoBpB,uBAAY,CAACrQ,EAAKC,KAE1C,GAAmB,YAAfyE,GAA4BoL,EAAiB,OAGjD,GAAmB,UAAfrL,EAAwB,OAE5B,MAAMvE,EAAQoC,EAAMtC,GAAKC,GAGzB,GAAIsC,EAAe,CAEjB,GAAIA,EAAcvC,MAAQA,GAAOuC,EAActC,MAAQA,EAErD,YADAkP,EAAiB,MAKnB,GAAIjP,GAASA,EAAMkB,QAAUqD,EAE3B,YADA0K,EAAiB,CAAEnP,MAAKC,MAAKC,UAK/B,GAAIsJ,EAAYlH,EAAOC,EAAcvC,IAAKuC,EAActC,IAAKD,EAAKC,EAAKwJ,GAAY,CAEjF,GAAIqB,EAAgBvI,EAAcrC,MAAOF,GAAM,CAE7C,MAAM0R,EAAYC,SAASC,cAAc,gBAAgBC,wBACnDC,EAAaJ,EAAUK,MAAQ,EAYrC,YAVAhC,EAAmB,CACjBvM,QAASjB,EAAcvC,IACvByD,QAASlB,EAActC,IACvByD,MAAO1D,EACP2D,MAAO1D,EACP0G,SAAU,CACRM,EAAGyK,EAAU1K,KAAO/G,EAAM6R,EAAaA,EAAa,EACpD/K,EAAG2K,EAAU5K,IAAM9G,EAAM8R,EAAaA,EAAa,IAIzD,CAGArB,EAAWlO,EAAcvC,IAAKuC,EAActC,IAAKD,EAAKC,EACxD,CACF,MAEMC,GAASA,EAAMkB,QAAUqD,GAC3B0K,EAAiB,CAAEnP,MAAKC,MAAKC,SAEjC,GACC,CAACoC,EAAOmH,EAAW/E,EAAY+L,EAAYhM,EAAYqL,EAAiBvN,IAErEyP,EAAkB3B,uBAAamB,IACnC,IAAK1B,EAAiB,OAEtB,MAAM,QAAEtM,EAAO,QAAEC,EAAO,MAAEC,EAAK,MAAEC,GAAUmM,EAG3CW,EAAWjN,EAASC,EAASC,EAAOC,EAAO6N,GAC3CzB,EAAmB,KAAK,GACvB,CAACU,EAAYX,IAEVmC,EAAY5B,uBAAY,KAC5BnB,EAAShH,KACTiH,EAAiB,MACjBC,EAAc,SACdC,EAAc,WACdC,EAAe,IACfC,EAAa,CACXnF,gBAAiB,KACjBiB,eAAgB,CACdpJ,MAAO,CAAEqJ,UAAU,EAAMC,WAAW,GACpCvJ,MAAO,CAAEsJ,UAAU,EAAMC,WAAW,MAGxCiE,EAAsB,IACtBC,EAAkB,MAClBG,GAAY,GACZC,EAAY,MACZE,EAAmB,KAAK,GACvB,IAEGmC,EAAyB7B,uBAAa5D,IAC1CiD,EAAgBjD,GAChBwF,GAAW,GACV,CAACA,IAEEE,EAAU9B,uBAAY,KAE1B,GAAmB,UAAf5L,GAAyC,YAAfC,EAA0B,CACtD,MAAM0N,EAAgB5D,EAAUlM,EAAO,QAASmH,EAAW,GACvD2I,IACFxC,GAAY,GACZC,EAAYuC,GAEhB,IACC,CAAC9P,EAAOmH,EAAW/E,EAAYD,IAG5B4N,EAAoBhC,uBAAarI,IACrCgI,EAAgBhI,GAEhBsK,aAAaC,QAAQ,aAAcvK,EAAS,GAC3C,IAGH6I,qBAAU,KACR,MAAM2B,EAAaF,aAAaG,QAAQ,cACpCD,GAAcpL,EAAOoL,IACvBxC,EAAgBwC,EAClB,GACC,IAGH,MAAM7P,GAAWG,mBAAQ,IAChB6B,EAAYzC,OAAS,EAAIyC,EAAYA,EAAYzC,OAAS,GAAK,MACrE,CAACyC,IAGE+N,GAAqB5P,mBAAQ,IAAMsE,EAAOQ,IAAe,CAACA,IAEhE,OACEpG,eAAA,OAAKT,UAAU,MAAKE,SAAA,CAClBO,eAAA,OAAKT,UAAU,aAAYE,SAAA,CACzBH,cAAA,MAAAG,SAAI,aACJH,cAAA,OAAKC,UAAU,iBAAgBE,SAC7BH,cAAA,QAAAG,SAAM,mCAGVO,eAAA,OAAKT,UAAU,sBAAqBE,SAAA,CAClCH,cAAA,QAAMC,UAAU,mBAAkBE,SAAC,mBACnCO,eAAA,OAAKT,UAAU,qBAAoBE,SAAA,CACjCH,cAAA,UACEC,UAAW,sBAAsC,SAAjB+D,EAA0B,SAAW,IACrEpE,QAASA,IAAMwR,EAAuB,QAAQjR,SAC/C,SAGDH,cAAA,UACEC,UAAW,sBAAsC,WAAjB+D,EAA4B,SAAW,IACvEpE,QAASA,IAAMwR,EAAuB,UAAUjR,SACjD,WAGDH,cAAA,UACEC,UAAW,sBAAsC,SAAjB+D,EAA0B,SAAW,IACrEpE,QAASA,IAAMwR,EAAuB,QAAQjR,SAC/C,eAKLH,cAAC6G,EAAa,CACZC,aAAcA,EACdC,cAAewK,IAEjB7Q,eAAA,OAAKT,UAAU,iBAAgBE,SAAA,CAC7BH,cAACsB,EAAU,CACTE,MAAOA,EACPC,cAAeA,EACfC,cAAeiP,EACfhP,mBAAoBA,EACpBC,eAAgBA,EAChBC,SAAUA,GACVC,SAAU+M,EAAW/M,EAAW,KAChCC,MAAO6P,KAET5R,cAAC0D,EAAQ,CACPC,WAAYA,EACZC,WAAYA,EACZC,YAAaA,EACbC,YAAaqN,EACbpN,UAA8B,OAAnBnC,EACXoC,aAAcA,EACdC,UAAWoN,EACXnN,WAAYA,OAGf8K,GACChP,cAAC4F,EAAe,CACdC,SAAUmJ,EAAgBnJ,SAC1BvF,MAAM,QACNwF,SAAUoL,EACVnL,SAAUA,IAAMkJ,EAAmB,QAGvCjP,cAAA,OAAKC,UAAU,aAAYE,SACzBO,eAAA,OAAKT,UAAU,iBAAgBE,SAAA,CAC7BH,cAAA,KAAAG,SAAG,yDACHO,eAAA,KAAAP,SAAA,CAAG,SAAG,IAAIyN,MAAOiE,cAAc,wCAKzC,EC7cAC,IAASC,OACP/R,cAACgS,IAAMC,WAAU,CAAA9R,SACfH,cAACmO,EAAG,MAEN0C,SAASqB,eAAe,Q","file":"static/js/main.033754e6.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/white-pawn.236f6686.svg\";","export default __webpack_public_path__ + \"static/media/white-rook.51da5ea4.svg\";","export default __webpack_public_path__ + \"static/media/white-knight.6682d263.svg\";","export default __webpack_public_path__ + \"static/media/white-bishop.434cf6df.svg\";","export default __webpack_public_path__ + \"static/media/white-queen.2ec74f60.svg\";","export default __webpack_public_path__ + \"static/media/white-king.5933a366.svg\";","export default __webpack_public_path__ + \"static/media/black-pawn.3df4af41.svg\";","export default __webpack_public_path__ + \"static/media/black-rook.6208da08.svg\";","export default __webpack_public_path__ + \"static/media/black-knight.dbe602a6.svg\";","export default __webpack_public_path__ + \"static/media/black-bishop.d3b59849.svg\";","export default __webpack_public_path__ + \"static/media/black-queen.81d53079.svg\";","export default __webpack_public_path__ + \"static/media/black-king.5c3d9d02.svg\";","import React, { useMemo, memo } from 'react';\nimport './ChessBoard.css';\n\n// Import SVG pieces\nimport whitePawn from '../assets/pieces/white-pawn.svg';\nimport whiteRook from '../assets/pieces/white-rook.svg';\nimport whiteKnight from '../assets/pieces/white-knight.svg';\nimport whiteBishop from '../assets/pieces/white-bishop.svg';\nimport whiteQueen from '../assets/pieces/white-queen.svg';\nimport whiteKing from '../assets/pieces/white-king.svg';\nimport blackPawn from '../assets/pieces/black-pawn.svg';\nimport blackRook from '../assets/pieces/black-rook.svg';\nimport blackKnight from '../assets/pieces/black-knight.svg';\nimport blackBishop from '../assets/pieces/black-bishop.svg';\nimport blackQueen from '../assets/pieces/black-queen.svg';\nimport blackKing from '../assets/pieces/black-king.svg';\n\n// Map piece types to SVG images - moved outside component for better performance\nconst pieceImages = {\n  'white': {\n    'pawn': whitePawn,\n    'rook': whiteRook,\n    'knight': whiteKnight,\n    'bishop': whiteBishop,\n    'queen': whiteQueen,\n    'king': whiteKing\n  },\n  'black': {\n    'pawn': blackPawn,\n    'rook': blackRook,\n    'knight': blackKnight,\n    'bishop': blackBishop,\n    'queen': blackQueen,\n    'king': blackKing\n  }\n};\n\n// Memoized Square component for better performance\nconst Square = memo(({ \n  row, \n  col, \n  piece, \n  isLight, \n  isSelected, \n  isHighlighted, \n  isCheck, \n  isLastMove, \n  isHint, \n  squareColor, \n  onClick \n}) => {\n  let squareClassName = `square ${isLight ? 'light' : 'dark'}`;\n  if (isSelected) squareClassName += ' selected';\n  if (isHighlighted) squareClassName += ' highlighted';\n  if (isCheck) squareClassName += ' check';\n  if (isLastMove) squareClassName += ' last-move';\n  if (isHint) squareClassName += ' hint';\n  \n  const squareStyle = {\n    backgroundColor: squareColor\n  };\n  \n  return (\n    <div \n      className={squareClassName}\n      style={squareStyle}\n      onClick={onClick}\n    >\n      {piece && !piece.captured && (\n        <img \n          src={pieceImages[piece.color][piece.type]} \n          alt={`${piece.color} ${piece.type}`} \n          className={`piece ${piece.color}`}\n        />\n      )}\n    </div>\n  );\n});\n\n// Memoized coordinates component\nconst Coordinates = memo(() => {\n  const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n  const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n  \n  return (\n    <div className=\"board-coordinates\">\n      <div className=\"files\">\n        {files.map(file => (\n          <div key={file}>{file}</div>\n        ))}\n      </div>\n      <div className=\"ranks\">\n        {ranks.map(rank => (\n          <div key={rank}>{rank}</div>\n        ))}\n      </div>\n    </div>\n  );\n});\n\n// Memoized captured pieces component\nconst CapturedPieces = memo(({ capturedPieces, color }) => {\n  const capturedByOpponent = color === 'white' ? capturedPieces.black : capturedPieces.white;\n  \n  if (capturedByOpponent.length === 0) return null;\n  \n  return (\n    <div className=\"captured-row\">\n      {capturedByOpponent.map((piece, index) => (\n        <img \n          key={index}\n          src={pieceImages[piece.color][piece.type]} \n          alt={`${piece.color} ${piece.type}`} \n          className=\"captured-piece\"\n        />\n      ))}\n    </div>\n  );\n});\n\nconst ChessBoard = ({ \n  board, \n  selectedPiece, \n  onSquareClick, \n  highlightedSquares, \n  checkIndicator,\n  lastMove,\n  hintMove,\n  theme\n}) => {\n  // Calculate captured pieces - memoized for performance\n  const capturedPieces = useMemo(() => {\n    const captured = {\n      white: [],\n      black: []\n    };\n    \n    board.flat().forEach(piece => {\n      if (piece && piece.captured) {\n        captured[piece.color].push(piece);\n      }\n    });\n    \n    return captured;\n  }, [board]);\n\n  // Check if a square is highlighted (valid move) - memoized lookup map\n  const highlightedSquaresMap = useMemo(() => {\n    const map = {};\n    highlightedSquares.forEach(square => {\n      map[`${square.row}-${square.col}`] = true;\n    });\n    return map;\n  }, [highlightedSquares]);\n  \n  // Check if a square is part of the last move - memoized\n  const lastMoveMap = useMemo(() => {\n    if (!lastMove) return {};\n    \n    const { from, to } = lastMove;\n    return {\n      [`${from.row}-${from.col}`]: true,\n      [`${to.row}-${to.col}`]: true\n    };\n  }, [lastMove]);\n  \n  // Check if a square is part of a hint - memoized\n  const hintSquareMap = useMemo(() => {\n    if (!hintMove) return {};\n    \n    const { fromRow, fromCol, toRow, toCol } = hintMove;\n    return {\n      [`${fromRow}-${fromCol}`]: true,\n      [`${toRow}-${toCol}`]: true\n    };\n  }, [hintMove]);\n\n  // Render the board - memoized for performance\n  const boardRows = useMemo(() => {\n    const squares = [];\n    \n    // Define these functions inside the useMemo callback to avoid dependency issues\n    const isHighlighted = (row, col) => {\n      return !!highlightedSquaresMap[`${row}-${col}`];\n    };\n    \n    const isLastMove = (row, col) => {\n      return !!lastMoveMap[`${row}-${col}`];\n    };\n    \n    const isHintSquare = (row, col) => {\n      return !!hintSquareMap[`${row}-${col}`];\n    };\n    \n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        const piece = board[row][col];\n        const isLight = (row + col) % 2 === 0;\n        const isSelected = selectedPiece && selectedPiece.row === row && selectedPiece.col === col;\n        const isCheck = checkIndicator && piece && piece.type === 'king' && piece.color === checkIndicator;\n        \n        // Get the square color from the theme\n        const squareColor = isLight ? theme.lightSquare : theme.darkSquare;\n        \n        squares.push(\n          <Square\n            key={`${row}-${col}`}\n            row={row}\n            col={col}\n            piece={piece}\n            isLight={isLight}\n            isSelected={isSelected}\n            isHighlighted={isHighlighted(row, col)}\n            isCheck={isCheck}\n            isLastMove={isLastMove(row, col)}\n            isHint={isHintSquare(row, col)}\n            squareColor={squareColor}\n            onClick={() => onSquareClick(row, col)}\n          />\n        );\n      }\n    }\n    \n    return squares;\n  }, [board, selectedPiece, checkIndicator, theme, onSquareClick, highlightedSquaresMap, lastMoveMap, hintSquareMap]);\n\n  // Apply theme styles\n  const containerStyle = useMemo(() => ({\n    background: theme.boardBg,\n    '--highlight-color': theme.highlightColor,\n    '--check-color': theme.checkColor,\n    '--last-move-color': theme.lastMoveColor,\n    '--accent-color': theme.accentColor\n  }), [theme]);\n\n  return (\n    <div className=\"chess-board-container\" style={containerStyle}>\n      <div className=\"chess-board\">\n        {boardRows}\n      </div>\n      <Coordinates />\n      <div className=\"captured-pieces\">\n        <CapturedPieces capturedPieces={capturedPieces} color=\"white\" />\n        <CapturedPieces capturedPieces={capturedPieces} color=\"black\" />\n      </div>\n    </div>\n  );\n};\n\nexport default memo(ChessBoard); ","import React, { useState } from 'react';\nimport './GameInfo.css';\n\nconst GameInfo = ({ \n  playerTurn, \n  gameStatus, \n  moveHistory, \n  onResetGame, \n  isInCheck,\n  aiDifficulty,\n  onGetHint,\n  aiThinking\n}) => {\n  const [activeTab, setActiveTab] = useState('moves');\n  \n  // Group moves into pairs (white and black)\n  const groupedMoves = [];\n  for (let i = 0; i < moveHistory.length; i += 2) {\n    groupedMoves.push({\n      number: Math.floor(i / 2) + 1,\n      white: moveHistory[i],\n      black: moveHistory[i + 1]\n    });\n  }\n  \n  // Calculate material advantage\n  const calculateMaterialAdvantage = () => {\n    const pieceValues = {\n      'pawn': 1,\n      'knight': 3,\n      'bishop': 3,\n      'rook': 5,\n      'queen': 9,\n      'king': 0\n    };\n    \n    let whiteCaptured = 0;\n    let blackCaptured = 0;\n    \n    moveHistory.forEach(move => {\n      if (move.capturedPiece) {\n        if (move.capturedPiece.color === 'white') {\n          blackCaptured += pieceValues[move.capturedPiece.type];\n        } else {\n          whiteCaptured += pieceValues[move.capturedPiece.type];\n        }\n      }\n    });\n    \n    const advantage = whiteCaptured - blackCaptured;\n    \n    if (advantage > 0) {\n      return { color: 'white', value: advantage };\n    } else if (advantage < 0) {\n      return { color: 'black', value: Math.abs(advantage) };\n    } else {\n      return { color: 'equal', value: 0 };\n    }\n  };\n  \n  const materialAdvantage = calculateMaterialAdvantage();\n  \n  // Render game status\n  const renderGameStatus = () => {\n    let statusText = '';\n    \n    if (gameStatus === 'ongoing') {\n      statusText = `${playerTurn === 'white' ? 'White' : 'Black'}'s turn`;\n    } else if (gameStatus.includes('checkmate')) {\n      statusText = gameStatus;\n    } else if (gameStatus.includes('stalemate')) {\n      statusText = 'Draw by stalemate';\n    } else {\n      statusText = gameStatus;\n    }\n    \n    return (\n      <div className=\"status-container\">\n        <div className=\"status\">\n          {statusText}\n          {aiThinking && playerTurn === 'black' && (\n            <div className=\"ai-thinking\">\n              <span>AI is thinking</span>\n              <div className=\"thinking-dots\">\n                <span className=\"dot\"></span>\n                <span className=\"dot\"></span>\n                <span className=\"dot\"></span>\n              </div>\n            </div>\n          )}\n        </div>\n        <div className=\"player-indicators\">\n          <div className={`player-indicator ${playerTurn === 'white' ? 'active' : ''}`}>\n            <span className=\"white\">White</span>\n            {isInCheck && playerTurn === 'white' && <span className=\"check-indicator\">CHECK!</span>}\n          </div>\n          <div className={`player-indicator ${playerTurn === 'black' ? 'active' : ''}`}>\n            <span className=\"black\">Black</span>\n            {isInCheck && playerTurn === 'black' && <span className=\"check-indicator\">CHECK!</span>}\n          </div>\n        </div>\n        {isInCheck && gameStatus === 'ongoing' && (\n          <div className=\"check-status\">\n            {isInCheck === 'white' ? 'White' : 'Black'} is in check!\n          </div>\n        )}\n        {gameStatus !== 'ongoing' && (\n          <div className=\"game-over\">\n            {gameStatus}\n          </div>\n        )}\n        <div className=\"button-container\">\n          <button className=\"reset-button\" onClick={onResetGame}>\n            New Game\n          </button>\n          <button \n            className=\"hint-button\" \n            onClick={onGetHint}\n            disabled={gameStatus !== 'ongoing' || playerTurn !== 'white' || aiThinking}\n          >\n            Hint\n          </button>\n        </div>\n      </div>\n    );\n  };\n  \n  // Render move history\n  const renderMoveHistory = () => {\n    if (moveHistory.length === 0) {\n      return <div className=\"no-moves\">No moves yet</div>;\n    }\n    \n    return (\n      <div className=\"moves-container\">\n        <table className=\"moves-table\">\n          <thead>\n            <tr>\n              <th>#</th>\n              <th>White</th>\n              <th>Black</th>\n            </tr>\n          </thead>\n          <tbody>\n            {groupedMoves.map(move => (\n              <tr key={move.number}>\n                <td className=\"move-number\">{move.number}</td>\n                <td className=\"white-move\">{move.white ? move.white.notation : ''}</td>\n                <td className=\"black-move\">{move.black ? move.black.notation : ''}</td>\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n    );\n  };\n  \n  // Render analysis\n  const renderAnalysis = () => {\n    const searchDepth = {\n      'easy': 1,\n      'medium': 2,\n      'hard': 3\n    }[aiDifficulty];\n    \n    return (\n      <div className=\"analysis-container\">\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">Total Moves</span>\n          <span className=\"analysis-value\">{moveHistory.length}</span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">Material Advantage</span>\n          <span className={`analysis-value material-advantage ${materialAdvantage.color}`}>\n            {materialAdvantage.color === 'equal' ? 'Equal' : `+${materialAdvantage.value} for ${materialAdvantage.color}`}\n          </span>\n        </div>\n        <div className=\"analysis-item\">\n          <span className=\"analysis-label\">AI Thinking Depth</span>\n          <span className=\"analysis-value\">{searchDepth} {searchDepth === 1 ? 'move' : 'moves'}</span>\n        </div>\n      </div>\n    );\n  };\n  \n  return (\n    <div className=\"game-info\">\n      <h2>Game Status</h2>\n      {renderGameStatus()}\n      \n      <div className=\"tabs\">\n        <div \n          className={`tab ${activeTab === 'moves' ? 'active' : ''}`}\n          onClick={() => setActiveTab('moves')}\n        >\n          Moves\n        </div>\n        <div \n          className={`tab ${activeTab === 'analysis' ? 'active' : ''}`}\n          onClick={() => setActiveTab('analysis')}\n        >\n          Analysis\n        </div>\n      </div>\n      \n      <div className=\"tab-content\">\n        {activeTab === 'moves' ? renderMoveHistory() : renderAnalysis()}\n      </div>\n    </div>\n  );\n};\n\nexport default GameInfo; ","import React from 'react';\nimport './PromotionDialog.css';\n\n// Import SVG pieces\nimport whiteQueen from '../assets/pieces/white-queen.svg';\nimport whiteRook from '../assets/pieces/white-rook.svg';\nimport whiteBishop from '../assets/pieces/white-bishop.svg';\nimport whiteKnight from '../assets/pieces/white-knight.svg';\nimport blackQueen from '../assets/pieces/black-queen.svg';\nimport blackRook from '../assets/pieces/black-rook.svg';\nimport blackBishop from '../assets/pieces/black-bishop.svg';\nimport blackKnight from '../assets/pieces/black-knight.svg';\n\nconst PromotionDialog = ({ position, color, onSelect, onCancel }) => {\n  const pieceImages = {\n    'white': {\n      'queen': whiteQueen,\n      'rook': whiteRook,\n      'bishop': whiteBishop,\n      'knight': whiteKnight\n    },\n    'black': {\n      'queen': blackQueen,\n      'rook': blackRook,\n      'bishop': blackBishop,\n      'knight': blackKnight\n    }\n  };\n\n  const pieces = ['queen', 'rook', 'bishop', 'knight'];\n\n  return (\n    <div className=\"promotion-dialog-backdrop\" onClick={onCancel}>\n      <div \n        className=\"promotion-dialog\" \n        style={{ \n          top: position.y, \n          left: position.x \n        }}\n        onClick={(e) => e.stopPropagation()}\n      >\n        <div className=\"promotion-title\">Promote to:</div>\n        <div className=\"promotion-options\">\n          {pieces.map(piece => (\n            <div \n              key={piece} \n              className=\"promotion-piece\" \n              onClick={() => onSelect(piece)}\n            >\n              <img \n                src={pieceImages[color][piece]} \n                alt={`${color} ${piece}`} \n                className=\"promotion-piece-image\"\n              />\n              <div className=\"promotion-piece-name\">{piece}</div>\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PromotionDialog; ","// Chess board themes\nconst themes = {\n  // Classic wooden theme\n  classic: {\n    name: 'Classic',\n    lightSquare: '#f0d9b5',\n    darkSquare: '#b58863',\n    highlightColor: 'rgba(78, 205, 196, 0.7)',\n    checkColor: 'rgba(255, 107, 107, 0.6)',\n    lastMoveColor: 'rgba(255, 209, 102, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9))',\n    accentColor: '#4ecdc4'\n  },\n  \n  // Blue theme\n  blue: {\n    name: 'Ocean Blue',\n    lightSquare: '#dee3e6',\n    darkSquare: '#8ca2ad',\n    highlightColor: 'rgba(106, 168, 79, 0.7)',\n    checkColor: 'rgba(244, 67, 54, 0.6)',\n    lastMoveColor: 'rgba(255, 193, 7, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(25, 118, 210, 0.9), rgba(13, 71, 161, 0.9))',\n    accentColor: '#03a9f4'\n  },\n  \n  // Dark theme\n  dark: {\n    name: 'Midnight',\n    lightSquare: '#6b7987',\n    darkSquare: '#2e3947',\n    highlightColor: 'rgba(121, 134, 203, 0.7)',\n    checkColor: 'rgba(255, 82, 82, 0.6)',\n    lastMoveColor: 'rgba(255, 215, 64, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(20, 20, 31, 0.9), rgba(10, 10, 18, 0.9))',\n    accentColor: '#9c27b0'\n  },\n  \n  // Green theme\n  green: {\n    name: 'Forest',\n    lightSquare: '#eeeed2',\n    darkSquare: '#769656',\n    highlightColor: 'rgba(119, 149, 86, 0.7)',\n    checkColor: 'rgba(255, 97, 97, 0.6)',\n    lastMoveColor: 'rgba(255, 213, 79, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(27, 94, 32, 0.9), rgba(46, 125, 50, 0.9))',\n    accentColor: '#8bc34a'\n  },\n  \n  // Coral theme\n  coral: {\n    name: 'Coral',\n    lightSquare: '#fce4ec',\n    darkSquare: '#f06292',\n    highlightColor: 'rgba(128, 203, 196, 0.7)',\n    checkColor: 'rgba(255, 82, 82, 0.6)',\n    lastMoveColor: 'rgba(255, 202, 40, 0.4)',\n    boardBg: 'linear-gradient(135deg, rgba(216, 27, 96, 0.9), rgba(142, 36, 170, 0.9))',\n    accentColor: '#00bcd4'\n  }\n};\n\nexport default themes; ","import React from 'react';\nimport './ThemeSelector.css';\nimport themes from '../themes';\n\nconst ThemeSelector = ({ currentTheme, onThemeChange }) => {\n  return (\n    <div className=\"theme-selector\">\n      <div className=\"theme-selector-label\">Board Theme:</div>\n      <div className=\"theme-options\">\n        {Object.keys(themes).map(themeKey => (\n          <div \n            key={themeKey}\n            className={`theme-option ${currentTheme === themeKey ? 'active' : ''}`}\n            onClick={() => onThemeChange(themeKey)}\n            title={themes[themeKey].name}\n          >\n            <div \n              className=\"theme-preview\"\n              style={{\n                background: `linear-gradient(135deg, \n                  ${themes[themeKey].lightSquare} 0%, \n                  ${themes[themeKey].lightSquare} 50%, \n                  ${themes[themeKey].darkSquare} 50%, \n                  ${themes[themeKey].darkSquare} 100%)`\n              }}\n            ></div>\n            <span className=\"theme-name\">{themes[themeKey].name}</span>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default ThemeSelector; ","// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n  \n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };\n    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };\n  }\n  \n  // Set up rooks\n  board[0][0] = { type: 'rook', color: 'black', hasMoved: false };\n  board[0][7] = { type: 'rook', color: 'black', hasMoved: false };\n  board[7][0] = { type: 'rook', color: 'white', hasMoved: false };\n  board[7][7] = { type: 'rook', color: 'white', hasMoved: false };\n  \n  // Set up knights\n  board[0][1] = { type: 'knight', color: 'black', hasMoved: false };\n  board[0][6] = { type: 'knight', color: 'black', hasMoved: false };\n  board[7][1] = { type: 'knight', color: 'white', hasMoved: false };\n  board[7][6] = { type: 'knight', color: 'white', hasMoved: false };\n  \n  // Set up bishops\n  board[0][2] = { type: 'bishop', color: 'black', hasMoved: false };\n  board[0][5] = { type: 'bishop', color: 'black', hasMoved: false };\n  board[7][2] = { type: 'bishop', color: 'white', hasMoved: false };\n  board[7][5] = { type: 'bishop', color: 'white', hasMoved: false };\n  \n  // Set up queens\n  board[0][3] = { type: 'queen', color: 'black', hasMoved: false };\n  board[7][3] = { type: 'queen', color: 'white', hasMoved: false };\n  \n  // Set up kings\n  board[0][4] = { type: 'king', color: 'black', hasMoved: false };\n  board[7][4] = { type: 'king', color: 'white', hasMoved: false };\n  \n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = (board) => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return { row, col };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row + pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row + pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from knights\n  const knightMoves = [\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n    [1, -2], [1, 2], [2, -1], [2, 1]\n  ];\n  \n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    \n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from bishops, rooks, and queens\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1], [0, -1],\n    [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n  \n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    \n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      \n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' ||\n              (piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir)) ||\n              (piece.type === 'rook' && (rowDir === 0 || colDir === 0))) {\n            return true;\n          }\n          \n          // King can attack adjacent squares\n          if (piece.type === 'king' && \n              Math.abs(newRow - row) <= 1 && \n              Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      \n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  \n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  \n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\n// eslint-disable-next-line no-unused-vars\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  // Check if the coordinates are valid\n  if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||\n      toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {\n    return false;\n  }\n  \n  // Check if there is a piece at the starting position\n  const piece = board[fromRow][fromCol];\n  if (!piece) {\n    return false;\n  }\n  \n  // Check if the destination has a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) {\n    return false;\n  }\n  \n  // Check piece-specific movement rules\n  let isValid = false;\n  \n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n  \n  // If the move is valid according to piece rules, check if it would leave the king in check\n  if (isValid) {\n    // Make a temporary move\n    const tempBoard = cloneBoard(board);\n    tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];\n    tempBoard[fromRow][fromCol] = null;\n    \n    // Check if the king is in check after the move\n    const kingInCheck = isInCheck(tempBoard, piece.color);\n    \n    // If the king is in check, the move is not valid\n    if (kingInCheck) {\n      return false;\n    }\n  }\n  \n  return isValid;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  \n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Moving forward two squares from starting position\n  if (fromCol === toCol && \n      ((piece.color === 'white' && fromRow === 6) || (piece.color === 'black' && fromRow === 1)) && \n      toRow === fromRow + 2 * direction &&\n      !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n    \n    // En passant capture\n    if (!board[toRow][toCol] && gameState && gameState.enPassantTarget &&\n        toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  \n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  \n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  \n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  if (rowDiff !== colDiff) return false;\n  \n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  \n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  \n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  \n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n  \n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Check if a pawn can be promoted\nexport const isPawnPromotion = (piece, toRow) => {\n  if (!piece || piece.type !== 'pawn') return false;\n  \n  // White pawns promote on row 0, black pawns on row 7\n  return (piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7);\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece = null) => {\n  // Create a deep copy of the board and game state\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const newGameState = JSON.parse(JSON.stringify(gameState || { enPassantTarget: null, castlingRights: { white: { kingSide: true, queenSide: true }, black: { kingSide: true, queenSide: true } } }));\n  \n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n  let capturedPiece = targetPiece;\n  \n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[toRow][toCol - 1] = newBoard[toRow][7]; // Move rook\n      newBoard[toRow][toCol - 1].hasMoved = true; // Mark rook as moved\n      newBoard[toRow][7] = null; // Remove rook from original position\n    } \n    // Queenside castling\n    else {\n      newBoard[toRow][toCol + 1] = newBoard[toRow][0]; // Move rook\n      newBoard[toRow][toCol + 1].hasMoved = true; // Mark rook as moved\n      newBoard[toRow][0] = null; // Remove rook from original position\n    }\n  }\n  \n  // Handle en passant capture\n  if (piece.type === 'pawn' && fromCol !== toCol && !targetPiece) {\n    // This is a diagonal move without a target piece, must be en passant\n    const captureRow = fromRow; // The pawn to be captured is on the same row as the moving pawn\n    capturedPiece = newBoard[captureRow][toCol]; // Store the captured pawn\n    newBoard[captureRow][toCol] = null; // Capture the pawn that just moved\n  }\n  \n  // Update en passant target\n  newGameState.enPassantTarget = null;\n  if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {\n    const direction = piece.color === 'white' ? -1 : 1;\n    newGameState.enPassantTarget = { row: fromRow + direction, col: fromCol };\n  }\n  \n  // Update castling rights\n  if (piece.type === 'king') {\n    newGameState.castlingRights[piece.color].kingSide = false;\n    newGameState.castlingRights[piece.color].queenSide = false;\n  } else if (piece.type === 'rook') {\n    if (fromRow === 7 && fromCol === 0 && piece.color === 'white') {\n      newGameState.castlingRights.white.queenSide = false;\n    } else if (fromRow === 7 && fromCol === 7 && piece.color === 'white') {\n      newGameState.castlingRights.white.kingSide = false;\n    } else if (fromRow === 0 && fromCol === 0 && piece.color === 'black') {\n      newGameState.castlingRights.black.queenSide = false;\n    } else if (fromRow === 0 && fromCol === 7 && piece.color === 'black') {\n      newGameState.castlingRights.black.kingSide = false;\n    }\n  }\n  \n  // Handle pawn promotion\n  if (piece.type === 'pawn' && isPawnPromotion(piece, toRow) && promotionPiece) {\n    // Create a new piece of the specified type\n    newBoard[toRow][toCol] = { type: promotionPiece, color: piece.color, hasMoved: true };\n  } else {\n    // Regular move\n    newBoard[toRow][toCol] = piece;\n    newBoard[toRow][toCol].hasMoved = true; // Mark the piece as moved\n  }\n  \n  // Remove the piece from its original position\n  newBoard[fromRow][fromCol] = null;\n  \n  return { board: newBoard, gameState: newGameState, capturedPiece };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color, gameState = {}) => {\n  // If not in check, can't be checkmate\n  if (!isInCheck(board, color)) return false;\n  \n  // Check if any move can get out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            // Check if this is a valid move that gets the king out of check\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // Make a temporary move\n              const tempBoard = cloneBoard(board);\n              tempBoard[toRow][toCol] = tempBoard[fromRow][fromCol];\n              tempBoard[fromRow][fromCol] = null;\n              \n              // If this move gets the king out of check, it's not checkmate\n              if (!isInCheck(tempBoard, color)) {\n                return false;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // If no move can get the king out of check, it's checkmate\n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color, gameState = {}) => {\n  // If in check, it's not stalemate\n  if (isInCheck(board, color)) return false;\n  \n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // If any legal move exists, it's not stalemate\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  // If no legal move exists and the king is not in check, it's stalemate\n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = (board) => {\n  let score = 0;\n  \n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n        \n        // Add positional bonuses\n        let positionalValue = 0;\n        \n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n          \n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n        \n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n        \n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          \n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            \n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          \n          positionalValue += diagonalMoves * 0.05;\n        }\n        \n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && \n                board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          \n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n        \n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(\n            Math.abs(0 - row) + Math.abs(0 - col),\n            Math.abs(0 - row) + Math.abs(7 - col),\n            Math.abs(7 - row) + Math.abs(0 - col),\n            Math.abs(7 - row) + Math.abs(7 - col)\n          );\n          \n          positionalValue += centerDistance * 0.1;\n        }\n        \n        const totalValue = value + positionalValue;\n        \n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n  \n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black')) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white')) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black')) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white')) {\n      score -= 0.5; // White is in check\n    }\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({ fromRow, fromCol, toRow, toCol });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n  \n  // Check for terminal states\n  if (isCheckmate(board, 'white')) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black')) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return 0; // Draw\n  }\n  \n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  \n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  \n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    \n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    \n    if ((isMaximizing && value > bestValue) || (!isMaximizing && value < bestValue)) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}; ","import { \n  // eslint-disable-next-line no-unused-vars\n  makeMove, \n  isValidMove, \n  // eslint-disable-next-line no-unused-vars\n  isInCheck, \n  // eslint-disable-next-line no-unused-vars\n  isCheckmate, \n  // eslint-disable-next-line no-unused-vars\n  isStalemate \n} from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  'knight': [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  'bishop': [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  'rook': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  'queen': [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  'king': [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Memoization cache for position evaluation\nconst evaluationCache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (evaluationCache.size > MAX_CACHE_SIZE) {\n    // Clear the entire cache for simplicity and performance\n    evaluationCache.clear();\n  }\n};\n\n// Get a simple hash for the board position\nconst getBoardHash = (board) => {\n  let hash = '';\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        hash += `${row}${col}${piece.type[0]}${piece.color[0]}`;\n      }\n    }\n  }\n  return hash;\n};\n\n// Evaluate a single move\nconst evaluateMove = (board, move, gameState) => {\n  const { fromRow, fromCol, toRow, toCol } = move;\n  const piece = board[fromRow][fromCol];\n  const targetPiece = board[toRow][toCol];\n  \n  let score = 0;\n  \n  // Capture value\n  if (targetPiece) {\n    score += pieceValues[targetPiece.type] * 2; // Prioritize captures\n  }\n  \n  // Position improvement\n  const currentPositionValue = positionBonus[piece.type][piece.color === 'white' ? fromRow : 7 - fromRow][fromCol];\n  const newPositionValue = positionBonus[piece.type][piece.color === 'white' ? toRow : 7 - toRow][toCol];\n  score += (newPositionValue - currentPositionValue) * 0.5;\n  \n  // Center control bonus\n  const centerDistance = Math.abs(3.5 - toRow) + Math.abs(3.5 - toCol);\n  score += (7 - centerDistance) * 0.2;\n  \n  // Pawn advancement bonus\n  if (piece.type === 'pawn') {\n    const advancementBonus = piece.color === 'white' ? (7 - toRow) : toRow;\n    score += advancementBonus * 0.5;\n    \n    // Bonus for pawns near promotion\n    if ((piece.color === 'white' && toRow <= 1) || (piece.color === 'black' && toRow >= 6)) {\n      score += 5;\n    }\n  }\n  \n  // Avoid moving the king early in the game\n  if (piece.type === 'king') {\n    score -= 2;\n  }\n  \n  // Encourage development of knights and bishops early\n  if ((piece.type === 'knight' || piece.type === 'bishop') && \n      ((piece.color === 'white' && fromRow === 7) || (piece.color === 'black' && fromRow === 0))) {\n    score += 1;\n  }\n  \n  return score;\n};\n\n// Knight move offsets for faster move generation\nconst knightOffsets = [\n  [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n  [1, -2], [1, 2], [2, -1], [2, 1]\n];\n\n// Directional offsets for sliding pieces (bishop, rook, queen)\nconst directions = {\n  bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],\n  rook: [[-1, 0], [0, -1], [0, 1], [1, 0]],\n  queen: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n};\n\n// Generate moves for a specific piece - optimized for speed\nconst generatePieceMoves = (board, row, col, gameState) => {\n  const piece = board[row][col];\n  if (!piece) return [];\n  \n  const moves = [];\n  \n  switch (piece.type) {\n    case 'pawn': {\n      const direction = piece.color === 'white' ? -1 : 1;\n      \n      // Move forward one square\n      if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {\n        moves.push({ fromRow: row, fromCol: col, toRow: row + direction, toCol: col, isCapture: false });\n        \n        // Move forward two squares from starting position\n        if (!piece.hasMoved && \n            row + 2 * direction >= 0 && row + 2 * direction < 8 && \n            !board[row + direction][col] && !board[row + 2 * direction][col]) {\n          moves.push({ fromRow: row, fromCol: col, toRow: row + 2 * direction, toCol: col, isCapture: false });\n        }\n      }\n      \n      // Capture diagonally\n      for (const colOffset of [-1, 1]) {\n        if (col + colOffset >= 0 && col + colOffset < 8 && row + direction >= 0 && row + direction < 8) {\n          // Normal capture\n          if (board[row + direction][col + colOffset] && \n              board[row + direction][col + colOffset].color !== piece.color) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: row + direction, \n              toCol: col + colOffset, \n              isCapture: true \n            });\n          }\n          \n          // En passant capture\n          if (!board[row + direction][col + colOffset] && gameState.enPassantTarget &&\n              row + direction === gameState.enPassantTarget.row && \n              col + colOffset === gameState.enPassantTarget.col) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: row + direction, \n              toCol: col + colOffset, \n              isCapture: true,\n              isEnPassant: true\n            });\n          }\n        }\n      }\n      break;\n    }\n    \n    case 'knight': {\n      for (const [rowOffset, colOffset] of knightOffsets) {\n        const newRow = row + rowOffset;\n        const newCol = col + colOffset;\n        \n        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n          const targetPiece = board[newRow][newCol];\n          if (!targetPiece || targetPiece.color !== piece.color) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: newRow, \n              toCol: newCol, \n              isCapture: !!targetPiece \n            });\n          }\n        }\n      }\n      break;\n    }\n    \n    case 'bishop':\n    case 'rook':\n    case 'queen': {\n      const dirs = directions[piece.type];\n      \n      for (const [rowDir, colDir] of dirs) {\n        let newRow = row + rowDir;\n        let newCol = col + colDir;\n        \n        while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n          const targetPiece = board[newRow][newCol];\n          \n          if (!targetPiece) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: newRow, \n              toCol: newCol, \n              isCapture: false \n            });\n          } else {\n            if (targetPiece.color !== piece.color) {\n              moves.push({ \n                fromRow: row, \n                fromCol: col, \n                toRow: newRow, \n                toCol: newCol, \n                isCapture: true \n              });\n            }\n            break; // Stop in this direction after hitting a piece\n          }\n          \n          newRow += rowDir;\n          newCol += colDir;\n        }\n      }\n      break;\n    }\n    \n    case 'king': {\n      // Regular king moves\n      for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {\n        for (let colOffset = -1; colOffset <= 1; colOffset++) {\n          if (rowOffset === 0 && colOffset === 0) continue;\n          \n          const newRow = row + rowOffset;\n          const newCol = col + colOffset;\n          \n          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = board[newRow][newCol];\n            if (!targetPiece || targetPiece.color !== piece.color) {\n              moves.push({ \n                fromRow: row, \n                fromCol: col, \n                toRow: newRow, \n                toCol: newCol, \n                isCapture: !!targetPiece \n              });\n            }\n          }\n        }\n      }\n      \n      // Castling\n      if (!piece.hasMoved && gameState.castlingRights) {\n        const castlingRights = gameState.castlingRights[piece.color];\n        \n        // Kingside castling\n        if (castlingRights && castlingRights.kingSide && \n            !board[row][col + 1] && !board[row][col + 2] &&\n            board[row][col + 3] && board[row][col + 3].type === 'rook' && \n            !board[row][col + 3].hasMoved) {\n          moves.push({ \n            fromRow: row, \n            fromCol: col, \n            toRow: row, \n            toCol: col + 2, \n            isCapture: false,\n            isCastling: true,\n            castlingSide: 'kingside'\n          });\n        }\n        \n        // Queenside castling\n        if (castlingRights && castlingRights.queenSide && \n            !board[row][col - 1] && !board[row][col - 2] && !board[row][col - 3] &&\n            board[row][col - 4] && board[row][col - 4].type === 'rook' && \n            !board[row][col - 4].hasMoved) {\n          moves.push({ \n            fromRow: row, \n            fromCol: col, \n            toRow: row, \n            toCol: col - 2, \n            isCapture: false,\n            isCastling: true,\n            castlingSide: 'queenside'\n          });\n        }\n      }\n      break;\n    }\n    \n    default:\n      // No moves for unknown piece types\n      break;\n  }\n  \n  return moves;\n};\n\n// Generate all valid moves for a player - optimized version\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  const candidateMoves = [];\n  \n  // First, collect all candidate moves without checking if they're valid\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.color === color) {\n        const pieceMoves = generatePieceMoves(board, row, col, gameState);\n        candidateMoves.push(...pieceMoves);\n      }\n    }\n  }\n  \n  // Then filter out moves that would leave the king in check\n  for (const move of candidateMoves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n      moves.push(move);\n    }\n  }\n  \n  return moves;\n};\n\n// Find the best move using a simple greedy algorithm\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  try {\n    // Generate all valid moves\n    let moves = generateMoves(board, color, gameState);\n    \n    // If no valid moves, return null\n    if (!moves || moves.length === 0) {\n      return null;\n    }\n    \n    // If only one move is available, return it immediately\n    if (moves.length === 1) {\n      return moves[0];\n    }\n    \n    // Add randomness based on difficulty\n    const randomChance = difficulty === 'easy' ? 0.4 : (difficulty === 'medium' ? 0.2 : 0.05);\n    if (Math.random() < randomChance) {\n      const randomIndex = Math.floor(Math.random() * moves.length);\n      return moves[randomIndex];\n    }\n    \n    // Check if we have this position cached\n    const boardHash = getBoardHash(board);\n    const cacheKey = `${boardHash}-${color}-${difficulty}`;\n    \n    if (evaluationCache.has(cacheKey)) {\n      return evaluationCache.get(cacheKey);\n    }\n    \n    // Limit the number of moves to evaluate for performance\n    const MAX_MOVES_TO_EVALUATE = 20;\n    if (moves.length > MAX_MOVES_TO_EVALUATE) {\n      // Randomly select a subset of moves to evaluate\n      moves = moves.sort(() => 0.5 - Math.random()).slice(0, MAX_MOVES_TO_EVALUATE);\n    }\n    \n    // Evaluate each move\n    const evaluatedMoves = moves.map(move => {\n      try {\n        const score = evaluateMove(board, move, gameState);\n        return { ...move, score };\n      } catch (error) {\n        console.error(\"Error evaluating move:\", error);\n        return { ...move, score: 0 }; // Assign neutral score on error\n      }\n    });\n    \n    // Sort moves by score (descending for white, ascending for black)\n    evaluatedMoves.sort((a, b) => {\n      return color === 'white' ? b.score - a.score : a.score - b.score;\n    });\n    \n    // Add some randomness to the top moves based on difficulty\n    const topMovesCount = difficulty === 'easy' ? 5 : (difficulty === 'medium' ? 3 : 2);\n    const topMoves = evaluatedMoves.slice(0, Math.min(topMovesCount, evaluatedMoves.length));\n    \n    // Select a random move from the top moves\n    const selectedIndex = Math.floor(Math.random() * topMoves.length);\n    const bestMove = topMoves[selectedIndex];\n    \n    // Cache the result\n    evaluationCache.set(cacheKey, bestMove);\n    checkCacheSize();\n    \n    return bestMove;\n  } catch (error) {\n    console.error(\"Error finding best move:\", error);\n    // If there's an error, try to return a random valid move\n    try {\n      const allMoves = [];\n      for (let fromRow = 0; fromRow < 8; fromRow++) {\n        for (let fromCol = 0; fromCol < 8; fromCol++) {\n          const piece = board[fromRow][fromCol];\n          if (piece && piece.color === color) {\n            for (let toRow = 0; toRow < 8; toRow++) {\n              for (let toCol = 0; toCol < 8; toCol++) {\n                if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n                  allMoves.push({ fromRow, fromCol, toRow, toCol });\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      if (allMoves.length > 0) {\n        return allMoves[Math.floor(Math.random() * allMoves.length)];\n      }\n    } catch (fallbackError) {\n      console.error(\"Error in fallback move generation:\", fallbackError);\n    }\n    \n    return null;\n  }\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  try {\n    // Add a maximum execution time check\n    const startTime = Date.now();\n    const MAX_EXECUTION_TIME = 2000; // 2 seconds max\n    \n    // Simplify difficulty for faster processing if needed\n    let effectiveDifficulty = difficulty;\n    if (difficulty === 'hard' && board.flat().filter(Boolean).length > 20) {\n      // Use medium difficulty for complex positions with many pieces\n      effectiveDifficulty = 'medium';\n    }\n    \n    // Get the best move with timeout protection\n    const bestMove = findBestMove(board, color, gameState, effectiveDifficulty);\n    \n    // Check if we've exceeded our time budget\n    if (Date.now() - startTime > MAX_EXECUTION_TIME) {\n      console.warn(\"AI move calculation took too long, returning a simpler move\");\n      // Fall back to a simple random move from valid moves\n      const moves = [];\n      for (let fromRow = 0; fromRow < 8; fromRow++) {\n        for (let fromCol = 0; fromCol < 8; fromCol++) {\n          const piece = board[fromRow][fromCol];\n          if (piece && piece.color === color) {\n            for (let toRow = 0; toRow < 8; toRow++) {\n              for (let toCol = 0; toCol < 8; toCol++) {\n                if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n                  moves.push({ fromRow, fromCol, toRow, toCol });\n                }\n              }\n            }\n          }\n        }\n      }\n      \n      if (moves.length > 0) {\n        return moves[Math.floor(Math.random() * moves.length)];\n      }\n    }\n    \n    return bestMove;\n  } catch (error) {\n    console.error(\"Error in AI move calculation:\", error);\n    // Return null to indicate no move found\n    return null;\n  }\n}; ","import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';\nimport './App.css';\nimport ChessBoard from './components/ChessBoard';\nimport GameInfo from './components/GameInfo';\nimport PromotionDialog from './components/PromotionDialog';\nimport ThemeSelector from './components/ThemeSelector';\nimport themes from './themes';\nimport { \n  initializeBoard, \n  isValidMove, \n  makeMove, \n  isInCheck, \n  isCheckmate, \n  isStalemate,\n  isPawnPromotion\n} from './utils/chessLogic';\nimport { getAIMove } from './utils/aiPlayer';\n\n// eslint-disable-next-line no-unused-vars\nfunction App() {\n  const [board, setBoard] = useState(initializeBoard());\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [playerTurn, setPlayerTurn] = useState('white');\n  const [gameStatus, setGameStatus] = useState('ongoing');\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [gameState, setGameState] = useState({\n    enPassantTarget: null,\n    castlingRights: {\n      white: { kingSide: true, queenSide: true },\n      black: { kingSide: true, queenSide: true }\n    }\n  });\n  const [highlightedSquares, setHighlightedSquares] = useState([]);\n  const [checkIndicator, setCheckIndicator] = useState(null);\n  const [aiDifficulty, setAiDifficulty] = useState('medium'); // 'easy', 'medium', 'hard'\n  const [showHint, setShowHint] = useState(false);\n  const [hintMove, setHintMove] = useState(null);\n  const [promotionDialog, setPromotionDialog] = useState(null);\n  const [currentTheme, setCurrentTheme] = useState('classic');\n  const [aiThinking, setAiThinking] = useState(false);\n\n  // Create a ref to store the handleMove function\n  const handleMoveRef = useRef(null);\n\n  // Generate algebraic notation for a move\n  const generateMoveNotation = useCallback((piece, fromRow, fromCol, toRow, toCol, capturedPiece, promotionPiece) => {\n    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];\n    \n    let notation = '';\n    \n    // Add piece letter (except for pawns)\n    if (piece.type !== 'pawn') {\n      notation += piece.type.charAt(0).toUpperCase();\n    }\n    \n    // Add starting position for pawns if capturing\n    if (piece.type === 'pawn' && capturedPiece) {\n      notation += files[fromCol];\n    }\n    \n    // Add 'x' if capturing\n    if (capturedPiece) {\n      notation += 'x';\n    }\n    \n    // Add destination square\n    notation += files[toCol] + ranks[toRow];\n    \n    // Add promotion piece\n    if (promotionPiece) {\n      notation += '=' + promotionPiece.charAt(0).toUpperCase();\n    }\n    \n    return notation;\n  }, []);\n\n  // Handle move\n  const handleMove = useCallback((fromRow, fromCol, toRow, toCol, promotionPiece = null) => {\n    // Get the piece before making the move\n    const piece = board[fromRow][fromCol];\n    \n    // Make the move\n    const { board: newBoard, gameState: newGameState, capturedPiece } = makeMove(\n      board, \n      fromRow, \n      fromCol, \n      toRow, \n      toCol, \n      gameState,\n      promotionPiece\n    );\n    \n    // Update the board and game state\n    setBoard(newBoard);\n    setGameState(newGameState);\n    \n    // Generate notation for the move\n    const notation = generateMoveNotation(piece, fromRow, fromCol, toRow, toCol, capturedPiece, promotionPiece);\n    \n    // Add move to history\n    const newMove = {\n      from: { row: fromRow, col: fromCol },\n      to: { row: toRow, col: toCol },\n      piece,\n      capturedPiece,\n      notation,\n      color: piece.color\n    };\n    \n    setMoveHistory(prevHistory => [...prevHistory, newMove]);\n    \n    // Switch turns\n    setPlayerTurn(prevTurn => prevTurn === 'white' ? 'black' : 'white');\n    \n    // Clear selection and highlights\n    setSelectedPiece(null);\n    setHighlightedSquares([]);\n    setShowHint(false);\n    setHintMove(null);\n  }, [board, gameState, generateMoveNotation]);\n\n  // Update the ref whenever handleMove changes\n  useEffect(() => {\n    handleMoveRef.current = handleMove;\n  }, [handleMove]);\n\n  // Make AI move - optimized version\n  const makeAIMove = useCallback(() => {\n    if (playerTurn === 'black' && gameStatus === 'ongoing' && !aiThinking) {\n      setAiThinking(true);\n      \n      // Add a small delay before starting AI calculation to ensure UI updates\n      setTimeout(() => {\n        try {\n          // Get AI move with a timeout to prevent infinite calculations\n          const aiMove = getAIMove(board, 'black', gameState, aiDifficulty);\n          \n          if (aiMove) {\n            const { fromRow, fromCol, toRow, toCol } = aiMove;\n            const piece = board[fromRow][fromCol];\n            \n            // Check if this is a pawn promotion\n            if (isPawnPromotion(piece, toRow)) {\n              // AI always promotes to queen\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol, 'queen');\n            } else {\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol);\n            }\n          } else {\n            // If no move found, try a random move\n            const moves = [];\n            for (let fromRow = 0; fromRow < 8; fromRow++) {\n              for (let fromCol = 0; fromCol < 8; fromCol++) {\n                const piece = board[fromRow][fromCol];\n                if (piece && piece.color === 'black') {\n                  for (let toRow = 0; toRow < 8; toRow++) {\n                    for (let toCol = 0; toCol < 8; toCol++) {\n                      if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n                        moves.push({ fromRow, fromCol, toRow, toCol });\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            \n            if (moves.length > 0) {\n              const randomMove = moves[Math.floor(Math.random() * moves.length)];\n              const { fromRow, fromCol, toRow, toCol } = randomMove;\n              handleMoveRef.current(fromRow, fromCol, toRow, toCol);\n            }\n          }\n        } catch (error) {\n          console.error(\"Error in AI move calculation:\", error);\n        } finally {\n          // Always set aiThinking to false when done, even if there was an error\n          setAiThinking(false);\n        }\n      }, 300); // Add a 300ms delay to ensure UI updates before AI calculation\n    }\n  }, [board, playerTurn, gameStatus, gameState, aiDifficulty, aiThinking]);\n\n  // AI makes a move when it's black's turn - with debounce protection\n  useEffect(() => {\n    let timeoutId = null;\n    \n    if (playerTurn === 'black' && gameStatus === 'ongoing' && !aiThinking) {\n      // Use a timeout to debounce multiple calls\n      timeoutId = setTimeout(() => {\n        makeAIMove();\n      }, 500);\n    }\n    \n    // Cleanup function to clear the timeout if component updates before timeout completes\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }, [playerTurn, gameStatus, makeAIMove, aiThinking]);\n\n  // Check for check, checkmate, or stalemate after each move\n  useEffect(() => {\n    if (moveHistory.length > 0) {\n      // Check if any king is in check\n      const whiteInCheck = isInCheck(board, 'white');\n      const blackInCheck = isInCheck(board, 'black');\n      \n      if (whiteInCheck) {\n        setCheckIndicator('white');\n        \n        // Check if it's checkmate\n        if (isCheckmate(board, 'white', gameState)) {\n          setGameStatus('Checkmate! Black wins.');\n        }\n      } else if (blackInCheck) {\n        setCheckIndicator('black');\n        \n        // Check if it's checkmate\n        if (isCheckmate(board, 'black', gameState)) {\n          setGameStatus('Checkmate! White wins.');\n        }\n      } else {\n        setCheckIndicator(null);\n      }\n      \n      // Check for stalemate\n      if (playerTurn === 'white' && isStalemate(board, 'white', gameState)) {\n        setGameStatus('Draw by stalemate');\n      } else if (playerTurn === 'black' && isStalemate(board, 'black', gameState)) {\n        setGameStatus('Draw by stalemate');\n      }\n    }\n  }, [board, playerTurn, moveHistory, gameState]);\n\n  // Calculate valid moves for the selected piece - memoized\n  const validMoves = useMemo(() => {\n    if (!selectedPiece) return [];\n    \n    const moves = [];\n    for (let row = 0; row < 8; row++) {\n      for (let col = 0; col < 8; col++) {\n        if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n          moves.push({ row, col });\n        }\n      }\n    }\n    return moves;\n  }, [selectedPiece, board, gameState]);\n\n  // Update highlighted squares when valid moves change\n  useEffect(() => {\n    setHighlightedSquares(validMoves);\n  }, [validMoves]);\n\n  // eslint-disable-next-line no-unused-vars\n  const getPieceSymbol = useCallback((pieceType) => {\n    switch (pieceType) {\n      case 'pawn': return '';\n      case 'knight': return 'N';\n      case 'bishop': return 'B';\n      case 'rook': return 'R';\n      case 'queen': return 'Q';\n      case 'king': return 'K';\n      default: return '';\n    }\n  }, []);\n\n  const handleSquareClick = useCallback((row, col) => {\n    // If game is over or promotion dialog is open, don't allow any moves\n    if (gameStatus !== 'ongoing' || promotionDialog) return;\n    \n    // If it's not the player's turn, don't allow any moves\n    if (playerTurn !== 'white') return;\n    \n    const piece = board[row][col];\n    \n    // If a piece is already selected\n    if (selectedPiece) {\n      // If clicking on the same piece, deselect it\n      if (selectedPiece.row === row && selectedPiece.col === col) {\n        setSelectedPiece(null);\n        return;\n      }\n      \n      // If clicking on a different piece of the same color, select that piece instead\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n        return;\n      }\n      \n      // Try to make a move\n      if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n        // Check if this is a pawn promotion\n        if (isPawnPromotion(selectedPiece.piece, row)) {\n          // Show promotion dialog\n          const boardRect = document.querySelector('.chess-board').getBoundingClientRect();\n          const squareSize = boardRect.width / 8;\n          \n          setPromotionDialog({\n            fromRow: selectedPiece.row,\n            fromCol: selectedPiece.col,\n            toRow: row,\n            toCol: col,\n            position: {\n              x: boardRect.left + col * squareSize + squareSize / 2,\n              y: boardRect.top + row * squareSize + squareSize / 2\n            }\n          });\n          return;\n        }\n        \n        // Regular move\n        handleMove(selectedPiece.row, selectedPiece.col, row, col);\n      }\n    } else {\n      // If no piece is selected and clicked on a piece of the player's color, select it\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n      }\n    }\n  }, [board, gameState, gameStatus, handleMove, playerTurn, promotionDialog, selectedPiece]);\n\n  const handlePromotion = useCallback((pieceType) => {\n    if (!promotionDialog) return;\n    \n    const { fromRow, fromCol, toRow, toCol } = promotionDialog;\n    \n    // Make the move with promotion\n    handleMove(fromRow, fromCol, toRow, toCol, pieceType);\n    setPromotionDialog(null);\n  }, [handleMove, promotionDialog]);\n\n  const resetGame = useCallback(() => {\n    setBoard(initializeBoard());\n    setSelectedPiece(null);\n    setPlayerTurn('white');\n    setGameStatus('ongoing');\n    setMoveHistory([]);\n    setGameState({\n      enPassantTarget: null,\n      castlingRights: {\n        white: { kingSide: true, queenSide: true },\n        black: { kingSide: true, queenSide: true }\n      }\n    });\n    setHighlightedSquares([]);\n    setCheckIndicator(null);\n    setShowHint(false);\n    setHintMove(null);\n    setPromotionDialog(null);\n  }, []);\n\n  const handleDifficultyChange = useCallback((difficulty) => {\n    setAiDifficulty(difficulty);\n    resetGame();\n  }, [resetGame]);\n\n  const getHint = useCallback(() => {\n    // Use the AI to suggest a move for the player\n    if (playerTurn === 'white' && gameStatus === 'ongoing') {\n      const suggestedMove = getAIMove(board, 'white', gameState, 2);\n      if (suggestedMove) {\n        setShowHint(true);\n        setHintMove(suggestedMove);\n      }\n    }\n  }, [board, gameState, gameStatus, playerTurn]);\n\n  // Handle theme change\n  const handleThemeChange = useCallback((themeKey) => {\n    setCurrentTheme(themeKey);\n    // Save theme preference to localStorage\n    localStorage.setItem('chessTheme', themeKey);\n  }, []);\n\n  // Load saved theme from localStorage on initial render\n  useEffect(() => {\n    const savedTheme = localStorage.getItem('chessTheme');\n    if (savedTheme && themes[savedTheme]) {\n      setCurrentTheme(savedTheme);\n    }\n  }, []);\n\n  // Memoize the last move for better performance\n  const lastMove = useMemo(() => {\n    return moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null;\n  }, [moveHistory]);\n\n  // Memoize the current theme object\n  const currentThemeObject = useMemo(() => themes[currentTheme], [currentTheme]);\n\n  return (\n    <div className=\"app\">\n      <div className=\"app-header\">\n        <h1>AI Chess</h1>\n        <div className=\"author-credits\">\n          <span>Created by Aditya Thakkar</span>\n        </div>\n      </div>\n      <div className=\"difficulty-selector\">\n        <span className=\"difficulty-label\">AI Difficulty:</span>\n        <div className=\"difficulty-buttons\">\n          <button \n            className={`difficulty-button ${aiDifficulty === 'easy' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('easy')}\n          >\n            Easy\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'medium' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('medium')}\n          >\n            Medium\n          </button>\n          <button \n            className={`difficulty-button ${aiDifficulty === 'hard' ? 'active' : ''}`}\n            onClick={() => handleDifficultyChange('hard')}\n          >\n            Hard\n          </button>\n        </div>\n      </div>\n      <ThemeSelector \n        currentTheme={currentTheme} \n        onThemeChange={handleThemeChange} \n      />\n      <div className=\"game-container\">\n        <ChessBoard \n          board={board} \n          selectedPiece={selectedPiece} \n          onSquareClick={handleSquareClick}\n          highlightedSquares={highlightedSquares}\n          checkIndicator={checkIndicator}\n          lastMove={lastMove}\n          hintMove={showHint ? hintMove : null}\n          theme={currentThemeObject}\n        />\n        <GameInfo \n          playerTurn={playerTurn} \n          gameStatus={gameStatus} \n          moveHistory={moveHistory} \n          onResetGame={resetGame} \n          isInCheck={checkIndicator !== null}\n          aiDifficulty={aiDifficulty}\n          onGetHint={getHint}\n          aiThinking={aiThinking}\n        />\n      </div>\n      {promotionDialog && (\n        <PromotionDialog \n          position={promotionDialog.position}\n          color=\"white\"\n          onSelect={handlePromotion}\n          onCancel={() => setPromotionDialog(null)}\n        />\n      )}\n      <div className=\"app-footer\">\n        <div className=\"footer-content\">\n          <p>Chess AI with Minimax Algorithm & Alpha-Beta Pruning</p>\n          <p>© {new Date().getFullYear()} AI Chess by Aditya Thakkar</p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App; \n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n); "],"sourceRoot":""}