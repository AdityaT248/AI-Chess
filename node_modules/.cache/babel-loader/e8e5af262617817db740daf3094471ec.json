{"ast":null,"code":"// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n\n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = {\n      type: 'pawn',\n      color: 'black',\n      hasMoved: false\n    };\n    board[6][col] = {\n      type: 'pawn',\n      color: 'white',\n      hasMoved: false\n    };\n  }\n\n  // Set up rooks\n  board[0][0] = {\n    type: 'rook',\n    color: 'black',\n    hasMoved: false\n  };\n  board[0][7] = {\n    type: 'rook',\n    color: 'black',\n    hasMoved: false\n  };\n  board[7][0] = {\n    type: 'rook',\n    color: 'white',\n    hasMoved: false\n  };\n  board[7][7] = {\n    type: 'rook',\n    color: 'white',\n    hasMoved: false\n  };\n\n  // Set up knights\n  board[0][1] = {\n    type: 'knight',\n    color: 'black'\n  };\n  board[0][6] = {\n    type: 'knight',\n    color: 'black'\n  };\n  board[7][1] = {\n    type: 'knight',\n    color: 'white'\n  };\n  board[7][6] = {\n    type: 'knight',\n    color: 'white'\n  };\n\n  // Set up bishops\n  board[0][2] = {\n    type: 'bishop',\n    color: 'black'\n  };\n  board[0][5] = {\n    type: 'bishop',\n    color: 'black'\n  };\n  board[7][2] = {\n    type: 'bishop',\n    color: 'white'\n  };\n  board[7][5] = {\n    type: 'bishop',\n    color: 'white'\n  };\n\n  // Set up queens\n  board[0][3] = {\n    type: 'queen',\n    color: 'black'\n  };\n  board[7][3] = {\n    type: 'queen',\n    color: 'white'\n  };\n\n  // Set up kings\n  board[0][4] = {\n    type: 'king',\n    color: 'black',\n    hasMoved: false\n  };\n  board[7][4] = {\n    type: 'king',\n    color: 'white',\n    hasMoved: false\n  };\n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = board => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row + pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row + pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n\n  // Check attacks from knights\n  const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n\n  // Check attacks from bishops, rooks, and queens\n  const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' || piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir) || piece.type === 'rook' && (rowDir === 0 || colDir === 0)) {\n            return true;\n          }\n\n          // King can attack adjacent squares\n          if (piece.type === 'king' && Math.abs(newRow - row) <= 1 && Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n\n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  if (!piece) return false;\n\n  // Can't move to a square with a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) return false;\n  let isValid = false;\n\n  // Check if the move is valid based on piece type\n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n\n  // If the move is valid by piece rules, check if it would leave the king in check\n  if (isValid && !wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, piece.color)) {\n    return true;\n  }\n  return false;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n\n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n\n  // Moving forward two squares from starting position\n  if (fromCol === toCol && !piece.hasMoved && toRow === fromRow + 2 * direction && !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n\n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n\n    // En passant capture\n    if (!board[toRow][toCol] && gameState.enPassantTarget && toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n\n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  return rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2;\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  if (rowDiff !== colDiff) return false;\n\n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n\n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n\n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n\n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) && !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) && !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const newBoard = cloneBoard(board);\n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n  const newGameState = {\n    ...gameState\n  };\n\n  // Reset en passant target\n  newGameState.enPassantTarget = null;\n\n  // Handle special moves\n  if (piece.type === 'pawn') {\n    // En passant capture\n    if (Math.abs(fromCol - toCol) === 1 && !targetPiece) {\n      if (gameState.enPassantTarget && toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n        // Remove the captured pawn\n        const capturedPawnRow = piece.color === 'white' ? toRow + 1 : toRow - 1;\n        newBoard[capturedPawnRow][toCol] = null;\n      }\n    }\n\n    // Set en passant target if pawn moves two squares\n    if (Math.abs(fromRow - toRow) === 2) {\n      const enPassantRow = piece.color === 'white' ? toRow + 1 : toRow - 1;\n      newGameState.enPassantTarget = {\n        row: enPassantRow,\n        col: toCol\n      };\n    }\n\n    // Mark pawn as moved\n    piece.hasMoved = true;\n\n    // Pawn promotion\n    if (piece.color === 'white' && toRow === 0 || piece.color === 'black' && toRow === 7) {\n      piece.type = 'queen'; // Auto-promote to queen for simplicity\n    }\n  }\n\n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[fromRow][5] = newBoard[fromRow][7]; // Move rook\n      newBoard[fromRow][7] = null;\n      newBoard[fromRow][5].hasMoved = true;\n    }\n    // Queenside castling\n    else {\n      newBoard[fromRow][3] = newBoard[fromRow][0]; // Move rook\n      newBoard[fromRow][0] = null;\n      newBoard[fromRow][3].hasMoved = true;\n    }\n  }\n\n  // Mark pieces as moved\n  if (piece.type === 'king' || piece.type === 'rook') {\n    piece.hasMoved = true;\n  }\n\n  // Make the move\n  newBoard[toRow][toCol] = piece;\n  newBoard[fromRow][fromCol] = null;\n  return {\n    board: newBoard,\n    gameState: newGameState\n  };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color) => {\n  // If not in check, can't be checkmate\n  if (!isInCheck(board, color)) return false;\n\n  // Check if any move can get out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color) => {\n  // If in check, it's not stalemate\n  if (isInCheck(board, color)) return false;\n\n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = board => {\n  let score = 0;\n\n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n\n        // Add positional bonuses\n        let positionalValue = 0;\n\n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n\n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n\n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n\n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          positionalValue += diagonalMoves * 0.05;\n        }\n\n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n\n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(Math.abs(0 - row) + Math.abs(0 - col), Math.abs(0 - row) + Math.abs(7 - col), Math.abs(7 - row) + Math.abs(0 - col), Math.abs(7 - row) + Math.abs(7 - col));\n          positionalValue += centerDistance * 0.1;\n        }\n        const totalValue = value + positionalValue;\n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n\n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black')) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white')) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black')) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white')) {\n      score -= 0.5; // White is in check\n    }\n  }\n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n\n  // Check for terminal states\n  if (isCheckmate(board, 'white')) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black')) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return 0; // Draw\n  }\n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n\n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n\n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  for (const move of moves) {\n    const {\n      fromRow,\n      fromCol,\n      toRow,\n      toCol\n    } = move;\n    const {\n      board: newBoard,\n      gameState: newGameState\n    } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n\n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    if (isMaximizing && value > bestValue || !isMaximizing && value < bestValue) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  return bestMove;\n};","map":{"version":3,"names":["PIECE_VALUES","initializeBoard","board","Array","fill","map","col","type","color","hasMoved","cloneBoard","JSON","parse","stringify","findKing","row","piece","isSquareUnderAttack","attackerColor","pawnDirection","knightMoves","rowOffset","colOffset","newRow","newCol","directions","rowDir","colDir","Math","abs","isInCheck","kingPos","opponentColor","wouldBeInCheck","fromRow","fromCol","toRow","toCol","newBoard","isValidMove","gameState","targetPiece","isValid","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","direction","enPassantTarget","start","min","end","max","rowDiff","colDiff","rowDirection","colDirection","i","rook","makeMove","newGameState","capturedPawnRow","enPassantRow","isCheckmate","isStalemate","evaluateBoard","score","value","positionalValue","advancementBonus","centerDistance","diagonalMoves","openFile","r","totalValue","findAllValidMoves","moves","push","minimax","depth","alpha","beta","isMaximizing","maxEval","Infinity","move","evaluation","minEval","getAIMove","length","bestMove","bestValue","sort","a","b","aCapture","bCapture","isCapture","searchDepth"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/utils/chessLogic.js"],"sourcesContent":["// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n  \n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };\n    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };\n  }\n  \n  // Set up rooks\n  board[0][0] = { type: 'rook', color: 'black', hasMoved: false };\n  board[0][7] = { type: 'rook', color: 'black', hasMoved: false };\n  board[7][0] = { type: 'rook', color: 'white', hasMoved: false };\n  board[7][7] = { type: 'rook', color: 'white', hasMoved: false };\n  \n  // Set up knights\n  board[0][1] = { type: 'knight', color: 'black' };\n  board[0][6] = { type: 'knight', color: 'black' };\n  board[7][1] = { type: 'knight', color: 'white' };\n  board[7][6] = { type: 'knight', color: 'white' };\n  \n  // Set up bishops\n  board[0][2] = { type: 'bishop', color: 'black' };\n  board[0][5] = { type: 'bishop', color: 'black' };\n  board[7][2] = { type: 'bishop', color: 'white' };\n  board[7][5] = { type: 'bishop', color: 'white' };\n  \n  // Set up queens\n  board[0][3] = { type: 'queen', color: 'black' };\n  board[7][3] = { type: 'queen', color: 'white' };\n  \n  // Set up kings\n  board[0][4] = { type: 'king', color: 'black', hasMoved: false };\n  board[7][4] = { type: 'king', color: 'white', hasMoved: false };\n  \n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = (board) => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return { row, col };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row + pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row + pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from knights\n  const knightMoves = [\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n    [1, -2], [1, 2], [2, -1], [2, 1]\n  ];\n  \n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    \n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from bishops, rooks, and queens\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1], [0, -1],\n    [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n  \n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    \n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      \n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' ||\n              (piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir)) ||\n              (piece.type === 'rook' && (rowDir === 0 || colDir === 0))) {\n            return true;\n          }\n          \n          // King can attack adjacent squares\n          if (piece.type === 'king' && \n              Math.abs(newRow - row) <= 1 && \n              Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      \n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  \n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  \n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  if (!piece) return false;\n  \n  // Can't move to a square with a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) return false;\n  \n  let isValid = false;\n  \n  // Check if the move is valid based on piece type\n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n  \n  // If the move is valid by piece rules, check if it would leave the king in check\n  if (isValid && !wouldBeInCheck(board, fromRow, fromCol, toRow, toCol, piece.color)) {\n    return true;\n  }\n  \n  return false;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  \n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Moving forward two squares from starting position\n  if (fromCol === toCol && !piece.hasMoved && \n      toRow === fromRow + 2 * direction &&\n      !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n    \n    // En passant capture\n    if (!board[toRow][toCol] && gameState.enPassantTarget &&\n        toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  \n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  \n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  \n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  if (rowDiff !== colDiff) return false;\n  \n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  \n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  \n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  \n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n  \n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const newBoard = cloneBoard(board);\n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n  const newGameState = { ...gameState };\n  \n  // Reset en passant target\n  newGameState.enPassantTarget = null;\n  \n  // Handle special moves\n  if (piece.type === 'pawn') {\n    // En passant capture\n    if (Math.abs(fromCol - toCol) === 1 && !targetPiece) {\n      if (gameState.enPassantTarget &&\n          toRow === gameState.enPassantTarget.row &&\n          toCol === gameState.enPassantTarget.col) {\n        // Remove the captured pawn\n        const capturedPawnRow = piece.color === 'white' ? toRow + 1 : toRow - 1;\n        newBoard[capturedPawnRow][toCol] = null;\n      }\n    }\n    \n    // Set en passant target if pawn moves two squares\n    if (Math.abs(fromRow - toRow) === 2) {\n      const enPassantRow = piece.color === 'white' ? toRow + 1 : toRow - 1;\n      newGameState.enPassantTarget = { row: enPassantRow, col: toCol };\n    }\n    \n    // Mark pawn as moved\n    piece.hasMoved = true;\n    \n    // Pawn promotion\n    if ((piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7)) {\n      piece.type = 'queen'; // Auto-promote to queen for simplicity\n    }\n  }\n  \n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[fromRow][5] = newBoard[fromRow][7]; // Move rook\n      newBoard[fromRow][7] = null;\n      newBoard[fromRow][5].hasMoved = true;\n    }\n    // Queenside castling\n    else {\n      newBoard[fromRow][3] = newBoard[fromRow][0]; // Move rook\n      newBoard[fromRow][0] = null;\n      newBoard[fromRow][3].hasMoved = true;\n    }\n  }\n  \n  // Mark pieces as moved\n  if (piece.type === 'king' || piece.type === 'rook') {\n    piece.hasMoved = true;\n  }\n  \n  // Make the move\n  newBoard[toRow][toCol] = piece;\n  newBoard[fromRow][fromCol] = null;\n  \n  return { board: newBoard, gameState: newGameState };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color) => {\n  // If not in check, can't be checkmate\n  if (!isInCheck(board, color)) return false;\n  \n  // Check if any move can get out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color) => {\n  // If in check, it's not stalemate\n  if (isInCheck(board, color)) return false;\n  \n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = (board) => {\n  let score = 0;\n  \n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n        \n        // Add positional bonuses\n        let positionalValue = 0;\n        \n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n          \n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n        \n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n        \n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          \n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            \n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          \n          positionalValue += diagonalMoves * 0.05;\n        }\n        \n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && \n                board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          \n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n        \n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(\n            Math.abs(0 - row) + Math.abs(0 - col),\n            Math.abs(0 - row) + Math.abs(7 - col),\n            Math.abs(7 - row) + Math.abs(0 - col),\n            Math.abs(7 - row) + Math.abs(7 - col)\n          );\n          \n          positionalValue += centerDistance * 0.1;\n        }\n        \n        const totalValue = value + positionalValue;\n        \n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n  \n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black')) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white')) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black')) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white')) {\n      score -= 0.5; // White is in check\n    }\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({ fromRow, fromCol, toRow, toCol });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n  \n  // Check for terminal states\n  if (isCheckmate(board, 'white')) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black')) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return 0; // Draw\n  }\n  \n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  \n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  \n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    \n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    \n    if ((isMaximizing && value > bestValue) || (!isMaximizing && value < bestValue)) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}