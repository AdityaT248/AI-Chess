{"ast":null,"code":"import { makeMove, isValidMove,\n// eslint-disable-next-line no-unused-vars\nisInCheck, isCheckmate, isStalemate } from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [[0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 2, 3, 3, 2, 1, 1], [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5], [0, 0, 0, 2, 2, 0, 0, 0], [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5], [0.5, 1, 1, -2, -2, 1, 1, 0.5], [0, 0, 0, 0, 0, 0, 0, 0]],\n  'knight': [[-5, -4, -3, -3, -3, -3, -4, -5], [-4, -2, 0, 0, 0, 0, -2, -4], [-3, 0, 1, 1.5, 1.5, 1, 0, -3], [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3], [-3, 0, 1.5, 2, 2, 1.5, 0, -3], [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3], [-4, -2, 0, 0.5, 0.5, 0, -2, -4], [-5, -4, -3, -3, -3, -3, -4, -5]],\n  'bishop': [[-2, -1, -1, -1, -1, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 1, 1, 0.5, 0, -1], [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1], [-1, 0, 1, 1, 1, 1, 0, -1], [-1, 1, 1, 1, 1, 1, 1, -1], [-1, 0.5, 0, 0, 0, 0, 0.5, -1], [-2, -1, -1, -1, -1, -1, -1, -2]],\n  'rook': [[0, 0, 0, 0, 0, 0, 0, 0], [0.5, 1, 1, 1, 1, 1, 1, 0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [0, 0, 0, 0.5, 0.5, 0, 0, 0]],\n  'queen': [[-2, -1, -1, -0.5, -0.5, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1], [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1], [-1, 0, 0.5, 0, 0, 0, 0, -1], [-2, -1, -1, -0.5, -0.5, -1, -1, -2]],\n  'king': [[-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-2, -3, -3, -4, -4, -3, -3, -2], [-1, -2, -2, -2, -2, -2, -2, -1], [2, 2, 0, 0, 0, 0, 2, 2], [2, 3, 1, 0, 0, 1, 3, 2]]\n};\n\n// Evaluate the board position\nconst evaluateBoard = (board, color) => {\n  let score = 0;\n\n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && !piece.captured) {\n        // Material value\n        const materialValue = pieceValues[piece.type];\n\n        // Position value (flipped for black)\n        let positionValue = 0;\n        if (piece.color === 'white') {\n          positionValue = positionBonus[piece.type][row][col];\n        } else {\n          positionValue = positionBonus[piece.type][7 - row][col];\n        }\n\n        // Add to score (positive for white, negative for black)\n        const value = materialValue + positionValue;\n        if (piece.color === 'white') {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n\n  // Adjust score based on check/checkmate\n  if (isCheckmate(board, 'white')) {\n    score = -10000; // Black wins\n  } else if (isCheckmate(board, 'black')) {\n    score = 10000; // White wins\n  } else if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    score = 0; // Draw\n  }\n\n  // Return score from the perspective of the current player\n  return color === 'white' ? score : -score;\n};\n\n// Generate all valid moves for a player\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color && !piece.captured) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Minimax algorithm with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, maximizingPlayer, color, gameState) => {\n  // Base case: depth reached or game over\n  if (depth === 0 || isCheckmate(board, 'white') || isCheckmate(board, 'black') || isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return evaluateBoard(board, color);\n  }\n  const currentColor = maximizingPlayer ? color : color === 'white' ? 'black' : 'white';\n  const moves = generateMoves(board, currentColor, gameState);\n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, color, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, color, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    return minEval;\n  }\n};\n\n// Find the best move using minimax with a time limit\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Set depth based on difficulty\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 1;\n      break;\n    case 'medium':\n      depth = 2;\n      break;\n    case 'hard':\n      depth = 3;\n      break;\n    default:\n      depth = 2;\n  }\n\n  // Generate all valid moves\n  const moves = generateMoves(board, color, gameState);\n\n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n\n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n\n  // Shuffle moves for variety\n  for (let i = moves.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [moves[i], moves[j]] = [moves[j], moves[i]];\n  }\n  let bestMove = moves[0]; // Default to first move\n  // eslint-disable-next-line no-unused-vars\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n\n  // Iterative deepening - start with depth 1 and increase if time allows\n  for (let currentDepth = 1; currentDepth <= depth; currentDepth++) {\n    let tempBestMove = null;\n    let tempBestValue = color === 'white' ? -Infinity : Infinity;\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const value = minimax(newBoard, currentDepth - 1, -Infinity, Infinity, color === 'black',\n      // If black, next player is white (maximizing)\n      color, newGameState);\n      if (color === 'white' && value > tempBestValue || color === 'black' && value < tempBestValue) {\n        tempBestValue = value;\n        tempBestMove = move;\n      }\n    }\n    if (tempBestMove) {\n      bestMove = tempBestMove;\n      bestValue = tempBestValue;\n    }\n  }\n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n};","map":{"version":3,"names":["makeMove","isValidMove","isInCheck","isCheckmate","isStalemate","pieceValues","positionBonus","evaluateBoard","board","color","score","row","col","piece","captured","materialValue","type","positionValue","value","generateMoves","gameState","moves","fromRow","fromCol","toRow","toCol","push","minimax","depth","alpha","beta","maximizingPlayer","currentColor","maxEval","Infinity","move","newBoard","newGameState","evaluation","Math","max","minEval","min","findBestMove","difficulty","length","i","j","floor","random","bestMove","bestValue","currentDepth","tempBestMove","tempBestValue","getAIMove"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/utils/aiPlayer.js"],"sourcesContent":["import { \n  makeMove, \n  isValidMove, \n  // eslint-disable-next-line no-unused-vars\n  isInCheck, \n  isCheckmate, \n  isStalemate \n} from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  'knight': [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  'bishop': [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  'rook': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  'queen': [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  'king': [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Evaluate the board position\nconst evaluateBoard = (board, color) => {\n  let score = 0;\n  \n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && !piece.captured) {\n        // Material value\n        const materialValue = pieceValues[piece.type];\n        \n        // Position value (flipped for black)\n        let positionValue = 0;\n        if (piece.color === 'white') {\n          positionValue = positionBonus[piece.type][row][col];\n        } else {\n          positionValue = positionBonus[piece.type][7 - row][col];\n        }\n        \n        // Add to score (positive for white, negative for black)\n        const value = materialValue + positionValue;\n        if (piece.color === 'white') {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  \n  // Adjust score based on check/checkmate\n  if (isCheckmate(board, 'white')) {\n    score = -10000; // Black wins\n  } else if (isCheckmate(board, 'black')) {\n    score = 10000; // White wins\n  } else if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    score = 0; // Draw\n  }\n  \n  // Return score from the perspective of the current player\n  return color === 'white' ? score : -score;\n};\n\n// Generate all valid moves for a player\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      \n      if (piece && piece.color === color && !piece.captured) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, maximizingPlayer, color, gameState) => {\n  // Base case: depth reached or game over\n  if (depth === 0 || isCheckmate(board, 'white') || isCheckmate(board, 'black') || \n      isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return evaluateBoard(board, color);\n  }\n  \n  const currentColor = maximizingPlayer ? color : (color === 'white' ? 'black' : 'white');\n  const moves = generateMoves(board, currentColor, gameState);\n  \n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, color, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      \n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    \n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, color, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      \n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    \n    return minEval;\n  }\n};\n\n// Find the best move using minimax with a time limit\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Set depth based on difficulty\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 1;\n      break;\n    case 'medium':\n      depth = 2;\n      break;\n    case 'hard':\n      depth = 3;\n      break;\n    default:\n      depth = 2;\n  }\n  \n  // Generate all valid moves\n  const moves = generateMoves(board, color, gameState);\n  \n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n  \n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n  \n  // Shuffle moves for variety\n  for (let i = moves.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [moves[i], moves[j]] = [moves[j], moves[i]];\n  }\n  \n  let bestMove = moves[0]; // Default to first move\n  // eslint-disable-next-line no-unused-vars\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // Iterative deepening - start with depth 1 and increase if time allows\n  for (let currentDepth = 1; currentDepth <= depth; currentDepth++) {\n    let tempBestMove = null;\n    let tempBestValue = color === 'white' ? -Infinity : Infinity;\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const value = minimax(\n        newBoard, \n        currentDepth - 1, \n        -Infinity, \n        Infinity, \n        color === 'black', // If black, next player is white (maximizing)\n        color, \n        newGameState\n      );\n      \n      if ((color === 'white' && value > tempBestValue) || (color === 'black' && value < tempBestValue)) {\n        tempBestValue = value;\n        tempBestMove = move;\n      }\n    }\n    \n    if (tempBestMove) {\n      bestMove = tempBestMove;\n      bestValue = tempBestValue;\n    }\n  }\n  \n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}