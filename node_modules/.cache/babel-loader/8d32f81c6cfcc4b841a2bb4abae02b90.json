{"ast":null,"code":"var _jsxFileName = \"/Users/aditya.thakkar/Documents/AI Chess/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport ChessBoard from './components/ChessBoard';\nimport GameInfo from './components/GameInfo';\nimport { initializeBoard, isValidMove, makeMove, getAIMove, isInCheck, isCheckmate, isStalemate } from './utils/chessLogic';\nfunction App() {\n  const [board, setBoard] = useState(initializeBoard());\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [playerTurn, setPlayerTurn] = useState('white');\n  const [gameStatus, setGameStatus] = useState('ongoing');\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [gameState, setGameState] = useState({\n    enPassantTarget: null,\n    castlingRights: {\n      white: {\n        kingSide: true,\n        queenSide: true\n      },\n      black: {\n        kingSide: true,\n        queenSide: true\n      }\n    }\n  });\n  const [highlightedSquares, setHighlightedSquares] = useState([]);\n  const [checkIndicator, setCheckIndicator] = useState(null);\n  // We'll implement pawn promotion in a future update\n  // const [promotionDialog, setPromotionDialog] = useState(null);\n\n  // Check for check, checkmate, or stalemate after each move\n  useEffect(() => {\n    if (gameStatus !== 'ongoing') return;\n    const currentPlayer = playerTurn;\n    const opponent = currentPlayer === 'white' ? 'black' : 'white';\n\n    // Check if the current player is in check\n    if (isInCheck(board, currentPlayer)) {\n      setCheckIndicator(currentPlayer);\n\n      // Check if it's checkmate\n      if (isCheckmate(board, currentPlayer)) {\n        setGameStatus(`${opponent} wins by checkmate`);\n        return;\n      }\n    } else {\n      setCheckIndicator(null);\n\n      // Check if it's stalemate\n      if (isStalemate(board, currentPlayer)) {\n        setGameStatus('draw by stalemate');\n        return;\n      }\n    }\n  }, [board, playerTurn, gameStatus]);\n\n  // Calculate valid moves for the selected piece\n  useEffect(() => {\n    if (selectedPiece) {\n      const validMoves = [];\n      for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n          if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n            validMoves.push({\n              row,\n              col\n            });\n          }\n        }\n      }\n      setHighlightedSquares(validMoves);\n    } else {\n      setHighlightedSquares([]);\n    }\n  }, [selectedPiece, board, gameState]);\n\n  // AI's turn\n  useEffect(() => {\n    if (playerTurn === 'black' && gameStatus === 'ongoing') {\n      const aiThinkingTime = Math.random() * 500 + 500; // Random time between 500-1000ms\n\n      const aiMoveTimeout = setTimeout(() => {\n        const aiMove = getAIMove(board, 'black', gameState);\n        if (aiMove) {\n          const {\n            fromRow,\n            fromCol,\n            toRow,\n            toCol\n          } = aiMove;\n          const aiPiece = board[fromRow][fromCol];\n\n          // Make the AI move\n          const {\n            board: newBoard,\n            gameState: newGameState\n          } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n\n          // Create move notation\n          const pieceSymbol = getPieceSymbol(aiPiece.type);\n          const fromSquare = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}`;\n          const toSquare = `${String.fromCharCode(97 + toCol)}${8 - toRow}`;\n          const captureSymbol = board[toRow][toCol] ? 'x' : '';\n          let moveNotation = `${pieceSymbol}${fromSquare}${captureSymbol}${toSquare}`;\n\n          // Check if the move results in check or checkmate\n          if (isCheckmate(newBoard, 'white')) {\n            moveNotation += '#';\n          } else if (isInCheck(newBoard, 'white')) {\n            moveNotation += '+';\n          }\n\n          // Update the game state\n          setBoard(newBoard);\n          setGameState(newGameState);\n          setMoveHistory([...moveHistory, {\n            notation: moveNotation,\n            color: 'black',\n            from: {\n              row: fromRow,\n              col: fromCol\n            },\n            to: {\n              row: toRow,\n              col: toCol\n            }\n          }]);\n          setPlayerTurn('white');\n        }\n      }, aiThinkingTime);\n      return () => clearTimeout(aiMoveTimeout);\n    }\n  }, [playerTurn, board, gameStatus, gameState, moveHistory]);\n  const getPieceSymbol = pieceType => {\n    switch (pieceType) {\n      case 'pawn':\n        return '';\n      case 'knight':\n        return 'N';\n      case 'bishop':\n        return 'B';\n      case 'rook':\n        return 'R';\n      case 'queen':\n        return 'Q';\n      case 'king':\n        return 'K';\n      default:\n        return '';\n    }\n  };\n  const handleSquareClick = (row, col) => {\n    // If game is over, don't allow any moves\n    if (gameStatus !== 'ongoing') return;\n\n    // If it's not the player's turn, don't allow any moves\n    if (playerTurn !== 'white') return;\n    const piece = board[row][col];\n\n    // If a piece is already selected\n    if (selectedPiece) {\n      // If clicking on the same piece, deselect it\n      if (selectedPiece.row === row && selectedPiece.col === col) {\n        setSelectedPiece(null);\n        return;\n      }\n\n      // If clicking on a different piece of the same color, select that piece instead\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({\n          row,\n          col,\n          piece\n        });\n        return;\n      }\n\n      // Try to make a move\n      if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n        const {\n          board: newBoard,\n          gameState: newGameState\n        } = makeMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState);\n\n        // Create move notation\n        const pieceSymbol = getPieceSymbol(selectedPiece.piece.type);\n        const fromSquare = `${String.fromCharCode(97 + selectedPiece.col)}${8 - selectedPiece.row}`;\n        const toSquare = `${String.fromCharCode(97 + col)}${8 - row}`;\n        const captureSymbol = board[row][col] ? 'x' : '';\n        let moveNotation = `${pieceSymbol}${fromSquare}${captureSymbol}${toSquare}`;\n\n        // Check if the move results in check or checkmate\n        if (isCheckmate(newBoard, 'black')) {\n          moveNotation += '#';\n        } else if (isInCheck(newBoard, 'black')) {\n          moveNotation += '+';\n        }\n\n        // Update the game state\n        setBoard(newBoard);\n        setGameState(newGameState);\n        setMoveHistory([...moveHistory, {\n          notation: moveNotation,\n          color: 'white',\n          from: {\n            row: selectedPiece.row,\n            col: selectedPiece.col\n          },\n          to: {\n            row,\n            col\n          }\n        }]);\n        setSelectedPiece(null);\n        setPlayerTurn('black');\n      }\n    } else {\n      // If no piece is selected and clicked on a piece of the player's color, select it\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({\n          row,\n          col,\n          piece\n        });\n      }\n    }\n  };\n  const resetGame = () => {\n    setBoard(initializeBoard());\n    setSelectedPiece(null);\n    setPlayerTurn('white');\n    setGameStatus('ongoing');\n    setMoveHistory([]);\n    setGameState({\n      enPassantTarget: null,\n      castlingRights: {\n        white: {\n          kingSide: true,\n          queenSide: true\n        },\n        black: {\n          kingSide: true,\n          queenSide: true\n        }\n      }\n    });\n    setHighlightedSquares([]);\n    setCheckIndicator(null);\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"app\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 230,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }\n  }, \"AI Chess\"), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"game-container\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 232,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(ChessBoard, {\n    board: board,\n    selectedPiece: selectedPiece,\n    onSquareClick: handleSquareClick,\n    highlightedSquares: highlightedSquares,\n    checkIndicator: checkIndicator,\n    lastMove: moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(GameInfo, {\n    playerTurn: playerTurn,\n    gameStatus: gameStatus,\n    moveHistory: moveHistory,\n    onResetGame: resetGame,\n    isInCheck: checkIndicator !== null,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 241,\n      columnNumber: 9\n    }\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"app-footer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 249,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 250,\n      columnNumber: 9\n    }\n  }, \"Chess AI with Minimax Algorithm & Alpha-Beta Pruning\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 251,\n      columnNumber: 9\n    }\n  }, \"\\xA9 \", new Date().getFullYear(), \" AI Chess\")));\n}\nexport default App;","map":{"version":3,"names":["React","useState","useEffect","ChessBoard","GameInfo","initializeBoard","isValidMove","makeMove","getAIMove","isInCheck","isCheckmate","isStalemate","App","board","setBoard","selectedPiece","setSelectedPiece","playerTurn","setPlayerTurn","gameStatus","setGameStatus","moveHistory","setMoveHistory","gameState","setGameState","enPassantTarget","castlingRights","white","kingSide","queenSide","black","highlightedSquares","setHighlightedSquares","checkIndicator","setCheckIndicator","currentPlayer","opponent","validMoves","row","col","push","aiThinkingTime","Math","random","aiMoveTimeout","setTimeout","aiMove","fromRow","fromCol","toRow","toCol","aiPiece","newBoard","newGameState","pieceSymbol","getPieceSymbol","type","fromSquare","String","fromCharCode","toSquare","captureSymbol","moveNotation","notation","color","from","to","clearTimeout","pieceType","handleSquareClick","piece","resetGame","createElement","className","__self","__source","fileName","_jsxFileName","lineNumber","columnNumber","onSquareClick","lastMove","length","onResetGame","Date","getFullYear"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport ChessBoard from './components/ChessBoard';\nimport GameInfo from './components/GameInfo';\nimport { \n  initializeBoard, \n  isValidMove, \n  makeMove, \n  getAIMove, \n  isInCheck, \n  isCheckmate, \n  isStalemate \n} from './utils/chessLogic';\n\nfunction App() {\n  const [board, setBoard] = useState(initializeBoard());\n  const [selectedPiece, setSelectedPiece] = useState(null);\n  const [playerTurn, setPlayerTurn] = useState('white');\n  const [gameStatus, setGameStatus] = useState('ongoing');\n  const [moveHistory, setMoveHistory] = useState([]);\n  const [gameState, setGameState] = useState({\n    enPassantTarget: null,\n    castlingRights: {\n      white: { kingSide: true, queenSide: true },\n      black: { kingSide: true, queenSide: true }\n    }\n  });\n  const [highlightedSquares, setHighlightedSquares] = useState([]);\n  const [checkIndicator, setCheckIndicator] = useState(null);\n  // We'll implement pawn promotion in a future update\n  // const [promotionDialog, setPromotionDialog] = useState(null);\n\n  // Check for check, checkmate, or stalemate after each move\n  useEffect(() => {\n    if (gameStatus !== 'ongoing') return;\n\n    const currentPlayer = playerTurn;\n    const opponent = currentPlayer === 'white' ? 'black' : 'white';\n\n    // Check if the current player is in check\n    if (isInCheck(board, currentPlayer)) {\n      setCheckIndicator(currentPlayer);\n      \n      // Check if it's checkmate\n      if (isCheckmate(board, currentPlayer)) {\n        setGameStatus(`${opponent} wins by checkmate`);\n        return;\n      }\n    } else {\n      setCheckIndicator(null);\n      \n      // Check if it's stalemate\n      if (isStalemate(board, currentPlayer)) {\n        setGameStatus('draw by stalemate');\n        return;\n      }\n    }\n  }, [board, playerTurn, gameStatus]);\n\n  // Calculate valid moves for the selected piece\n  useEffect(() => {\n    if (selectedPiece) {\n      const validMoves = [];\n      for (let row = 0; row < 8; row++) {\n        for (let col = 0; col < 8; col++) {\n          if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n            validMoves.push({ row, col });\n          }\n        }\n      }\n      setHighlightedSquares(validMoves);\n    } else {\n      setHighlightedSquares([]);\n    }\n  }, [selectedPiece, board, gameState]);\n\n  // AI's turn\n  useEffect(() => {\n    if (playerTurn === 'black' && gameStatus === 'ongoing') {\n      const aiThinkingTime = Math.random() * 500 + 500; // Random time between 500-1000ms\n      \n      const aiMoveTimeout = setTimeout(() => {\n        const aiMove = getAIMove(board, 'black', gameState);\n        \n        if (aiMove) {\n          const { fromRow, fromCol, toRow, toCol } = aiMove;\n          const aiPiece = board[fromRow][fromCol];\n          \n          // Make the AI move\n          const { board: newBoard, gameState: newGameState } = makeMove(\n            board, \n            fromRow, \n            fromCol, \n            toRow, \n            toCol, \n            gameState\n          );\n          \n          // Create move notation\n          const pieceSymbol = getPieceSymbol(aiPiece.type);\n          const fromSquare = `${String.fromCharCode(97 + fromCol)}${8 - fromRow}`;\n          const toSquare = `${String.fromCharCode(97 + toCol)}${8 - toRow}`;\n          const captureSymbol = board[toRow][toCol] ? 'x' : '';\n          \n          let moveNotation = `${pieceSymbol}${fromSquare}${captureSymbol}${toSquare}`;\n          \n          // Check if the move results in check or checkmate\n          if (isCheckmate(newBoard, 'white')) {\n            moveNotation += '#';\n          } else if (isInCheck(newBoard, 'white')) {\n            moveNotation += '+';\n          }\n          \n          // Update the game state\n          setBoard(newBoard);\n          setGameState(newGameState);\n          setMoveHistory([...moveHistory, { \n            notation: moveNotation, \n            color: 'black',\n            from: { row: fromRow, col: fromCol },\n            to: { row: toRow, col: toCol }\n          }]);\n          setPlayerTurn('white');\n        }\n      }, aiThinkingTime);\n      \n      return () => clearTimeout(aiMoveTimeout);\n    }\n  }, [playerTurn, board, gameStatus, gameState, moveHistory]);\n\n  const getPieceSymbol = (pieceType) => {\n    switch (pieceType) {\n      case 'pawn': return '';\n      case 'knight': return 'N';\n      case 'bishop': return 'B';\n      case 'rook': return 'R';\n      case 'queen': return 'Q';\n      case 'king': return 'K';\n      default: return '';\n    }\n  };\n\n  const handleSquareClick = (row, col) => {\n    // If game is over, don't allow any moves\n    if (gameStatus !== 'ongoing') return;\n    \n    // If it's not the player's turn, don't allow any moves\n    if (playerTurn !== 'white') return;\n    \n    const piece = board[row][col];\n    \n    // If a piece is already selected\n    if (selectedPiece) {\n      // If clicking on the same piece, deselect it\n      if (selectedPiece.row === row && selectedPiece.col === col) {\n        setSelectedPiece(null);\n        return;\n      }\n      \n      // If clicking on a different piece of the same color, select that piece instead\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n        return;\n      }\n      \n      // Try to make a move\n      if (isValidMove(board, selectedPiece.row, selectedPiece.col, row, col, gameState)) {\n        const { board: newBoard, gameState: newGameState } = makeMove(\n          board, \n          selectedPiece.row, \n          selectedPiece.col, \n          row, \n          col, \n          gameState\n        );\n        \n        // Create move notation\n        const pieceSymbol = getPieceSymbol(selectedPiece.piece.type);\n        const fromSquare = `${String.fromCharCode(97 + selectedPiece.col)}${8 - selectedPiece.row}`;\n        const toSquare = `${String.fromCharCode(97 + col)}${8 - row}`;\n        const captureSymbol = board[row][col] ? 'x' : '';\n        \n        let moveNotation = `${pieceSymbol}${fromSquare}${captureSymbol}${toSquare}`;\n        \n        // Check if the move results in check or checkmate\n        if (isCheckmate(newBoard, 'black')) {\n          moveNotation += '#';\n        } else if (isInCheck(newBoard, 'black')) {\n          moveNotation += '+';\n        }\n        \n        // Update the game state\n        setBoard(newBoard);\n        setGameState(newGameState);\n        setMoveHistory([...moveHistory, { \n          notation: moveNotation, \n          color: 'white',\n          from: { row: selectedPiece.row, col: selectedPiece.col },\n          to: { row, col }\n        }]);\n        setSelectedPiece(null);\n        setPlayerTurn('black');\n      }\n    } else {\n      // If no piece is selected and clicked on a piece of the player's color, select it\n      if (piece && piece.color === playerTurn) {\n        setSelectedPiece({ row, col, piece });\n      }\n    }\n  };\n\n  const resetGame = () => {\n    setBoard(initializeBoard());\n    setSelectedPiece(null);\n    setPlayerTurn('white');\n    setGameStatus('ongoing');\n    setMoveHistory([]);\n    setGameState({\n      enPassantTarget: null,\n      castlingRights: {\n        white: { kingSide: true, queenSide: true },\n        black: { kingSide: true, queenSide: true }\n      }\n    });\n    setHighlightedSquares([]);\n    setCheckIndicator(null);\n  };\n\n  return (\n    <div className=\"app\">\n      <h1>AI Chess</h1>\n      <div className=\"game-container\">\n        <ChessBoard \n          board={board} \n          selectedPiece={selectedPiece} \n          onSquareClick={handleSquareClick}\n          highlightedSquares={highlightedSquares}\n          checkIndicator={checkIndicator}\n          lastMove={moveHistory.length > 0 ? moveHistory[moveHistory.length - 1] : null}\n        />\n        <GameInfo \n          playerTurn={playerTurn} \n          gameStatus={gameStatus} \n          moveHistory={moveHistory} \n          onResetGame={resetGame} \n          isInCheck={checkIndicator !== null}\n        />\n      </div>\n      <div className=\"app-footer\">\n        <p>Chess AI with Minimax Algorithm & Alpha-Beta Pruning</p>\n        <p>Â© {new Date().getFullYear()} AI Chess</p>\n      </div>\n    </div>\n  );\n}\n\nexport default App; "],"mappings":";AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,OAAO,WAAW;AAClB,OAAOC,UAAU,MAAM,yBAAyB;AAChD,OAAOC,QAAQ,MAAM,uBAAuB;AAC5C,SACEC,eAAe,EACfC,WAAW,EACXC,QAAQ,EACRC,SAAS,EACTC,SAAS,EACTC,WAAW,EACXC,WAAW,QACN,oBAAoB;AAE3B,SAASC,GAAGA,CAAA,EAAG;EACb,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGb,QAAQ,CAACI,eAAe,CAAC,CAAC,CAAC;EACrD,MAAM,CAACU,aAAa,EAAEC,gBAAgB,CAAC,GAAGf,QAAQ,CAAC,IAAI,CAAC;EACxD,MAAM,CAACgB,UAAU,EAAEC,aAAa,CAAC,GAAGjB,QAAQ,CAAC,OAAO,CAAC;EACrD,MAAM,CAACkB,UAAU,EAAEC,aAAa,CAAC,GAAGnB,QAAQ,CAAC,SAAS,CAAC;EACvD,MAAM,CAACoB,WAAW,EAAEC,cAAc,CAAC,GAAGrB,QAAQ,CAAC,EAAE,CAAC;EAClD,MAAM,CAACsB,SAAS,EAAEC,YAAY,CAAC,GAAGvB,QAAQ,CAAC;IACzCwB,eAAe,EAAE,IAAI;IACrBC,cAAc,EAAE;MACdC,KAAK,EAAE;QAAEC,QAAQ,EAAE,IAAI;QAAEC,SAAS,EAAE;MAAK,CAAC;MAC1CC,KAAK,EAAE;QAAEF,QAAQ,EAAE,IAAI;QAAEC,SAAS,EAAE;MAAK;IAC3C;EACF,CAAC,CAAC;EACF,MAAM,CAACE,kBAAkB,EAAEC,qBAAqB,CAAC,GAAG/B,QAAQ,CAAC,EAAE,CAAC;EAChE,MAAM,CAACgC,cAAc,EAAEC,iBAAiB,CAAC,GAAGjC,QAAQ,CAAC,IAAI,CAAC;EAC1D;EACA;;EAEA;EACAC,SAAS,CAAC,MAAM;IACd,IAAIiB,UAAU,KAAK,SAAS,EAAE;IAE9B,MAAMgB,aAAa,GAAGlB,UAAU;IAChC,MAAMmB,QAAQ,GAAGD,aAAa,KAAK,OAAO,GAAG,OAAO,GAAG,OAAO;;IAE9D;IACA,IAAI1B,SAAS,CAACI,KAAK,EAAEsB,aAAa,CAAC,EAAE;MACnCD,iBAAiB,CAACC,aAAa,CAAC;;MAEhC;MACA,IAAIzB,WAAW,CAACG,KAAK,EAAEsB,aAAa,CAAC,EAAE;QACrCf,aAAa,CAAC,GAAGgB,QAAQ,oBAAoB,CAAC;QAC9C;MACF;IACF,CAAC,MAAM;MACLF,iBAAiB,CAAC,IAAI,CAAC;;MAEvB;MACA,IAAIvB,WAAW,CAACE,KAAK,EAAEsB,aAAa,CAAC,EAAE;QACrCf,aAAa,CAAC,mBAAmB,CAAC;QAClC;MACF;IACF;EACF,CAAC,EAAE,CAACP,KAAK,EAAEI,UAAU,EAAEE,UAAU,CAAC,CAAC;;EAEnC;EACAjB,SAAS,CAAC,MAAM;IACd,IAAIa,aAAa,EAAE;MACjB,MAAMsB,UAAU,GAAG,EAAE;MACrB,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;QAChC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAG,CAAC,EAAEA,GAAG,EAAE,EAAE;UAChC,IAAIjC,WAAW,CAACO,KAAK,EAAEE,aAAa,CAACuB,GAAG,EAAEvB,aAAa,CAACwB,GAAG,EAAED,GAAG,EAAEC,GAAG,EAAEhB,SAAS,CAAC,EAAE;YACjFc,UAAU,CAACG,IAAI,CAAC;cAAEF,GAAG;cAAEC;YAAI,CAAC,CAAC;UAC/B;QACF;MACF;MACAP,qBAAqB,CAACK,UAAU,CAAC;IACnC,CAAC,MAAM;MACLL,qBAAqB,CAAC,EAAE,CAAC;IAC3B;EACF,CAAC,EAAE,CAACjB,aAAa,EAAEF,KAAK,EAAEU,SAAS,CAAC,CAAC;;EAErC;EACArB,SAAS,CAAC,MAAM;IACd,IAAIe,UAAU,KAAK,OAAO,IAAIE,UAAU,KAAK,SAAS,EAAE;MACtD,MAAMsB,cAAc,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;;MAElD,MAAMC,aAAa,GAAGC,UAAU,CAAC,MAAM;QACrC,MAAMC,MAAM,GAAGtC,SAAS,CAACK,KAAK,EAAE,OAAO,EAAEU,SAAS,CAAC;QAEnD,IAAIuB,MAAM,EAAE;UACV,MAAM;YAAEC,OAAO;YAAEC,OAAO;YAAEC,KAAK;YAAEC;UAAM,CAAC,GAAGJ,MAAM;UACjD,MAAMK,OAAO,GAAGtC,KAAK,CAACkC,OAAO,CAAC,CAACC,OAAO,CAAC;;UAEvC;UACA,MAAM;YAAEnC,KAAK,EAAEuC,QAAQ;YAAE7B,SAAS,EAAE8B;UAAa,CAAC,GAAG9C,QAAQ,CAC3DM,KAAK,EACLkC,OAAO,EACPC,OAAO,EACPC,KAAK,EACLC,KAAK,EACL3B,SACF,CAAC;;UAED;UACA,MAAM+B,WAAW,GAAGC,cAAc,CAACJ,OAAO,CAACK,IAAI,CAAC;UAChD,MAAMC,UAAU,GAAG,GAAGC,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGX,OAAO,CAAC,GAAG,CAAC,GAAGD,OAAO,EAAE;UACvE,MAAMa,QAAQ,GAAG,GAAGF,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGT,KAAK,CAAC,GAAG,CAAC,GAAGD,KAAK,EAAE;UACjE,MAAMY,aAAa,GAAGhD,KAAK,CAACoC,KAAK,CAAC,CAACC,KAAK,CAAC,GAAG,GAAG,GAAG,EAAE;UAEpD,IAAIY,YAAY,GAAG,GAAGR,WAAW,GAAGG,UAAU,GAAGI,aAAa,GAAGD,QAAQ,EAAE;;UAE3E;UACA,IAAIlD,WAAW,CAAC0C,QAAQ,EAAE,OAAO,CAAC,EAAE;YAClCU,YAAY,IAAI,GAAG;UACrB,CAAC,MAAM,IAAIrD,SAAS,CAAC2C,QAAQ,EAAE,OAAO,CAAC,EAAE;YACvCU,YAAY,IAAI,GAAG;UACrB;;UAEA;UACAhD,QAAQ,CAACsC,QAAQ,CAAC;UAClB5B,YAAY,CAAC6B,YAAY,CAAC;UAC1B/B,cAAc,CAAC,CAAC,GAAGD,WAAW,EAAE;YAC9B0C,QAAQ,EAAED,YAAY;YACtBE,KAAK,EAAE,OAAO;YACdC,IAAI,EAAE;cAAE3B,GAAG,EAAES,OAAO;cAAER,GAAG,EAAES;YAAQ,CAAC;YACpCkB,EAAE,EAAE;cAAE5B,GAAG,EAAEW,KAAK;cAAEV,GAAG,EAAEW;YAAM;UAC/B,CAAC,CAAC,CAAC;UACHhC,aAAa,CAAC,OAAO,CAAC;QACxB;MACF,CAAC,EAAEuB,cAAc,CAAC;MAElB,OAAO,MAAM0B,YAAY,CAACvB,aAAa,CAAC;IAC1C;EACF,CAAC,EAAE,CAAC3B,UAAU,EAAEJ,KAAK,EAAEM,UAAU,EAAEI,SAAS,EAAEF,WAAW,CAAC,CAAC;EAE3D,MAAMkC,cAAc,GAAIa,SAAS,IAAK;IACpC,QAAQA,SAAS;MACf,KAAK,MAAM;QAAE,OAAO,EAAE;MACtB,KAAK,QAAQ;QAAE,OAAO,GAAG;MACzB,KAAK,QAAQ;QAAE,OAAO,GAAG;MACzB,KAAK,MAAM;QAAE,OAAO,GAAG;MACvB,KAAK,OAAO;QAAE,OAAO,GAAG;MACxB,KAAK,MAAM;QAAE,OAAO,GAAG;MACvB;QAAS,OAAO,EAAE;IACpB;EACF,CAAC;EAED,MAAMC,iBAAiB,GAAGA,CAAC/B,GAAG,EAAEC,GAAG,KAAK;IACtC;IACA,IAAIpB,UAAU,KAAK,SAAS,EAAE;;IAE9B;IACA,IAAIF,UAAU,KAAK,OAAO,EAAE;IAE5B,MAAMqD,KAAK,GAAGzD,KAAK,CAACyB,GAAG,CAAC,CAACC,GAAG,CAAC;;IAE7B;IACA,IAAIxB,aAAa,EAAE;MACjB;MACA,IAAIA,aAAa,CAACuB,GAAG,KAAKA,GAAG,IAAIvB,aAAa,CAACwB,GAAG,KAAKA,GAAG,EAAE;QAC1DvB,gBAAgB,CAAC,IAAI,CAAC;QACtB;MACF;;MAEA;MACA,IAAIsD,KAAK,IAAIA,KAAK,CAACN,KAAK,KAAK/C,UAAU,EAAE;QACvCD,gBAAgB,CAAC;UAAEsB,GAAG;UAAEC,GAAG;UAAE+B;QAAM,CAAC,CAAC;QACrC;MACF;;MAEA;MACA,IAAIhE,WAAW,CAACO,KAAK,EAAEE,aAAa,CAACuB,GAAG,EAAEvB,aAAa,CAACwB,GAAG,EAAED,GAAG,EAAEC,GAAG,EAAEhB,SAAS,CAAC,EAAE;QACjF,MAAM;UAAEV,KAAK,EAAEuC,QAAQ;UAAE7B,SAAS,EAAE8B;QAAa,CAAC,GAAG9C,QAAQ,CAC3DM,KAAK,EACLE,aAAa,CAACuB,GAAG,EACjBvB,aAAa,CAACwB,GAAG,EACjBD,GAAG,EACHC,GAAG,EACHhB,SACF,CAAC;;QAED;QACA,MAAM+B,WAAW,GAAGC,cAAc,CAACxC,aAAa,CAACuD,KAAK,CAACd,IAAI,CAAC;QAC5D,MAAMC,UAAU,GAAG,GAAGC,MAAM,CAACC,YAAY,CAAC,EAAE,GAAG5C,aAAa,CAACwB,GAAG,CAAC,GAAG,CAAC,GAAGxB,aAAa,CAACuB,GAAG,EAAE;QAC3F,MAAMsB,QAAQ,GAAG,GAAGF,MAAM,CAACC,YAAY,CAAC,EAAE,GAAGpB,GAAG,CAAC,GAAG,CAAC,GAAGD,GAAG,EAAE;QAC7D,MAAMuB,aAAa,GAAGhD,KAAK,CAACyB,GAAG,CAAC,CAACC,GAAG,CAAC,GAAG,GAAG,GAAG,EAAE;QAEhD,IAAIuB,YAAY,GAAG,GAAGR,WAAW,GAAGG,UAAU,GAAGI,aAAa,GAAGD,QAAQ,EAAE;;QAE3E;QACA,IAAIlD,WAAW,CAAC0C,QAAQ,EAAE,OAAO,CAAC,EAAE;UAClCU,YAAY,IAAI,GAAG;QACrB,CAAC,MAAM,IAAIrD,SAAS,CAAC2C,QAAQ,EAAE,OAAO,CAAC,EAAE;UACvCU,YAAY,IAAI,GAAG;QACrB;;QAEA;QACAhD,QAAQ,CAACsC,QAAQ,CAAC;QAClB5B,YAAY,CAAC6B,YAAY,CAAC;QAC1B/B,cAAc,CAAC,CAAC,GAAGD,WAAW,EAAE;UAC9B0C,QAAQ,EAAED,YAAY;UACtBE,KAAK,EAAE,OAAO;UACdC,IAAI,EAAE;YAAE3B,GAAG,EAAEvB,aAAa,CAACuB,GAAG;YAAEC,GAAG,EAAExB,aAAa,CAACwB;UAAI,CAAC;UACxD2B,EAAE,EAAE;YAAE5B,GAAG;YAAEC;UAAI;QACjB,CAAC,CAAC,CAAC;QACHvB,gBAAgB,CAAC,IAAI,CAAC;QACtBE,aAAa,CAAC,OAAO,CAAC;MACxB;IACF,CAAC,MAAM;MACL;MACA,IAAIoD,KAAK,IAAIA,KAAK,CAACN,KAAK,KAAK/C,UAAU,EAAE;QACvCD,gBAAgB,CAAC;UAAEsB,GAAG;UAAEC,GAAG;UAAE+B;QAAM,CAAC,CAAC;MACvC;IACF;EACF,CAAC;EAED,MAAMC,SAAS,GAAGA,CAAA,KAAM;IACtBzD,QAAQ,CAACT,eAAe,CAAC,CAAC,CAAC;IAC3BW,gBAAgB,CAAC,IAAI,CAAC;IACtBE,aAAa,CAAC,OAAO,CAAC;IACtBE,aAAa,CAAC,SAAS,CAAC;IACxBE,cAAc,CAAC,EAAE,CAAC;IAClBE,YAAY,CAAC;MACXC,eAAe,EAAE,IAAI;MACrBC,cAAc,EAAE;QACdC,KAAK,EAAE;UAAEC,QAAQ,EAAE,IAAI;UAAEC,SAAS,EAAE;QAAK,CAAC;QAC1CC,KAAK,EAAE;UAAEF,QAAQ,EAAE,IAAI;UAAEC,SAAS,EAAE;QAAK;MAC3C;IACF,CAAC,CAAC;IACFG,qBAAqB,CAAC,EAAE,CAAC;IACzBE,iBAAiB,CAAC,IAAI,CAAC;EACzB,CAAC;EAED,oBACElC,KAAA,CAAAwE,aAAA;IAAKC,SAAS,EAAC,KAAK;IAAAC,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBAClB/E,KAAA,CAAAwE,aAAA;IAAAE,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAI,UAAY,CAAC,eACjB/E,KAAA,CAAAwE,aAAA;IAAKC,SAAS,EAAC,gBAAgB;IAAAC,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBAC7B/E,KAAA,CAAAwE,aAAA,CAACrE,UAAU;IACTU,KAAK,EAAEA,KAAM;IACbE,aAAa,EAAEA,aAAc;IAC7BiE,aAAa,EAAEX,iBAAkB;IACjCtC,kBAAkB,EAAEA,kBAAmB;IACvCE,cAAc,EAAEA,cAAe;IAC/BgD,QAAQ,EAAE5D,WAAW,CAAC6D,MAAM,GAAG,CAAC,GAAG7D,WAAW,CAACA,WAAW,CAAC6D,MAAM,GAAG,CAAC,CAAC,GAAG,IAAK;IAAAR,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,CAC/E,CAAC,eACF/E,KAAA,CAAAwE,aAAA,CAACpE,QAAQ;IACPa,UAAU,EAAEA,UAAW;IACvBE,UAAU,EAAEA,UAAW;IACvBE,WAAW,EAAEA,WAAY;IACzB8D,WAAW,EAAEZ,SAAU;IACvB9D,SAAS,EAAEwB,cAAc,KAAK,IAAK;IAAAyC,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,CACpC,CACE,CAAC,eACN/E,KAAA,CAAAwE,aAAA;IAAKC,SAAS,EAAC,YAAY;IAAAC,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,gBACzB/E,KAAA,CAAAwE,aAAA;IAAAE,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAG,sDAAuD,CAAC,eAC3D/E,KAAA,CAAAwE,aAAA;IAAAE,MAAA;IAAAC,QAAA;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA;EAAA,GAAG,OAAE,EAAC,IAAIK,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,EAAC,WAAY,CACxC,CACF,CAAC;AAEV;AAEA,eAAezE,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module"}