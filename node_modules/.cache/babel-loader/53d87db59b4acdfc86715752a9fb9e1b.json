{"ast":null,"code":"// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n\n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = {\n      type: 'pawn',\n      color: 'black',\n      hasMoved: false\n    };\n    board[6][col] = {\n      type: 'pawn',\n      color: 'white',\n      hasMoved: false\n    };\n  }\n\n  // Set up rooks\n  board[0][0] = {\n    type: 'rook',\n    color: 'black',\n    hasMoved: false\n  };\n  board[0][7] = {\n    type: 'rook',\n    color: 'black',\n    hasMoved: false\n  };\n  board[7][0] = {\n    type: 'rook',\n    color: 'white',\n    hasMoved: false\n  };\n  board[7][7] = {\n    type: 'rook',\n    color: 'white',\n    hasMoved: false\n  };\n\n  // Set up knights\n  board[0][1] = {\n    type: 'knight',\n    color: 'black'\n  };\n  board[0][6] = {\n    type: 'knight',\n    color: 'black'\n  };\n  board[7][1] = {\n    type: 'knight',\n    color: 'white'\n  };\n  board[7][6] = {\n    type: 'knight',\n    color: 'white'\n  };\n\n  // Set up bishops\n  board[0][2] = {\n    type: 'bishop',\n    color: 'black'\n  };\n  board[0][5] = {\n    type: 'bishop',\n    color: 'black'\n  };\n  board[7][2] = {\n    type: 'bishop',\n    color: 'white'\n  };\n  board[7][5] = {\n    type: 'bishop',\n    color: 'white'\n  };\n\n  // Set up queens\n  board[0][3] = {\n    type: 'queen',\n    color: 'black'\n  };\n  board[7][3] = {\n    type: 'queen',\n    color: 'white'\n  };\n\n  // Set up kings\n  board[0][4] = {\n    type: 'king',\n    color: 'black',\n    hasMoved: false\n  };\n  board[7][4] = {\n    type: 'king',\n    color: 'white',\n    hasMoved: false\n  };\n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = board => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return {\n          row,\n          col\n        };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row + pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row + pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n\n  // Check attacks from knights\n  const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n\n  // Check attacks from bishops, rooks, and queens\n  const directions = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' || piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir) || piece.type === 'rook' && (rowDir === 0 || colDir === 0)) {\n            return true;\n          }\n\n          // King can attack adjacent squares\n          if (piece.type === 'king' && Math.abs(newRow - row) <= 1 && Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n\n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  // Check if the coordinates are valid\n  if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 || toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {\n    return false;\n  }\n\n  // Check if there is a piece at the starting position\n  const piece = board[fromRow][fromCol];\n  if (!piece) {\n    return false;\n  }\n\n  // Check if the destination has a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) {\n    return false;\n  }\n\n  // Check piece-specific movement rules\n  let isValid = false;\n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n\n  // If the move is valid according to piece rules, check if it would leave the king in check\n  if (isValid) {\n    // Make a temporary move\n    const {\n      board: tempBoard\n    } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n\n    // Check if the king is in check after the move\n    const kingInCheck = isInCheck(tempBoard, piece.color);\n\n    // If the king is in check, the move is not valid\n    if (kingInCheck) {\n      return false;\n    }\n  }\n  return isValid;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n\n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n\n  // Moving forward two squares from starting position\n  if (fromCol === toCol && !piece.hasMoved && toRow === fromRow + 2 * direction && !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n\n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n\n    // En passant capture\n    if (!board[toRow][toCol] && gameState.enPassantTarget && toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n\n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  return rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2;\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  if (rowDiff !== colDiff) return false;\n\n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n\n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n\n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n\n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) && !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) && !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  return false;\n};\n\n// Check if a pawn can be promoted\nexport const isPawnPromotion = (piece, toRow) => {\n  if (!piece || piece.type !== 'pawn') return false;\n\n  // White pawns promote on row 0, black pawns on row 7\n  return piece.color === 'white' && toRow === 0 || piece.color === 'black' && toRow === 7;\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece = null) => {\n  // Create a deep copy of the board and game state\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const newGameState = JSON.parse(JSON.stringify(gameState));\n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n\n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[toRow][toCol - 1] = newBoard[toRow][7]; // Move rook\n      newBoard[toRow][7] = null; // Remove rook from original position\n    }\n    // Queenside castling\n    else {\n      newBoard[toRow][toCol + 1] = newBoard[toRow][0]; // Move rook\n      newBoard[toRow][0] = null; // Remove rook from original position\n    }\n  }\n\n  // Handle en passant capture\n  if (piece.type === 'pawn' && fromCol !== toCol && !targetPiece) {\n    // This is a diagonal move without a target piece, must be en passant\n    newBoard[fromRow][toCol] = null; // Capture the pawn that just moved\n  }\n\n  // Update en passant target\n  newGameState.enPassantTarget = null;\n  if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {\n    newGameState.enPassantTarget = {\n      row: (fromRow + toRow) / 2,\n      col: fromCol\n    };\n  }\n\n  // Update castling rights\n  if (piece.type === 'king') {\n    newGameState.castlingRights[piece.color].kingSide = false;\n    newGameState.castlingRights[piece.color].queenSide = false;\n  } else if (piece.type === 'rook') {\n    if (fromRow === 7 && fromCol === 0 && piece.color === 'white') {\n      newGameState.castlingRights.white.queenSide = false;\n    } else if (fromRow === 7 && fromCol === 7 && piece.color === 'white') {\n      newGameState.castlingRights.white.kingSide = false;\n    } else if (fromRow === 0 && fromCol === 0 && piece.color === 'black') {\n      newGameState.castlingRights.black.queenSide = false;\n    } else if (fromRow === 0 && fromCol === 7 && piece.color === 'black') {\n      newGameState.castlingRights.black.kingSide = false;\n    }\n  }\n\n  // Handle pawn promotion\n  if (piece.type === 'pawn' && isPawnPromotion(piece, toRow) && promotionPiece) {\n    // Create a new piece of the specified type\n    newBoard[toRow][toCol] = {\n      type: promotionPiece,\n      color: piece.color\n    };\n  } else {\n    // Regular move\n    newBoard[toRow][toCol] = piece;\n  }\n\n  // Remove the piece from its original position\n  newBoard[fromRow][fromCol] = null;\n  return {\n    board: newBoard,\n    gameState: newGameState\n  };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color) => {\n  // If not in check, can't be checkmate\n  if (!isInCheck(board, color)) return false;\n\n  // Check if any move can get out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color) => {\n  // If in check, it's not stalemate\n  if (isInCheck(board, color)) return false;\n\n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = board => {\n  let score = 0;\n\n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n\n        // Add positional bonuses\n        let positionalValue = 0;\n\n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n\n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n\n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n\n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          positionalValue += diagonalMoves * 0.05;\n        }\n\n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n\n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(Math.abs(0 - row) + Math.abs(0 - col), Math.abs(0 - row) + Math.abs(7 - col), Math.abs(7 - row) + Math.abs(0 - col), Math.abs(7 - row) + Math.abs(7 - col));\n          positionalValue += centerDistance * 0.1;\n        }\n        const totalValue = value + positionalValue;\n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n\n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black')) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white')) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black')) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white')) {\n      score -= 0.5; // White is in check\n    }\n  }\n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n\n  // Check for terminal states\n  if (isCheckmate(board, 'white')) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black')) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return 0; // Draw\n  }\n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n\n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n\n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  for (const move of moves) {\n    const {\n      fromRow,\n      fromCol,\n      toRow,\n      toCol\n    } = move;\n    const {\n      board: newBoard,\n      gameState: newGameState\n    } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n\n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    if (isMaximizing && value > bestValue || !isMaximizing && value < bestValue) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  return bestMove;\n};","map":{"version":3,"names":["PIECE_VALUES","initializeBoard","board","Array","fill","map","col","type","color","hasMoved","cloneBoard","JSON","parse","stringify","findKing","row","piece","isSquareUnderAttack","attackerColor","pawnDirection","knightMoves","rowOffset","colOffset","newRow","newCol","directions","rowDir","colDir","Math","abs","isInCheck","kingPos","opponentColor","wouldBeInCheck","fromRow","fromCol","toRow","toCol","newBoard","isValidMove","gameState","targetPiece","isValid","isValidPawnMove","isValidKnightMove","isValidBishopMove","isValidRookMove","isValidQueenMove","isValidKingMove","tempBoard","makeMove","kingInCheck","direction","enPassantTarget","start","min","end","max","rowDiff","colDiff","rowDirection","colDirection","i","rook","isPawnPromotion","promotionPiece","newGameState","castlingRights","kingSide","queenSide","white","black","isCheckmate","isStalemate","evaluateBoard","score","value","positionalValue","advancementBonus","centerDistance","diagonalMoves","openFile","r","totalValue","findAllValidMoves","moves","push","minimax","depth","alpha","beta","isMaximizing","maxEval","Infinity","move","evaluation","minEval","getAIMove","length","bestMove","bestValue","sort","a","b","aCapture","bCapture","isCapture","searchDepth"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/utils/chessLogic.js"],"sourcesContent":["// Chess piece types and their values\nconst PIECE_VALUES = {\n  'pawn': 1,\n  'knight': 3,\n  'bishop': 3,\n  'rook': 5,\n  'queen': 9,\n  'king': 0 // King has no material value for evaluation\n};\n\n// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n  \n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = { type: 'pawn', color: 'black', hasMoved: false };\n    board[6][col] = { type: 'pawn', color: 'white', hasMoved: false };\n  }\n  \n  // Set up rooks\n  board[0][0] = { type: 'rook', color: 'black', hasMoved: false };\n  board[0][7] = { type: 'rook', color: 'black', hasMoved: false };\n  board[7][0] = { type: 'rook', color: 'white', hasMoved: false };\n  board[7][7] = { type: 'rook', color: 'white', hasMoved: false };\n  \n  // Set up knights\n  board[0][1] = { type: 'knight', color: 'black' };\n  board[0][6] = { type: 'knight', color: 'black' };\n  board[7][1] = { type: 'knight', color: 'white' };\n  board[7][6] = { type: 'knight', color: 'white' };\n  \n  // Set up bishops\n  board[0][2] = { type: 'bishop', color: 'black' };\n  board[0][5] = { type: 'bishop', color: 'black' };\n  board[7][2] = { type: 'bishop', color: 'white' };\n  board[7][5] = { type: 'bishop', color: 'white' };\n  \n  // Set up queens\n  board[0][3] = { type: 'queen', color: 'black' };\n  board[7][3] = { type: 'queen', color: 'white' };\n  \n  // Set up kings\n  board[0][4] = { type: 'king', color: 'black', hasMoved: false };\n  board[7][4] = { type: 'king', color: 'white', hasMoved: false };\n  \n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = (board) => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Find the position of the king for a given color\nexport const findKing = (board, color) => {\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.type === 'king' && piece.color === color) {\n        return { row, col };\n      }\n    }\n  }\n  return null;\n};\n\n// Check if a square is under attack by the opponent\nexport const isSquareUnderAttack = (board, row, col, attackerColor) => {\n  // Check attacks from pawns\n  const pawnDirection = attackerColor === 'white' ? -1 : 1;\n  if (row + pawnDirection >= 0 && row + pawnDirection < 8) {\n    if (col - 1 >= 0) {\n      const piece = board[row + pawnDirection][col - 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n    if (col + 1 < 8) {\n      const piece = board[row + pawnDirection][col + 1];\n      if (piece && piece.type === 'pawn' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from knights\n  const knightMoves = [\n    [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n    [1, -2], [1, 2], [2, -1], [2, 1]\n  ];\n  \n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    \n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      if (piece && piece.type === 'knight' && piece.color === attackerColor) {\n        return true;\n      }\n    }\n  }\n  \n  // Check attacks from bishops, rooks, and queens\n  const directions = [\n    [-1, -1], [-1, 0], [-1, 1], [0, -1],\n    [0, 1], [1, -1], [1, 0], [1, 1]\n  ];\n  \n  for (const [rowDir, colDir] of directions) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    \n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const piece = board[newRow][newCol];\n      \n      if (piece) {\n        if (piece.color === attackerColor) {\n          if (piece.type === 'queen' ||\n              (piece.type === 'bishop' && Math.abs(rowDir) === Math.abs(colDir)) ||\n              (piece.type === 'rook' && (rowDir === 0 || colDir === 0))) {\n            return true;\n          }\n          \n          // King can attack adjacent squares\n          if (piece.type === 'king' && \n              Math.abs(newRow - row) <= 1 && \n              Math.abs(newCol - col) <= 1) {\n            return true;\n          }\n        }\n        break; // Stop checking in this direction if we hit any piece\n      }\n      \n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  \n  return false;\n};\n\n// Check if the king of the given color is in check\nexport const isInCheck = (board, color) => {\n  const kingPos = findKing(board, color);\n  if (!kingPos) return false;\n  \n  const opponentColor = color === 'white' ? 'black' : 'white';\n  return isSquareUnderAttack(board, kingPos.row, kingPos.col, opponentColor);\n};\n\n// Check if a move would leave the king in check\nconst wouldBeInCheck = (board, fromRow, fromCol, toRow, toCol, color) => {\n  // Make the move on a cloned board\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // Check if the king is in check after the move\n  return isInCheck(newBoard, color);\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  // Check if the coordinates are valid\n  if (fromRow < 0 || fromRow > 7 || fromCol < 0 || fromCol > 7 ||\n      toRow < 0 || toRow > 7 || toCol < 0 || toCol > 7) {\n    return false;\n  }\n  \n  // Check if there is a piece at the starting position\n  const piece = board[fromRow][fromCol];\n  if (!piece) {\n    return false;\n  }\n  \n  // Check if the destination has a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) {\n    return false;\n  }\n  \n  // Check piece-specific movement rules\n  let isValid = false;\n  \n  switch (piece.type) {\n    case 'pawn':\n      isValid = isValidPawnMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    case 'knight':\n      isValid = isValidKnightMove(fromRow, fromCol, toRow, toCol);\n      break;\n    case 'bishop':\n      isValid = isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'rook':\n      isValid = isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'queen':\n      isValid = isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n      break;\n    case 'king':\n      isValid = isValidKingMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      break;\n    default:\n      isValid = false;\n  }\n  \n  // If the move is valid according to piece rules, check if it would leave the king in check\n  if (isValid) {\n    // Make a temporary move\n    const { board: tempBoard } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Check if the king is in check after the move\n    const kingInCheck = isInCheck(tempBoard, piece.color);\n    \n    // If the king is in check, the move is not valid\n    if (kingInCheck) {\n      return false;\n    }\n  }\n  \n  return isValid;\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  \n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Moving forward two squares from starting position\n  if (fromCol === toCol && !piece.hasMoved && \n      toRow === fromRow + 2 * direction &&\n      !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction) {\n    // Normal capture\n    if (board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n      return true;\n    }\n    \n    // En passant capture\n    if (!board[toRow][toCol] && gameState.enPassantTarget &&\n        toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col) {\n      return true;\n    }\n  }\n  \n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  \n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  \n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  if (rowDiff !== colDiff) return false;\n  \n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  \n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  \n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol, gameState) => {\n  const piece = board[fromRow][fromCol];\n  \n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  // Normal king move\n  if (rowDiff <= 1 && colDiff <= 1) {\n    return true;\n  }\n  \n  // Castling\n  if (rowDiff === 0 && colDiff === 2 && !piece.hasMoved && !isInCheck(board, piece.color)) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      const rook = board[fromRow][7];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][5] && !board[fromRow][6]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 5, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 6, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n    // Queenside castling\n    else {\n      const rook = board[fromRow][0];\n      if (rook && rook.type === 'rook' && rook.color === piece.color && !rook.hasMoved) {\n        // Check if squares between king and rook are empty\n        if (!board[fromRow][1] && !board[fromRow][2] && !board[fromRow][3]) {\n          // Check if king passes through or ends up on a square under attack\n          const opponentColor = piece.color === 'white' ? 'black' : 'white';\n          if (!isSquareUnderAttack(board, fromRow, 2, opponentColor) &&\n              !isSquareUnderAttack(board, fromRow, 3, opponentColor)) {\n            return true;\n          }\n        }\n      }\n    }\n  }\n  \n  return false;\n};\n\n// Check if a pawn can be promoted\nexport const isPawnPromotion = (piece, toRow) => {\n  if (!piece || piece.type !== 'pawn') return false;\n  \n  // White pawns promote on row 0, black pawns on row 7\n  return (piece.color === 'white' && toRow === 0) || (piece.color === 'black' && toRow === 7);\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol, gameState, promotionPiece = null) => {\n  // Create a deep copy of the board and game state\n  const newBoard = JSON.parse(JSON.stringify(board));\n  const newGameState = JSON.parse(JSON.stringify(gameState));\n  \n  const piece = newBoard[fromRow][fromCol];\n  const targetPiece = newBoard[toRow][toCol];\n  \n  // Handle castling\n  if (piece.type === 'king' && Math.abs(fromCol - toCol) === 2) {\n    // Kingside castling\n    if (toCol > fromCol) {\n      newBoard[toRow][toCol - 1] = newBoard[toRow][7]; // Move rook\n      newBoard[toRow][7] = null; // Remove rook from original position\n    } \n    // Queenside castling\n    else {\n      newBoard[toRow][toCol + 1] = newBoard[toRow][0]; // Move rook\n      newBoard[toRow][0] = null; // Remove rook from original position\n    }\n  }\n  \n  // Handle en passant capture\n  if (piece.type === 'pawn' && fromCol !== toCol && !targetPiece) {\n    // This is a diagonal move without a target piece, must be en passant\n    newBoard[fromRow][toCol] = null; // Capture the pawn that just moved\n  }\n  \n  // Update en passant target\n  newGameState.enPassantTarget = null;\n  if (piece.type === 'pawn' && Math.abs(fromRow - toRow) === 2) {\n    newGameState.enPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };\n  }\n  \n  // Update castling rights\n  if (piece.type === 'king') {\n    newGameState.castlingRights[piece.color].kingSide = false;\n    newGameState.castlingRights[piece.color].queenSide = false;\n  } else if (piece.type === 'rook') {\n    if (fromRow === 7 && fromCol === 0 && piece.color === 'white') {\n      newGameState.castlingRights.white.queenSide = false;\n    } else if (fromRow === 7 && fromCol === 7 && piece.color === 'white') {\n      newGameState.castlingRights.white.kingSide = false;\n    } else if (fromRow === 0 && fromCol === 0 && piece.color === 'black') {\n      newGameState.castlingRights.black.queenSide = false;\n    } else if (fromRow === 0 && fromCol === 7 && piece.color === 'black') {\n      newGameState.castlingRights.black.kingSide = false;\n    }\n  }\n  \n  // Handle pawn promotion\n  if (piece.type === 'pawn' && isPawnPromotion(piece, toRow) && promotionPiece) {\n    // Create a new piece of the specified type\n    newBoard[toRow][toCol] = { type: promotionPiece, color: piece.color };\n  } else {\n    // Regular move\n    newBoard[toRow][toCol] = piece;\n  }\n  \n  // Remove the piece from its original position\n  newBoard[fromRow][fromCol] = null;\n  \n  return { board: newBoard, gameState: newGameState };\n};\n\n// Check if a player is in checkmate\nexport const isCheckmate = (board, color) => {\n  // If not in check, can't be checkmate\n  if (!isInCheck(board, color)) return false;\n  \n  // Check if any move can get out of check\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return true;\n};\n\n// Check if a player is in stalemate\nexport const isStalemate = (board, color) => {\n  // If in check, it's not stalemate\n  if (isInCheck(board, color)) return false;\n  \n  // Check if any legal move exists\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, {})) {\n              return false;\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return true;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = (board) => {\n  let score = 0;\n  \n  // Material evaluation\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = PIECE_VALUES[piece.type];\n        \n        // Add positional bonuses\n        let positionalValue = 0;\n        \n        // Pawns: encourage advancement and center control\n        if (piece.type === 'pawn') {\n          // Advancement bonus\n          const advancementBonus = piece.color === 'white' ? (7 - row) * 0.1 : row * 0.1;\n          positionalValue += advancementBonus;\n          \n          // Center control bonus\n          if ((col === 3 || col === 4) && (row === 3 || row === 4)) {\n            positionalValue += 0.2;\n          }\n        }\n        \n        // Knights: bonus for being near the center\n        if (piece.type === 'knight') {\n          const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);\n          positionalValue += (4 - centerDistance) * 0.1;\n        }\n        \n        // Bishops: bonus for controlling diagonals\n        if (piece.type === 'bishop') {\n          // Count available diagonal moves as a proxy for bishop activity\n          let diagonalMoves = 0;\n          const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n          \n          for (const [rowDir, colDir] of directions) {\n            let newRow = row + rowDir;\n            let newCol = col + colDir;\n            \n            while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              if (!board[newRow][newCol]) {\n                diagonalMoves++;\n              } else {\n                break;\n              }\n              newRow += rowDir;\n              newCol += colDir;\n            }\n          }\n          \n          positionalValue += diagonalMoves * 0.05;\n        }\n        \n        // Rooks: bonus for open files\n        if (piece.type === 'rook') {\n          let openFile = true;\n          for (let r = 0; r < 8; r++) {\n            if (r !== row && board[r][col] && board[r][col].type === 'pawn' && \n                board[r][col].color === piece.color) {\n              openFile = false;\n              break;\n            }\n          }\n          \n          if (openFile) {\n            positionalValue += 0.3;\n          }\n        }\n        \n        // King safety: penalize exposed king in the middle\n        if (piece.type === 'king') {\n          // In the opening and middlegame, the king should stay in a corner\n          const centerDistance = Math.min(\n            Math.abs(0 - row) + Math.abs(0 - col),\n            Math.abs(0 - row) + Math.abs(7 - col),\n            Math.abs(7 - row) + Math.abs(0 - col),\n            Math.abs(7 - row) + Math.abs(7 - col)\n          );\n          \n          positionalValue += centerDistance * 0.1;\n        }\n        \n        const totalValue = value + positionalValue;\n        \n        if (piece.color === 'white') {\n          score += totalValue;\n        } else {\n          score -= totalValue;\n        }\n      }\n    }\n  }\n  \n  // Check and checkmate evaluation\n  if (isCheckmate(board, 'black')) {\n    score += 1000; // White wins\n  } else if (isCheckmate(board, 'white')) {\n    score -= 1000; // Black wins\n  } else {\n    if (isInCheck(board, 'black')) {\n      score += 0.5; // Black is in check\n    }\n    if (isInCheck(board, 'white')) {\n      score -= 0.5; // White is in check\n    }\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              moves.push({ fromRow, fromCol, toRow, toCol });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm for AI with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, isMaximizing, gameState) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n  \n  // Check for terminal states\n  if (isCheckmate(board, 'white')) {\n    return -1000 - depth; // Black wins, prefer quicker checkmate\n  }\n  if (isCheckmate(board, 'black')) {\n    return 1000 + depth; // White wins, prefer quicker checkmate\n  }\n  if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    return 0; // Draw\n  }\n  \n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black', gameState);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, gameState) => {\n  const moves = findAllValidMoves(board, color, gameState);\n  if (moves.length === 0) return null;\n  \n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  \n  // Sort moves to improve alpha-beta pruning efficiency\n  // Try capturing moves first\n  moves.sort((a, b) => {\n    const aCapture = board[a.toRow][a.toCol] !== null ? 1 : 0;\n    const bCapture = board[b.toRow][b.toCol] !== null ? 1 : 0;\n    return bCapture - aCapture;\n  });\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n    \n    // Use a limited depth for performance (can be increased for stronger AI)\n    // Deeper depth for captures to reduce horizon effect\n    const isCapture = board[toRow][toCol] !== null;\n    const searchDepth = isCapture ? 3 : 2;\n    \n    const value = minimax(newBoard, searchDepth, -Infinity, Infinity, !isMaximizing, newGameState);\n    \n    if ((isMaximizing && value > bestValue) || (!isMaximizing && value < bestValue)) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}