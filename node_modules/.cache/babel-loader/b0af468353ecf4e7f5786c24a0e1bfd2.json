{"ast":null,"code":"import { makeMove, isValidMove,\n// eslint-disable-next-line no-unused-vars\nisInCheck, isCheckmate, isStalemate } from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [[0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 2, 3, 3, 2, 1, 1], [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5], [0, 0, 0, 2, 2, 0, 0, 0], [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5], [0.5, 1, 1, -2, -2, 1, 1, 0.5], [0, 0, 0, 0, 0, 0, 0, 0]],\n  'knight': [[-5, -4, -3, -3, -3, -3, -4, -5], [-4, -2, 0, 0, 0, 0, -2, -4], [-3, 0, 1, 1.5, 1.5, 1, 0, -3], [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3], [-3, 0, 1.5, 2, 2, 1.5, 0, -3], [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3], [-4, -2, 0, 0.5, 0.5, 0, -2, -4], [-5, -4, -3, -3, -3, -3, -4, -5]],\n  'bishop': [[-2, -1, -1, -1, -1, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 1, 1, 0.5, 0, -1], [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1], [-1, 0, 1, 1, 1, 1, 0, -1], [-1, 1, 1, 1, 1, 1, 1, -1], [-1, 0.5, 0, 0, 0, 0, 0.5, -1], [-2, -1, -1, -1, -1, -1, -1, -2]],\n  'rook': [[0, 0, 0, 0, 0, 0, 0, 0], [0.5, 1, 1, 1, 1, 1, 1, 0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [0, 0, 0, 0.5, 0.5, 0, 0, 0]],\n  'queen': [[-2, -1, -1, -0.5, -0.5, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1], [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1], [-1, 0, 0.5, 0, 0, 0, 0, -1], [-2, -1, -1, -0.5, -0.5, -1, -1, -2]],\n  'king': [[-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-2, -3, -3, -4, -4, -3, -3, -2], [-1, -2, -2, -2, -2, -2, -2, -1], [2, 2, 0, 0, 0, 0, 2, 2], [2, 3, 1, 0, 0, 1, 3, 2]]\n};\n\n// Memoization cache for position evaluation\nconst evaluationCache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (evaluationCache.size > MAX_CACHE_SIZE) {\n    // Clear the entire cache for simplicity and performance\n    evaluationCache.clear();\n  }\n};\n\n// Get a simple hash for the board position\nconst getBoardHash = board => {\n  let hash = '';\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        hash += `${row}${col}${piece.type[0]}${piece.color[0]}`;\n      }\n    }\n  }\n  return hash;\n};\n\n// Evaluate a single move\nconst evaluateMove = (board, move, gameState) => {\n  const {\n    fromRow,\n    fromCol,\n    toRow,\n    toCol\n  } = move;\n  const piece = board[fromRow][fromCol];\n  const targetPiece = board[toRow][toCol];\n  let score = 0;\n\n  // Capture value\n  if (targetPiece) {\n    score += pieceValues[targetPiece.type] * 2; // Prioritize captures\n  }\n\n  // Position improvement\n  const currentPositionValue = positionBonus[piece.type][piece.color === 'white' ? fromRow : 7 - fromRow][fromCol];\n  const newPositionValue = positionBonus[piece.type][piece.color === 'white' ? toRow : 7 - toRow][toCol];\n  score += (newPositionValue - currentPositionValue) * 0.5;\n\n  // Center control bonus\n  const centerDistance = Math.abs(3.5 - toRow) + Math.abs(3.5 - toCol);\n  score += (7 - centerDistance) * 0.2;\n\n  // Pawn advancement bonus\n  if (piece.type === 'pawn') {\n    const advancementBonus = piece.color === 'white' ? 7 - toRow : toRow;\n    score += advancementBonus * 0.5;\n\n    // Bonus for pawns near promotion\n    if (piece.color === 'white' && toRow <= 1 || piece.color === 'black' && toRow >= 6) {\n      score += 5;\n    }\n  }\n\n  // Avoid moving the king early in the game\n  if (piece.type === 'king') {\n    score -= 2;\n  }\n\n  // Encourage development of knights and bishops early\n  if ((piece.type === 'knight' || piece.type === 'bishop') && (piece.color === 'white' && fromRow === 7 || piece.color === 'black' && fromRow === 0)) {\n    score += 1;\n  }\n  return score;\n};\n\n// Knight move offsets for faster move generation\nconst knightOffsets = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n\n// Directional offsets for sliding pieces (bishop, rook, queen)\nconst directions = {\n  bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],\n  rook: [[-1, 0], [0, -1], [0, 1], [1, 0]],\n  queen: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n};\n\n// Generate moves for a specific piece - optimized for speed\nconst generatePieceMoves = (board, row, col, gameState) => {\n  const piece = board[row][col];\n  if (!piece) return [];\n  const moves = [];\n  switch (piece.type) {\n    case 'pawn':\n      {\n        const direction = piece.color === 'white' ? -1 : 1;\n\n        // Move forward one square\n        if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {\n          moves.push({\n            fromRow: row,\n            fromCol: col,\n            toRow: row + direction,\n            toCol: col,\n            isCapture: false\n          });\n\n          // Move forward two squares from starting position\n          if (!piece.hasMoved && row + 2 * direction >= 0 && row + 2 * direction < 8 && !board[row + direction][col] && !board[row + 2 * direction][col]) {\n            moves.push({\n              fromRow: row,\n              fromCol: col,\n              toRow: row + 2 * direction,\n              toCol: col,\n              isCapture: false\n            });\n          }\n        }\n\n        // Capture diagonally\n        for (const colOffset of [-1, 1]) {\n          if (col + colOffset >= 0 && col + colOffset < 8 && row + direction >= 0 && row + direction < 8) {\n            // Normal capture\n            if (board[row + direction][col + colOffset] && board[row + direction][col + colOffset].color !== piece.color) {\n              moves.push({\n                fromRow: row,\n                fromCol: col,\n                toRow: row + direction,\n                toCol: col + colOffset,\n                isCapture: true\n              });\n            }\n\n            // En passant capture\n            if (!board[row + direction][col + colOffset] && gameState.enPassantTarget && row + direction === gameState.enPassantTarget.row && col + colOffset === gameState.enPassantTarget.col) {\n              moves.push({\n                fromRow: row,\n                fromCol: col,\n                toRow: row + direction,\n                toCol: col + colOffset,\n                isCapture: true,\n                isEnPassant: true\n              });\n            }\n          }\n        }\n        break;\n      }\n    case 'knight':\n      {\n        for (const [rowOffset, colOffset] of knightOffsets) {\n          const newRow = row + rowOffset;\n          const newCol = col + colOffset;\n          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = board[newRow][newCol];\n            if (!targetPiece || targetPiece.color !== piece.color) {\n              moves.push({\n                fromRow: row,\n                fromCol: col,\n                toRow: newRow,\n                toCol: newCol,\n                isCapture: !!targetPiece\n              });\n            }\n          }\n        }\n        break;\n      }\n    case 'bishop':\n    case 'rook':\n    case 'queen':\n      {\n        const dirs = directions[piece.type];\n        for (const [rowDir, colDir] of dirs) {\n          let newRow = row + rowDir;\n          let newCol = col + colDir;\n          while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = board[newRow][newCol];\n            if (!targetPiece) {\n              moves.push({\n                fromRow: row,\n                fromCol: col,\n                toRow: newRow,\n                toCol: newCol,\n                isCapture: false\n              });\n            } else {\n              if (targetPiece.color !== piece.color) {\n                moves.push({\n                  fromRow: row,\n                  fromCol: col,\n                  toRow: newRow,\n                  toCol: newCol,\n                  isCapture: true\n                });\n              }\n              break; // Stop in this direction after hitting a piece\n            }\n            newRow += rowDir;\n            newCol += colDir;\n          }\n        }\n        break;\n      }\n    case 'king':\n      {\n        // Regular king moves\n        for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {\n          for (let colOffset = -1; colOffset <= 1; colOffset++) {\n            if (rowOffset === 0 && colOffset === 0) continue;\n            const newRow = row + rowOffset;\n            const newCol = col + colOffset;\n            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n              const targetPiece = board[newRow][newCol];\n              if (!targetPiece || targetPiece.color !== piece.color) {\n                moves.push({\n                  fromRow: row,\n                  fromCol: col,\n                  toRow: newRow,\n                  toCol: newCol,\n                  isCapture: !!targetPiece\n                });\n              }\n            }\n          }\n        }\n\n        // Castling\n        if (!piece.hasMoved && gameState.castlingRights) {\n          const castlingRights = gameState.castlingRights[piece.color];\n\n          // Kingside castling\n          if (castlingRights && castlingRights.kingSide && !board[row][col + 1] && !board[row][col + 2] && board[row][col + 3] && board[row][col + 3].type === 'rook' && !board[row][col + 3].hasMoved) {\n            moves.push({\n              fromRow: row,\n              fromCol: col,\n              toRow: row,\n              toCol: col + 2,\n              isCapture: false,\n              isCastling: true,\n              castlingSide: 'kingside'\n            });\n          }\n\n          // Queenside castling\n          if (castlingRights && castlingRights.queenSide && !board[row][col - 1] && !board[row][col - 2] && !board[row][col - 3] && board[row][col - 4] && board[row][col - 4].type === 'rook' && !board[row][col - 4].hasMoved) {\n            moves.push({\n              fromRow: row,\n              fromCol: col,\n              toRow: row,\n              toCol: col - 2,\n              isCapture: false,\n              isCastling: true,\n              castlingSide: 'queenside'\n            });\n          }\n        }\n        break;\n      }\n  }\n  return moves;\n};\n\n// Generate all valid moves for a player - optimized version\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  const candidateMoves = [];\n\n  // First, collect all candidate moves without checking if they're valid\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.color === color) {\n        const pieceMoves = generatePieceMoves(board, row, col, gameState);\n        candidateMoves.push(...pieceMoves);\n      }\n    }\n  }\n\n  // Then filter out moves that would leave the king in check\n  for (const move of candidateMoves) {\n    const {\n      fromRow,\n      fromCol,\n      toRow,\n      toCol\n    } = move;\n    if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n      moves.push(move);\n    }\n  }\n  return moves;\n};\n\n// Find the best move using a simple greedy algorithm\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Generate all valid moves\n  let moves = generateMoves(board, color, gameState);\n\n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n\n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n\n  // Add randomness based on difficulty\n  const randomChance = difficulty === 'easy' ? 0.3 : difficulty === 'medium' ? 0.15 : 0.05;\n  if (Math.random() < randomChance) {\n    const randomIndex = Math.floor(Math.random() * moves.length);\n    return moves[randomIndex];\n  }\n\n  // Check if we have this position cached\n  const boardHash = getBoardHash(board);\n  const cacheKey = `${boardHash}-${color}-${difficulty}`;\n  if (evaluationCache.has(cacheKey)) {\n    return evaluationCache.get(cacheKey);\n  }\n\n  // Evaluate each move\n  const evaluatedMoves = moves.map(move => {\n    const score = evaluateMove(board, move, gameState);\n    return {\n      ...move,\n      score\n    };\n  });\n\n  // Sort moves by score (descending for white, ascending for black)\n  evaluatedMoves.sort((a, b) => {\n    return color === 'white' ? b.score - a.score : a.score - b.score;\n  });\n\n  // Add some randomness to the top moves based on difficulty\n  const topMovesCount = difficulty === 'easy' ? 5 : difficulty === 'medium' ? 3 : 2;\n  const topMoves = evaluatedMoves.slice(0, Math.min(topMovesCount, evaluatedMoves.length));\n\n  // Select a random move from the top moves\n  const selectedIndex = Math.floor(Math.random() * topMoves.length);\n  const bestMove = topMoves[selectedIndex];\n\n  // Cache the result\n  evaluationCache.set(cacheKey, bestMove);\n  checkCacheSize();\n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n};","map":{"version":3,"names":["makeMove","isValidMove","isInCheck","isCheckmate","isStalemate","pieceValues","positionBonus","evaluationCache","Map","MAX_CACHE_SIZE","checkCacheSize","size","clear","getBoardHash","board","hash","row","col","piece","type","color","evaluateMove","move","gameState","fromRow","fromCol","toRow","toCol","targetPiece","score","currentPositionValue","newPositionValue","centerDistance","Math","abs","advancementBonus","knightOffsets","directions","bishop","rook","queen","generatePieceMoves","moves","direction","push","isCapture","hasMoved","colOffset","enPassantTarget","isEnPassant","rowOffset","newRow","newCol","dirs","rowDir","colDir","castlingRights","kingSide","isCastling","castlingSide","queenSide","generateMoves","candidateMoves","pieceMoves","findBestMove","difficulty","length","randomChance","random","randomIndex","floor","boardHash","cacheKey","has","get","evaluatedMoves","map","sort","a","b","topMovesCount","topMoves","slice","min","selectedIndex","bestMove","set","getAIMove"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/utils/aiPlayer.js"],"sourcesContent":["import { \n  makeMove, \n  isValidMove, \n  // eslint-disable-next-line no-unused-vars\n  isInCheck, \n  isCheckmate, \n  isStalemate \n} from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  'knight': [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  'bishop': [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  'rook': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  'queen': [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  'king': [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Memoization cache for position evaluation\nconst evaluationCache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (evaluationCache.size > MAX_CACHE_SIZE) {\n    // Clear the entire cache for simplicity and performance\n    evaluationCache.clear();\n  }\n};\n\n// Get a simple hash for the board position\nconst getBoardHash = (board) => {\n  let hash = '';\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        hash += `${row}${col}${piece.type[0]}${piece.color[0]}`;\n      }\n    }\n  }\n  return hash;\n};\n\n// Evaluate a single move\nconst evaluateMove = (board, move, gameState) => {\n  const { fromRow, fromCol, toRow, toCol } = move;\n  const piece = board[fromRow][fromCol];\n  const targetPiece = board[toRow][toCol];\n  \n  let score = 0;\n  \n  // Capture value\n  if (targetPiece) {\n    score += pieceValues[targetPiece.type] * 2; // Prioritize captures\n  }\n  \n  // Position improvement\n  const currentPositionValue = positionBonus[piece.type][piece.color === 'white' ? fromRow : 7 - fromRow][fromCol];\n  const newPositionValue = positionBonus[piece.type][piece.color === 'white' ? toRow : 7 - toRow][toCol];\n  score += (newPositionValue - currentPositionValue) * 0.5;\n  \n  // Center control bonus\n  const centerDistance = Math.abs(3.5 - toRow) + Math.abs(3.5 - toCol);\n  score += (7 - centerDistance) * 0.2;\n  \n  // Pawn advancement bonus\n  if (piece.type === 'pawn') {\n    const advancementBonus = piece.color === 'white' ? (7 - toRow) : toRow;\n    score += advancementBonus * 0.5;\n    \n    // Bonus for pawns near promotion\n    if ((piece.color === 'white' && toRow <= 1) || (piece.color === 'black' && toRow >= 6)) {\n      score += 5;\n    }\n  }\n  \n  // Avoid moving the king early in the game\n  if (piece.type === 'king') {\n    score -= 2;\n  }\n  \n  // Encourage development of knights and bishops early\n  if ((piece.type === 'knight' || piece.type === 'bishop') && \n      ((piece.color === 'white' && fromRow === 7) || (piece.color === 'black' && fromRow === 0))) {\n    score += 1;\n  }\n  \n  return score;\n};\n\n// Knight move offsets for faster move generation\nconst knightOffsets = [\n  [-2, -1], [-2, 1], [-1, -2], [-1, 2],\n  [1, -2], [1, 2], [2, -1], [2, 1]\n];\n\n// Directional offsets for sliding pieces (bishop, rook, queen)\nconst directions = {\n  bishop: [[-1, -1], [-1, 1], [1, -1], [1, 1]],\n  rook: [[-1, 0], [0, -1], [0, 1], [1, 0]],\n  queen: [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n};\n\n// Generate moves for a specific piece - optimized for speed\nconst generatePieceMoves = (board, row, col, gameState) => {\n  const piece = board[row][col];\n  if (!piece) return [];\n  \n  const moves = [];\n  \n  switch (piece.type) {\n    case 'pawn': {\n      const direction = piece.color === 'white' ? -1 : 1;\n      \n      // Move forward one square\n      if (row + direction >= 0 && row + direction < 8 && !board[row + direction][col]) {\n        moves.push({ fromRow: row, fromCol: col, toRow: row + direction, toCol: col, isCapture: false });\n        \n        // Move forward two squares from starting position\n        if (!piece.hasMoved && \n            row + 2 * direction >= 0 && row + 2 * direction < 8 && \n            !board[row + direction][col] && !board[row + 2 * direction][col]) {\n          moves.push({ fromRow: row, fromCol: col, toRow: row + 2 * direction, toCol: col, isCapture: false });\n        }\n      }\n      \n      // Capture diagonally\n      for (const colOffset of [-1, 1]) {\n        if (col + colOffset >= 0 && col + colOffset < 8 && row + direction >= 0 && row + direction < 8) {\n          // Normal capture\n          if (board[row + direction][col + colOffset] && \n              board[row + direction][col + colOffset].color !== piece.color) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: row + direction, \n              toCol: col + colOffset, \n              isCapture: true \n            });\n          }\n          \n          // En passant capture\n          if (!board[row + direction][col + colOffset] && gameState.enPassantTarget &&\n              row + direction === gameState.enPassantTarget.row && \n              col + colOffset === gameState.enPassantTarget.col) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: row + direction, \n              toCol: col + colOffset, \n              isCapture: true,\n              isEnPassant: true\n            });\n          }\n        }\n      }\n      break;\n    }\n    \n    case 'knight': {\n      for (const [rowOffset, colOffset] of knightOffsets) {\n        const newRow = row + rowOffset;\n        const newCol = col + colOffset;\n        \n        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n          const targetPiece = board[newRow][newCol];\n          if (!targetPiece || targetPiece.color !== piece.color) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: newRow, \n              toCol: newCol, \n              isCapture: !!targetPiece \n            });\n          }\n        }\n      }\n      break;\n    }\n    \n    case 'bishop':\n    case 'rook':\n    case 'queen': {\n      const dirs = directions[piece.type];\n      \n      for (const [rowDir, colDir] of dirs) {\n        let newRow = row + rowDir;\n        let newCol = col + colDir;\n        \n        while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n          const targetPiece = board[newRow][newCol];\n          \n          if (!targetPiece) {\n            moves.push({ \n              fromRow: row, \n              fromCol: col, \n              toRow: newRow, \n              toCol: newCol, \n              isCapture: false \n            });\n          } else {\n            if (targetPiece.color !== piece.color) {\n              moves.push({ \n                fromRow: row, \n                fromCol: col, \n                toRow: newRow, \n                toCol: newCol, \n                isCapture: true \n              });\n            }\n            break; // Stop in this direction after hitting a piece\n          }\n          \n          newRow += rowDir;\n          newCol += colDir;\n        }\n      }\n      break;\n    }\n    \n    case 'king': {\n      // Regular king moves\n      for (let rowOffset = -1; rowOffset <= 1; rowOffset++) {\n        for (let colOffset = -1; colOffset <= 1; colOffset++) {\n          if (rowOffset === 0 && colOffset === 0) continue;\n          \n          const newRow = row + rowOffset;\n          const newCol = col + colOffset;\n          \n          if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n            const targetPiece = board[newRow][newCol];\n            if (!targetPiece || targetPiece.color !== piece.color) {\n              moves.push({ \n                fromRow: row, \n                fromCol: col, \n                toRow: newRow, \n                toCol: newCol, \n                isCapture: !!targetPiece \n              });\n            }\n          }\n        }\n      }\n      \n      // Castling\n      if (!piece.hasMoved && gameState.castlingRights) {\n        const castlingRights = gameState.castlingRights[piece.color];\n        \n        // Kingside castling\n        if (castlingRights && castlingRights.kingSide && \n            !board[row][col + 1] && !board[row][col + 2] &&\n            board[row][col + 3] && board[row][col + 3].type === 'rook' && \n            !board[row][col + 3].hasMoved) {\n          moves.push({ \n            fromRow: row, \n            fromCol: col, \n            toRow: row, \n            toCol: col + 2, \n            isCapture: false,\n            isCastling: true,\n            castlingSide: 'kingside'\n          });\n        }\n        \n        // Queenside castling\n        if (castlingRights && castlingRights.queenSide && \n            !board[row][col - 1] && !board[row][col - 2] && !board[row][col - 3] &&\n            board[row][col - 4] && board[row][col - 4].type === 'rook' && \n            !board[row][col - 4].hasMoved) {\n          moves.push({ \n            fromRow: row, \n            fromCol: col, \n            toRow: row, \n            toCol: col - 2, \n            isCapture: false,\n            isCastling: true,\n            castlingSide: 'queenside'\n          });\n        }\n      }\n      break;\n    }\n  }\n  \n  return moves;\n};\n\n// Generate all valid moves for a player - optimized version\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  const candidateMoves = [];\n  \n  // First, collect all candidate moves without checking if they're valid\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && piece.color === color) {\n        const pieceMoves = generatePieceMoves(board, row, col, gameState);\n        candidateMoves.push(...pieceMoves);\n      }\n    }\n  }\n  \n  // Then filter out moves that would leave the king in check\n  for (const move of candidateMoves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n      moves.push(move);\n    }\n  }\n  \n  return moves;\n};\n\n// Find the best move using a simple greedy algorithm\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Generate all valid moves\n  let moves = generateMoves(board, color, gameState);\n  \n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n  \n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n  \n  // Add randomness based on difficulty\n  const randomChance = difficulty === 'easy' ? 0.3 : (difficulty === 'medium' ? 0.15 : 0.05);\n  if (Math.random() < randomChance) {\n    const randomIndex = Math.floor(Math.random() * moves.length);\n    return moves[randomIndex];\n  }\n  \n  // Check if we have this position cached\n  const boardHash = getBoardHash(board);\n  const cacheKey = `${boardHash}-${color}-${difficulty}`;\n  \n  if (evaluationCache.has(cacheKey)) {\n    return evaluationCache.get(cacheKey);\n  }\n  \n  // Evaluate each move\n  const evaluatedMoves = moves.map(move => {\n    const score = evaluateMove(board, move, gameState);\n    return { ...move, score };\n  });\n  \n  // Sort moves by score (descending for white, ascending for black)\n  evaluatedMoves.sort((a, b) => {\n    return color === 'white' ? b.score - a.score : a.score - b.score;\n  });\n  \n  // Add some randomness to the top moves based on difficulty\n  const topMovesCount = difficulty === 'easy' ? 5 : (difficulty === 'medium' ? 3 : 2);\n  const topMoves = evaluatedMoves.slice(0, Math.min(topMovesCount, evaluatedMoves.length));\n  \n  // Select a random move from the top moves\n  const selectedIndex = Math.floor(Math.random() * topMoves.length);\n  const bestMove = topMoves[selectedIndex];\n  \n  // Cache the result\n  evaluationCache.set(cacheKey, bestMove);\n  checkCacheSize();\n  \n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}