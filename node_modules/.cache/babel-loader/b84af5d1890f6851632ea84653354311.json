{"ast":null,"code":"// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n\n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = {\n      type: 'pawn',\n      color: 'black'\n    };\n    board[6][col] = {\n      type: 'pawn',\n      color: 'white'\n    };\n  }\n\n  // Set up rooks\n  board[0][0] = {\n    type: 'rook',\n    color: 'black'\n  };\n  board[0][7] = {\n    type: 'rook',\n    color: 'black'\n  };\n  board[7][0] = {\n    type: 'rook',\n    color: 'white'\n  };\n  board[7][7] = {\n    type: 'rook',\n    color: 'white'\n  };\n\n  // Set up knights\n  board[0][1] = {\n    type: 'knight',\n    color: 'black'\n  };\n  board[0][6] = {\n    type: 'knight',\n    color: 'black'\n  };\n  board[7][1] = {\n    type: 'knight',\n    color: 'white'\n  };\n  board[7][6] = {\n    type: 'knight',\n    color: 'white'\n  };\n\n  // Set up bishops\n  board[0][2] = {\n    type: 'bishop',\n    color: 'black'\n  };\n  board[0][5] = {\n    type: 'bishop',\n    color: 'black'\n  };\n  board[7][2] = {\n    type: 'bishop',\n    color: 'white'\n  };\n  board[7][5] = {\n    type: 'bishop',\n    color: 'white'\n  };\n\n  // Set up queens\n  board[0][3] = {\n    type: 'queen',\n    color: 'black'\n  };\n  board[7][3] = {\n    type: 'queen',\n    color: 'white'\n  };\n\n  // Set up kings\n  board[0][4] = {\n    type: 'king',\n    color: 'black'\n  };\n  board[7][4] = {\n    type: 'king',\n    color: 'white'\n  };\n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = board => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, moveHistory) => {\n  const piece = board[fromRow][fromCol];\n  if (!piece) return false;\n\n  // Can't move to a square with a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) return false;\n\n  // Check if the move is valid based on piece type\n  switch (piece.type) {\n    case 'pawn':\n      return isValidPawnMove(board, fromRow, fromCol, toRow, toCol);\n    case 'rook':\n      return isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n    case 'knight':\n      return isValidKnightMove(board, fromRow, fromCol, toRow, toCol);\n    case 'bishop':\n      return isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n    case 'queen':\n      return isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n    case 'king':\n      return isValidKingMove(board, fromRow, fromCol, toRow, toCol);\n    default:\n      return false;\n  }\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  const startRow = piece.color === 'white' ? 6 : 1;\n\n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n\n  // Moving forward two squares from starting position\n  if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction && !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n\n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n    return true;\n  }\n\n  // TODO: En passant (not implemented for simplicity)\n\n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n\n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  return rowDiff === 2 && colDiff === 1 || rowDiff === 1 && colDiff === 2;\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  if (rowDiff !== colDiff) return false;\n\n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n\n  // TODO: Castling (not implemented for simplicity)\n\n  return rowDiff <= 1 && colDiff <= 1;\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n\n  // TODO: Handle pawn promotion (not implemented for simplicity)\n\n  return newBoard;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = board => {\n  const pieceValues = {\n    'pawn': 1,\n    'knight': 3,\n    'bishop': 3,\n    'rook': 5,\n    'queen': 9,\n    'king': 100\n  };\n  let score = 0;\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = pieceValues[piece.type];\n        if (piece.color === 'white') {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, [])) {\n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Minimax algorithm for AI (simplified version with limited depth)\nconst minimax = (board, depth, isMaximizing, alpha, beta) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white');\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const newBoard = makeMove(board, fromRow, fromCol, toRow, toCol);\n      const evaluation = minimax(newBoard, depth - 1, false, alpha, beta);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black');\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const newBoard = makeMove(board, fromRow, fromCol, toRow, toCol);\n      const evaluation = minimax(newBoard, depth - 1, true, alpha, beta);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, moveHistory) => {\n  const moves = findAllValidMoves(board, color);\n  if (moves.length === 0) return null;\n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n\n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  for (const move of moves) {\n    const {\n      fromRow,\n      fromCol,\n      toRow,\n      toCol\n    } = move;\n    const newBoard = makeMove(board, fromRow, fromCol, toRow, toCol);\n\n    // Use a limited depth for performance (can be increased for stronger AI)\n    const value = minimax(newBoard, 2, !isMaximizing, -Infinity, Infinity);\n    if (isMaximizing && value > bestValue || !isMaximizing && value < bestValue) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  return bestMove;\n};","map":{"version":3,"names":["initializeBoard","board","Array","fill","map","col","type","color","cloneBoard","JSON","parse","stringify","isValidMove","fromRow","fromCol","toRow","toCol","moveHistory","piece","targetPiece","isValidPawnMove","isValidRookMove","isValidKnightMove","isValidBishopMove","isValidQueenMove","isValidKingMove","direction","startRow","Math","abs","start","min","end","max","row","rowDiff","colDiff","rowDirection","colDirection","i","makeMove","newBoard","evaluateBoard","pieceValues","score","value","findAllValidMoves","moves","push","minimax","depth","isMaximizing","alpha","beta","maxEval","Infinity","move","evaluation","minEval","getAIMove","length","bestMove","bestValue"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/utils/chessLogic.js"],"sourcesContent":["// Initialize the chess board with pieces in their starting positions\nexport const initializeBoard = () => {\n  const board = Array(8).fill().map(() => Array(8).fill(null));\n  \n  // Set up pawns\n  for (let col = 0; col < 8; col++) {\n    board[1][col] = { type: 'pawn', color: 'black' };\n    board[6][col] = { type: 'pawn', color: 'white' };\n  }\n  \n  // Set up rooks\n  board[0][0] = { type: 'rook', color: 'black' };\n  board[0][7] = { type: 'rook', color: 'black' };\n  board[7][0] = { type: 'rook', color: 'white' };\n  board[7][7] = { type: 'rook', color: 'white' };\n  \n  // Set up knights\n  board[0][1] = { type: 'knight', color: 'black' };\n  board[0][6] = { type: 'knight', color: 'black' };\n  board[7][1] = { type: 'knight', color: 'white' };\n  board[7][6] = { type: 'knight', color: 'white' };\n  \n  // Set up bishops\n  board[0][2] = { type: 'bishop', color: 'black' };\n  board[0][5] = { type: 'bishop', color: 'black' };\n  board[7][2] = { type: 'bishop', color: 'white' };\n  board[7][5] = { type: 'bishop', color: 'white' };\n  \n  // Set up queens\n  board[0][3] = { type: 'queen', color: 'black' };\n  board[7][3] = { type: 'queen', color: 'white' };\n  \n  // Set up kings\n  board[0][4] = { type: 'king', color: 'black' };\n  board[7][4] = { type: 'king', color: 'white' };\n  \n  return board;\n};\n\n// Deep clone the board to avoid mutation\nexport const cloneBoard = (board) => {\n  return JSON.parse(JSON.stringify(board));\n};\n\n// Check if a move is valid\nexport const isValidMove = (board, fromRow, fromCol, toRow, toCol, moveHistory) => {\n  const piece = board[fromRow][fromCol];\n  if (!piece) return false;\n  \n  // Can't move to a square with a piece of the same color\n  const targetPiece = board[toRow][toCol];\n  if (targetPiece && targetPiece.color === piece.color) return false;\n  \n  // Check if the move is valid based on piece type\n  switch (piece.type) {\n    case 'pawn':\n      return isValidPawnMove(board, fromRow, fromCol, toRow, toCol);\n    case 'rook':\n      return isValidRookMove(board, fromRow, fromCol, toRow, toCol);\n    case 'knight':\n      return isValidKnightMove(board, fromRow, fromCol, toRow, toCol);\n    case 'bishop':\n      return isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n    case 'queen':\n      return isValidQueenMove(board, fromRow, fromCol, toRow, toCol);\n    case 'king':\n      return isValidKingMove(board, fromRow, fromCol, toRow, toCol);\n    default:\n      return false;\n  }\n};\n\n// Check if a pawn move is valid\nconst isValidPawnMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const piece = board[fromRow][fromCol];\n  const direction = piece.color === 'white' ? -1 : 1;\n  const startRow = piece.color === 'white' ? 6 : 1;\n  \n  // Moving forward one square\n  if (fromCol === toCol && toRow === fromRow + direction && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Moving forward two squares from starting position\n  if (fromCol === toCol && fromRow === startRow && toRow === fromRow + 2 * direction &&\n      !board[fromRow + direction][fromCol] && !board[toRow][toCol]) {\n    return true;\n  }\n  \n  // Capturing diagonally\n  if (Math.abs(fromCol - toCol) === 1 && toRow === fromRow + direction && \n      board[toRow][toCol] && board[toRow][toCol].color !== piece.color) {\n    return true;\n  }\n  \n  // TODO: En passant (not implemented for simplicity)\n  \n  return false;\n};\n\n// Check if a rook move is valid\nconst isValidRookMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Rooks move horizontally or vertically\n  if (fromRow !== toRow && fromCol !== toCol) return false;\n  \n  // Check if path is clear\n  if (fromRow === toRow) {\n    // Horizontal move\n    const start = Math.min(fromCol, toCol);\n    const end = Math.max(fromCol, toCol);\n    for (let col = start + 1; col < end; col++) {\n      if (board[fromRow][col]) return false;\n    }\n  } else {\n    // Vertical move\n    const start = Math.min(fromRow, toRow);\n    const end = Math.max(fromRow, toRow);\n    for (let row = start + 1; row < end; row++) {\n      if (board[row][fromCol]) return false;\n    }\n  }\n  \n  return true;\n};\n\n// Check if a knight move is valid\nconst isValidKnightMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Knights move in an L-shape: 2 squares in one direction and 1 square perpendicular\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);\n};\n\n// Check if a bishop move is valid\nconst isValidBishopMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Bishops move diagonally\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  if (rowDiff !== colDiff) return false;\n  \n  // Check if path is clear\n  const rowDirection = fromRow < toRow ? 1 : -1;\n  const colDirection = fromCol < toCol ? 1 : -1;\n  \n  for (let i = 1; i < rowDiff; i++) {\n    if (board[fromRow + i * rowDirection][fromCol + i * colDirection]) return false;\n  }\n  \n  return true;\n};\n\n// Check if a queen move is valid\nconst isValidQueenMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Queens can move like rooks or bishops\n  return isValidRookMove(board, fromRow, fromCol, toRow, toCol) || \n         isValidBishopMove(board, fromRow, fromCol, toRow, toCol);\n};\n\n// Check if a king move is valid\nconst isValidKingMove = (board, fromRow, fromCol, toRow, toCol) => {\n  // Kings move one square in any direction\n  const rowDiff = Math.abs(fromRow - toRow);\n  const colDiff = Math.abs(fromCol - toCol);\n  \n  // TODO: Castling (not implemented for simplicity)\n  \n  return rowDiff <= 1 && colDiff <= 1;\n};\n\n// Make a move on the board\nexport const makeMove = (board, fromRow, fromCol, toRow, toCol) => {\n  const newBoard = cloneBoard(board);\n  newBoard[toRow][toCol] = newBoard[fromRow][fromCol];\n  newBoard[fromRow][fromCol] = null;\n  \n  // TODO: Handle pawn promotion (not implemented for simplicity)\n  \n  return newBoard;\n};\n\n// Evaluate the board position (for AI)\nconst evaluateBoard = (board) => {\n  const pieceValues = {\n    'pawn': 1,\n    'knight': 3,\n    'bishop': 3,\n    'rook': 5,\n    'queen': 9,\n    'king': 100\n  };\n  \n  let score = 0;\n  \n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece) {\n        const value = pieceValues[piece.type];\n        if (piece.color === 'white') {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  \n  return score;\n};\n\n// Find all valid moves for a player\nconst findAllValidMoves = (board, color) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, [])) {\n              moves.push({ fromRow, fromCol, toRow, toCol });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Minimax algorithm for AI (simplified version with limited depth)\nconst minimax = (board, depth, isMaximizing, alpha, beta) => {\n  if (depth === 0) {\n    return evaluateBoard(board);\n  }\n  \n  if (isMaximizing) {\n    // White's turn (maximizing)\n    let maxEval = -Infinity;\n    const moves = findAllValidMoves(board, 'white');\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const newBoard = makeMove(board, fromRow, fromCol, toRow, toCol);\n      const evaluation = minimax(newBoard, depth - 1, false, alpha, beta);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return maxEval;\n  } else {\n    // Black's turn (minimizing)\n    let minEval = Infinity;\n    const moves = findAllValidMoves(board, 'black');\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const newBoard = makeMove(board, fromRow, fromCol, toRow, toCol);\n      const evaluation = minimax(newBoard, depth - 1, true, alpha, beta);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) break; // Alpha-beta pruning\n    }\n    \n    return minEval;\n  }\n};\n\n// Get the best move for the AI\nexport const getAIMove = (board, color, moveHistory) => {\n  const moves = findAllValidMoves(board, color);\n  if (moves.length === 0) return null;\n  \n  let bestMove = null;\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // For black (AI), we want to minimize the score\n  const isMaximizing = color === 'white';\n  \n  for (const move of moves) {\n    const { fromRow, fromCol, toRow, toCol } = move;\n    const newBoard = makeMove(board, fromRow, fromCol, toRow, toCol);\n    \n    // Use a limited depth for performance (can be increased for stronger AI)\n    const value = minimax(newBoard, 2, !isMaximizing, -Infinity, Infinity);\n    \n    if ((isMaximizing && value > bestValue) || (!isMaximizing && value < bestValue)) {\n      bestValue = value;\n      bestMove = move;\n    }\n  }\n  \n  return bestMove;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}