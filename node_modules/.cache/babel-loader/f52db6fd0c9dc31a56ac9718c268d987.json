{"ast":null,"code":"import { makeMove, isValidMove,\n// eslint-disable-next-line no-unused-vars\nisInCheck, isCheckmate, isStalemate } from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [[0, 0, 0, 0, 0, 0, 0, 0], [5, 5, 5, 5, 5, 5, 5, 5], [1, 1, 2, 3, 3, 2, 1, 1], [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5], [0, 0, 0, 2, 2, 0, 0, 0], [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5], [0.5, 1, 1, -2, -2, 1, 1, 0.5], [0, 0, 0, 0, 0, 0, 0, 0]],\n  'knight': [[-5, -4, -3, -3, -3, -3, -4, -5], [-4, -2, 0, 0, 0, 0, -2, -4], [-3, 0, 1, 1.5, 1.5, 1, 0, -3], [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3], [-3, 0, 1.5, 2, 2, 1.5, 0, -3], [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3], [-4, -2, 0, 0.5, 0.5, 0, -2, -4], [-5, -4, -3, -3, -3, -3, -4, -5]],\n  'bishop': [[-2, -1, -1, -1, -1, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 1, 1, 0.5, 0, -1], [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1], [-1, 0, 1, 1, 1, 1, 0, -1], [-1, 1, 1, 1, 1, 1, 1, -1], [-1, 0.5, 0, 0, 0, 0, 0.5, -1], [-2, -1, -1, -1, -1, -1, -1, -2]],\n  'rook': [[0, 0, 0, 0, 0, 0, 0, 0], [0.5, 1, 1, 1, 1, 1, 1, 0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [-0.5, 0, 0, 0, 0, 0, 0, -0.5], [0, 0, 0, 0.5, 0.5, 0, 0, 0]],\n  'queen': [[-2, -1, -1, -0.5, -0.5, -1, -1, -2], [-1, 0, 0, 0, 0, 0, 0, -1], [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1], [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5], [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1], [-1, 0, 0.5, 0, 0, 0, 0, -1], [-2, -1, -1, -0.5, -0.5, -1, -1, -2]],\n  'king': [[-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-3, -4, -4, -5, -5, -4, -4, -3], [-2, -3, -3, -4, -4, -3, -3, -2], [-1, -2, -2, -2, -2, -2, -2, -1], [2, 2, 0, 0, 0, 0, 2, 2], [2, 3, 1, 0, 0, 1, 3, 2]]\n};\n\n// Simple move cache to avoid recalculating positions\nconst moveCache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (moveCache.size > MAX_CACHE_SIZE) {\n    // Clear half of the cache (oldest entries)\n    const keys = Array.from(moveCache.keys());\n    for (let i = 0; i < keys.length / 2; i++) {\n      moveCache.delete(keys[i]);\n    }\n  }\n};\n\n// Get cache key for a position\nconst getCacheKey = (board, depth, maximizingPlayer, color) => {\n  return JSON.stringify(board) + depth + maximizingPlayer + color;\n};\n\n// Evaluate the board position - simplified for speed\nconst evaluateBoard = (board, color) => {\n  let score = 0;\n\n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && !piece.captured) {\n        // Material value\n        const materialValue = pieceValues[piece.type];\n\n        // Position value (flipped for black)\n        let positionValue = 0;\n        if (piece.color === 'white') {\n          positionValue = positionBonus[piece.type][row][col];\n        } else {\n          positionValue = positionBonus[piece.type][7 - row][col];\n        }\n\n        // Add to score (positive for white, negative for black)\n        const value = materialValue + positionValue;\n        if (piece.color === 'white') {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n\n  // Adjust score based on check/checkmate\n  if (isCheckmate(board, 'white')) {\n    score = -10000; // Black wins\n  } else if (isCheckmate(board, 'black')) {\n    score = 10000; // White wins\n  } else if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    score = 0; // Draw\n  }\n\n  // Return score from the perspective of the current player\n  return color === 'white' ? score : -score;\n};\n\n// Generate all valid moves for a player\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      if (piece && piece.color === color && !piece.captured) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // Check if this is a capture move\n              const isCapture = board[toRow][toCol] !== null;\n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol,\n                isCapture,\n                piece: piece.type\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  return moves;\n};\n\n// Order moves to improve alpha-beta pruning efficiency\nconst orderMoves = (moves, board) => {\n  return moves.sort((a, b) => {\n    // Prioritize captures\n    if (a.isCapture && !b.isCapture) return -1;\n    if (!a.isCapture && b.isCapture) return 1;\n\n    // If both are captures, prioritize capturing higher value pieces with lower value pieces\n    if (a.isCapture && b.isCapture) {\n      const targetA = board[a.toRow][a.toCol];\n      const targetB = board[b.toRow][b.toCol];\n      if (targetA && targetB) {\n        // MVV-LVA (Most Valuable Victim - Least Valuable Aggressor)\n        const valueA = pieceValues[targetA.type] - pieceValues[a.piece];\n        const valueB = pieceValues[targetB.type] - pieceValues[b.piece];\n        return valueB - valueA;\n      }\n    }\n\n    // Prioritize center control for non-captures\n    const aCenterDistance = Math.abs(3.5 - a.toRow) + Math.abs(3.5 - a.toCol);\n    const bCenterDistance = Math.abs(3.5 - b.toRow) + Math.abs(3.5 - b.toCol);\n    return aCenterDistance - bCenterDistance;\n  });\n};\n\n// Quiescence search to handle the horizon effect\nconst quiescenceSearch = (board, alpha, beta, maximizingPlayer, color, gameState, depth = 0) => {\n  // Limit quiescence search depth\n  if (depth > 3) {\n    return evaluateBoard(board, color);\n  }\n  const standPat = evaluateBoard(board, color);\n  if (maximizingPlayer) {\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n    const currentColor = maximizingPlayer ? color : color === 'white' ? 'black' : 'white';\n    let moves = generateMoves(board, currentColor, gameState);\n\n    // Only consider captures for quiescence search\n    moves = moves.filter(move => move.isCapture);\n    moves = orderMoves(moves, board);\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const score = quiescenceSearch(newBoard, alpha, beta, false, color, newGameState, depth + 1);\n      if (score >= beta) return beta;\n      if (score > alpha) alpha = score;\n    }\n    return alpha;\n  } else {\n    if (standPat <= alpha) return alpha;\n    if (beta > standPat) beta = standPat;\n    const currentColor = maximizingPlayer ? color : color === 'white' ? 'black' : 'white';\n    let moves = generateMoves(board, currentColor, gameState);\n\n    // Only consider captures for quiescence search\n    moves = moves.filter(move => move.isCapture);\n    moves = orderMoves(moves, board);\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const score = quiescenceSearch(newBoard, alpha, beta, true, color, newGameState, depth + 1);\n      if (score <= alpha) return alpha;\n      if (score < beta) beta = score;\n    }\n    return beta;\n  }\n};\n\n// Minimax algorithm with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, maximizingPlayer, color, gameState) => {\n  // Check cache first\n  const cacheKey = getCacheKey(board, depth, maximizingPlayer, color);\n  if (moveCache.has(cacheKey)) {\n    return moveCache.get(cacheKey);\n  }\n\n  // Base case: depth reached or game over\n  if (depth === 0) {\n    // Use quiescence search to handle horizon effect\n    return quiescenceSearch(board, alpha, beta, maximizingPlayer, color, gameState);\n  }\n  if (isCheckmate(board, 'white') || isCheckmate(board, 'black') || isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    const score = evaluateBoard(board, color);\n    moveCache.set(cacheKey, score);\n    return score;\n  }\n  const currentColor = maximizingPlayer ? color : color === 'white' ? 'black' : 'white';\n  let moves = generateMoves(board, currentColor, gameState);\n\n  // Order moves to improve alpha-beta pruning\n  moves = orderMoves(moves, board);\n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, color, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    moveCache.set(cacheKey, maxEval);\n    checkCacheSize();\n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    for (const move of moves) {\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, color, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    moveCache.set(cacheKey, minEval);\n    checkCacheSize();\n    return minEval;\n  }\n};\n\n// Find the best move using minimax with a time limit\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Set depth based on difficulty - reduced for faster response\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 1;\n      break;\n    case 'medium':\n      depth = 2;\n      break;\n    case 'hard':\n      depth = 2; // Reduced from 3 to 2 for faster response\n      break;\n    default:\n      depth = 1;\n  }\n\n  // Generate all valid moves\n  let moves = generateMoves(board, color, gameState);\n\n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n\n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n\n  // Order moves to improve alpha-beta pruning\n  moves = orderMoves(moves, board);\n\n  // Add some randomness for variety and to make the AI less predictable\n  if (Math.random() < 0.1) {\n    // 10% chance to make a random move\n    const randomIndex = Math.floor(Math.random() * moves.length);\n    return moves[randomIndex];\n  }\n  let bestMove = moves[0]; // Default to first move\n  // eslint-disable-next-line no-unused-vars\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n\n  // Set a timeout for the AI's thinking\n  const startTime = Date.now();\n  const timeLimit = difficulty === 'easy' ? 300 : difficulty === 'medium' ? 500 : 800;\n\n  // Iterative deepening - start with depth 1 and increase if time allows\n  for (let currentDepth = 1; currentDepth <= depth; currentDepth++) {\n    // Check if we've exceeded the time limit\n    if (Date.now() - startTime > timeLimit) {\n      break;\n    }\n    let tempBestMove = null;\n    let tempBestValue = color === 'white' ? -Infinity : Infinity;\n    for (const move of moves) {\n      // Check if we've exceeded the time limit\n      if (Date.now() - startTime > timeLimit) {\n        break;\n      }\n      const {\n        fromRow,\n        fromCol,\n        toRow,\n        toCol\n      } = move;\n      const {\n        board: newBoard,\n        gameState: newGameState\n      } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      const value = minimax(newBoard, currentDepth - 1, -Infinity, Infinity, color === 'black',\n      // If black, next player is white (maximizing)\n      color, newGameState);\n      if (color === 'white' && value > tempBestValue || color === 'black' && value < tempBestValue) {\n        tempBestValue = value;\n        tempBestMove = move;\n      }\n    }\n    if (tempBestMove) {\n      bestMove = tempBestMove;\n      bestValue = tempBestValue;\n    }\n  }\n\n  // Clear cache periodically to prevent memory issues\n  if (Math.random() < 0.1) {\n    moveCache.clear();\n  }\n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n};","map":{"version":3,"names":["makeMove","isValidMove","isInCheck","isCheckmate","isStalemate","pieceValues","positionBonus","moveCache","Map","MAX_CACHE_SIZE","checkCacheSize","size","keys","Array","from","i","length","delete","getCacheKey","board","depth","maximizingPlayer","color","JSON","stringify","evaluateBoard","score","row","col","piece","captured","materialValue","type","positionValue","value","generateMoves","gameState","moves","fromRow","fromCol","toRow","toCol","isCapture","push","orderMoves","sort","a","b","targetA","targetB","valueA","valueB","aCenterDistance","Math","abs","bCenterDistance","quiescenceSearch","alpha","beta","standPat","currentColor","filter","move","newBoard","newGameState","minimax","cacheKey","has","get","set","maxEval","Infinity","evaluation","max","minEval","min","findBestMove","difficulty","random","randomIndex","floor","bestMove","bestValue","startTime","Date","now","timeLimit","currentDepth","tempBestMove","tempBestValue","clear","getAIMove"],"sources":["/Users/aditya.thakkar/Documents/AI Chess/src/utils/aiPlayer.js"],"sourcesContent":["import { \n  makeMove, \n  isValidMove, \n  // eslint-disable-next-line no-unused-vars\n  isInCheck, \n  isCheckmate, \n  isStalemate \n} from './chessLogic';\n\n// Piece values for evaluation\nconst pieceValues = {\n  'pawn': 10,\n  'knight': 30,\n  'bishop': 30,\n  'rook': 50,\n  'queen': 90,\n  'king': 900\n};\n\n// Position bonuses to encourage good piece placement\nconst positionBonus = {\n  'pawn': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [5, 5, 5, 5, 5, 5, 5, 5],\n    [1, 1, 2, 3, 3, 2, 1, 1],\n    [0.5, 0.5, 1, 2.5, 2.5, 1, 0.5, 0.5],\n    [0, 0, 0, 2, 2, 0, 0, 0],\n    [0.5, -0.5, -1, 0, 0, -1, -0.5, 0.5],\n    [0.5, 1, 1, -2, -2, 1, 1, 0.5],\n    [0, 0, 0, 0, 0, 0, 0, 0]\n  ],\n  'knight': [\n    [-5, -4, -3, -3, -3, -3, -4, -5],\n    [-4, -2, 0, 0, 0, 0, -2, -4],\n    [-3, 0, 1, 1.5, 1.5, 1, 0, -3],\n    [-3, 0.5, 1.5, 2, 2, 1.5, 0.5, -3],\n    [-3, 0, 1.5, 2, 2, 1.5, 0, -3],\n    [-3, 0.5, 1, 1.5, 1.5, 1, 0.5, -3],\n    [-4, -2, 0, 0.5, 0.5, 0, -2, -4],\n    [-5, -4, -3, -3, -3, -3, -4, -5]\n  ],\n  'bishop': [\n    [-2, -1, -1, -1, -1, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 1, 1, 0.5, 0, -1],\n    [-1, 0.5, 0.5, 1, 1, 0.5, 0.5, -1],\n    [-1, 0, 1, 1, 1, 1, 0, -1],\n    [-1, 1, 1, 1, 1, 1, 1, -1],\n    [-1, 0.5, 0, 0, 0, 0, 0.5, -1],\n    [-2, -1, -1, -1, -1, -1, -1, -2]\n  ],\n  'rook': [\n    [0, 0, 0, 0, 0, 0, 0, 0],\n    [0.5, 1, 1, 1, 1, 1, 1, 0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [-0.5, 0, 0, 0, 0, 0, 0, -0.5],\n    [0, 0, 0, 0.5, 0.5, 0, 0, 0]\n  ],\n  'queen': [\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2],\n    [-1, 0, 0, 0, 0, 0, 0, -1],\n    [-1, 0, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-0.5, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [0, 0, 0.5, 0.5, 0.5, 0.5, 0, -0.5],\n    [-1, 0.5, 0.5, 0.5, 0.5, 0.5, 0, -1],\n    [-1, 0, 0.5, 0, 0, 0, 0, -1],\n    [-2, -1, -1, -0.5, -0.5, -1, -1, -2]\n  ],\n  'king': [\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-3, -4, -4, -5, -5, -4, -4, -3],\n    [-2, -3, -3, -4, -4, -3, -3, -2],\n    [-1, -2, -2, -2, -2, -2, -2, -1],\n    [2, 2, 0, 0, 0, 0, 2, 2],\n    [2, 3, 1, 0, 0, 1, 3, 2]\n  ]\n};\n\n// Simple move cache to avoid recalculating positions\nconst moveCache = new Map();\nconst MAX_CACHE_SIZE = 1000;\n\n// Clear cache when it gets too large\nconst checkCacheSize = () => {\n  if (moveCache.size > MAX_CACHE_SIZE) {\n    // Clear half of the cache (oldest entries)\n    const keys = Array.from(moveCache.keys());\n    for (let i = 0; i < keys.length / 2; i++) {\n      moveCache.delete(keys[i]);\n    }\n  }\n};\n\n// Get cache key for a position\nconst getCacheKey = (board, depth, maximizingPlayer, color) => {\n  return JSON.stringify(board) + depth + maximizingPlayer + color;\n};\n\n// Evaluate the board position - simplified for speed\nconst evaluateBoard = (board, color) => {\n  let score = 0;\n  \n  // Count material and position value\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const piece = board[row][col];\n      if (piece && !piece.captured) {\n        // Material value\n        const materialValue = pieceValues[piece.type];\n        \n        // Position value (flipped for black)\n        let positionValue = 0;\n        if (piece.color === 'white') {\n          positionValue = positionBonus[piece.type][row][col];\n        } else {\n          positionValue = positionBonus[piece.type][7 - row][col];\n        }\n        \n        // Add to score (positive for white, negative for black)\n        const value = materialValue + positionValue;\n        if (piece.color === 'white') {\n          score += value;\n        } else {\n          score -= value;\n        }\n      }\n    }\n  }\n  \n  // Adjust score based on check/checkmate\n  if (isCheckmate(board, 'white')) {\n    score = -10000; // Black wins\n  } else if (isCheckmate(board, 'black')) {\n    score = 10000; // White wins\n  } else if (isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    score = 0; // Draw\n  }\n  \n  // Return score from the perspective of the current player\n  return color === 'white' ? score : -score;\n};\n\n// Generate all valid moves for a player\nconst generateMoves = (board, color, gameState) => {\n  const moves = [];\n  \n  for (let fromRow = 0; fromRow < 8; fromRow++) {\n    for (let fromCol = 0; fromCol < 8; fromCol++) {\n      const piece = board[fromRow][fromCol];\n      \n      if (piece && piece.color === color && !piece.captured) {\n        for (let toRow = 0; toRow < 8; toRow++) {\n          for (let toCol = 0; toCol < 8; toCol++) {\n            if (isValidMove(board, fromRow, fromCol, toRow, toCol, gameState)) {\n              // Check if this is a capture move\n              const isCapture = board[toRow][toCol] !== null;\n              \n              moves.push({\n                fromRow,\n                fromCol,\n                toRow,\n                toCol,\n                isCapture,\n                piece: piece.type\n              });\n            }\n          }\n        }\n      }\n    }\n  }\n  \n  return moves;\n};\n\n// Order moves to improve alpha-beta pruning efficiency\nconst orderMoves = (moves, board) => {\n  return moves.sort((a, b) => {\n    // Prioritize captures\n    if (a.isCapture && !b.isCapture) return -1;\n    if (!a.isCapture && b.isCapture) return 1;\n    \n    // If both are captures, prioritize capturing higher value pieces with lower value pieces\n    if (a.isCapture && b.isCapture) {\n      const targetA = board[a.toRow][a.toCol];\n      const targetB = board[b.toRow][b.toCol];\n      \n      if (targetA && targetB) {\n        // MVV-LVA (Most Valuable Victim - Least Valuable Aggressor)\n        const valueA = pieceValues[targetA.type] - pieceValues[a.piece];\n        const valueB = pieceValues[targetB.type] - pieceValues[b.piece];\n        return valueB - valueA;\n      }\n    }\n    \n    // Prioritize center control for non-captures\n    const aCenterDistance = Math.abs(3.5 - a.toRow) + Math.abs(3.5 - a.toCol);\n    const bCenterDistance = Math.abs(3.5 - b.toRow) + Math.abs(3.5 - b.toCol);\n    return aCenterDistance - bCenterDistance;\n  });\n};\n\n// Quiescence search to handle the horizon effect\nconst quiescenceSearch = (board, alpha, beta, maximizingPlayer, color, gameState, depth = 0) => {\n  // Limit quiescence search depth\n  if (depth > 3) {\n    return evaluateBoard(board, color);\n  }\n  \n  const standPat = evaluateBoard(board, color);\n  \n  if (maximizingPlayer) {\n    if (standPat >= beta) return beta;\n    if (alpha < standPat) alpha = standPat;\n    \n    const currentColor = maximizingPlayer ? color : (color === 'white' ? 'black' : 'white');\n    let moves = generateMoves(board, currentColor, gameState);\n    \n    // Only consider captures for quiescence search\n    moves = moves.filter(move => move.isCapture);\n    moves = orderMoves(moves, board);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const score = quiescenceSearch(newBoard, alpha, beta, false, color, newGameState, depth + 1);\n      \n      if (score >= beta) return beta;\n      if (score > alpha) alpha = score;\n    }\n    \n    return alpha;\n  } else {\n    if (standPat <= alpha) return alpha;\n    if (beta > standPat) beta = standPat;\n    \n    const currentColor = maximizingPlayer ? color : (color === 'white' ? 'black' : 'white');\n    let moves = generateMoves(board, currentColor, gameState);\n    \n    // Only consider captures for quiescence search\n    moves = moves.filter(move => move.isCapture);\n    moves = orderMoves(moves, board);\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const score = quiescenceSearch(newBoard, alpha, beta, true, color, newGameState, depth + 1);\n      \n      if (score <= alpha) return alpha;\n      if (score < beta) beta = score;\n    }\n    \n    return beta;\n  }\n};\n\n// Minimax algorithm with alpha-beta pruning\nconst minimax = (board, depth, alpha, beta, maximizingPlayer, color, gameState) => {\n  // Check cache first\n  const cacheKey = getCacheKey(board, depth, maximizingPlayer, color);\n  if (moveCache.has(cacheKey)) {\n    return moveCache.get(cacheKey);\n  }\n  \n  // Base case: depth reached or game over\n  if (depth === 0) {\n    // Use quiescence search to handle horizon effect\n    return quiescenceSearch(board, alpha, beta, maximizingPlayer, color, gameState);\n  }\n  \n  if (isCheckmate(board, 'white') || isCheckmate(board, 'black') || \n      isStalemate(board, 'white') || isStalemate(board, 'black')) {\n    const score = evaluateBoard(board, color);\n    moveCache.set(cacheKey, score);\n    return score;\n  }\n  \n  const currentColor = maximizingPlayer ? color : (color === 'white' ? 'black' : 'white');\n  let moves = generateMoves(board, currentColor, gameState);\n  \n  // Order moves to improve alpha-beta pruning\n  moves = orderMoves(moves, board);\n  \n  if (maximizingPlayer) {\n    let maxEval = -Infinity;\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, color, newGameState);\n      maxEval = Math.max(maxEval, evaluation);\n      \n      alpha = Math.max(alpha, evaluation);\n      if (beta <= alpha) {\n        break; // Beta cutoff\n      }\n    }\n    \n    moveCache.set(cacheKey, maxEval);\n    checkCacheSize();\n    return maxEval;\n  } else {\n    let minEval = Infinity;\n    \n    for (const move of moves) {\n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, color, newGameState);\n      minEval = Math.min(minEval, evaluation);\n      \n      beta = Math.min(beta, evaluation);\n      if (beta <= alpha) {\n        break; // Alpha cutoff\n      }\n    }\n    \n    moveCache.set(cacheKey, minEval);\n    checkCacheSize();\n    return minEval;\n  }\n};\n\n// Find the best move using minimax with a time limit\nexport const findBestMove = (board, color, gameState, difficulty = 'medium') => {\n  // Set depth based on difficulty - reduced for faster response\n  let depth;\n  switch (difficulty) {\n    case 'easy':\n      depth = 1;\n      break;\n    case 'medium':\n      depth = 2;\n      break;\n    case 'hard':\n      depth = 2; // Reduced from 3 to 2 for faster response\n      break;\n    default:\n      depth = 1;\n  }\n  \n  // Generate all valid moves\n  let moves = generateMoves(board, color, gameState);\n  \n  // If no valid moves, return null\n  if (moves.length === 0) {\n    return null;\n  }\n  \n  // If only one move is available, return it immediately\n  if (moves.length === 1) {\n    return moves[0];\n  }\n  \n  // Order moves to improve alpha-beta pruning\n  moves = orderMoves(moves, board);\n  \n  // Add some randomness for variety and to make the AI less predictable\n  if (Math.random() < 0.1) {\n    // 10% chance to make a random move\n    const randomIndex = Math.floor(Math.random() * moves.length);\n    return moves[randomIndex];\n  }\n  \n  let bestMove = moves[0]; // Default to first move\n  // eslint-disable-next-line no-unused-vars\n  let bestValue = color === 'white' ? -Infinity : Infinity;\n  \n  // Set a timeout for the AI's thinking\n  const startTime = Date.now();\n  const timeLimit = difficulty === 'easy' ? 300 : (difficulty === 'medium' ? 500 : 800);\n  \n  // Iterative deepening - start with depth 1 and increase if time allows\n  for (let currentDepth = 1; currentDepth <= depth; currentDepth++) {\n    // Check if we've exceeded the time limit\n    if (Date.now() - startTime > timeLimit) {\n      break;\n    }\n    \n    let tempBestMove = null;\n    let tempBestValue = color === 'white' ? -Infinity : Infinity;\n    \n    for (const move of moves) {\n      // Check if we've exceeded the time limit\n      if (Date.now() - startTime > timeLimit) {\n        break;\n      }\n      \n      const { fromRow, fromCol, toRow, toCol } = move;\n      const { board: newBoard, gameState: newGameState } = makeMove(board, fromRow, fromCol, toRow, toCol, gameState);\n      \n      const value = minimax(\n        newBoard, \n        currentDepth - 1, \n        -Infinity, \n        Infinity, \n        color === 'black', // If black, next player is white (maximizing)\n        color, \n        newGameState\n      );\n      \n      if ((color === 'white' && value > tempBestValue) || (color === 'black' && value < tempBestValue)) {\n        tempBestValue = value;\n        tempBestMove = move;\n      }\n    }\n    \n    if (tempBestMove) {\n      bestMove = tempBestMove;\n      bestValue = tempBestValue;\n    }\n  }\n  \n  // Clear cache periodically to prevent memory issues\n  if (Math.random() < 0.1) {\n    moveCache.clear();\n  }\n  \n  return bestMove;\n};\n\n// Export a function that matches the getAIMove signature from chessLogic\nexport const getAIMove = (board, color, gameState, difficulty) => {\n  return findBestMove(board, color, gameState, difficulty);\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}